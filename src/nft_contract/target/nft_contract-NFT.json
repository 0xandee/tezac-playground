{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "NFT",
  "functions": [
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "new_admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAACYHgIAAgAeAgADADM4AAIAAwAEJwICAQEkAgAEAAAAbyUAAADBJwICAAUvDAACAAMeAgAEAQo4AwQFJAIABQAAAJElAAAA0zAMAAEAAiYoAIAEBHgADQAAAIAEgAMkAIADAAAAwCoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFedUGXr5zdNI8AQECJg==",
      "debug_symbols": "5ZXdisIwEIXfJde9mMlMkomvsixStUqhtFLrwiK++ybS1KrFgog3eyNO+dJz5qeZk9oUq+NuWdbb5qAWXydVNeu8K5s6RKdzplZtWVXlbjl+rCD+OHPhD/u8juGhy9tOLZC0gUwV9Sb+JzHhHduyKkKEfM4eedA64cB6ROMEzdZiT7N1MNDOT8BiwPSwGI1j+DtTAu+x733CEf0H7b+p+kaG6stc9dE4l2hL9Ny+Nz7l6i3xnX1P77aP+tZ+FJEPiCDYT6ggTqkQQOoIgb5qGJiSQDaDxGj6MDb+gXZGuKedBfO82Y6EEswj95MwIjk7GGHwd7OBaP9PrlpP50o45Mr+ea4slNyzsJ67VZwebhVxD3bcbOmNHtuJh0i/cIjhlUNm+pCkS5jCNTYzGQyptMjazUyGAKX2SfhCZyZDKPlw4mFuMliuI2q0vWnFOUQ/eVvmq6roN/H2WK9Hi7n73Rd3O3rfNutic2yLuK2vixpjpbVkRJePKwTkMvJBI+j8AQ==",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "_finalize_transfer_to_private_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17922298012674089187": {
            "error_kind": "string",
            "string": "Cannot complete a PartialNFTNote with a value of 0"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finalize_transfer_to_private_unsafe"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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X5He/xXz+78iv/8rytu/4sXyT9WveP9fd3n/X3d5/193ef9fd3n/X3d5/193ef9fd3n/X3d5+1+3m6b3f8WP/7rvp/lzp4Vzp8m50+K509K50+Zzp+Vzp5VTp7np3GnnqsSdqxJ3rkrcuSpx56rEnasSd65K3LkqceeqxJ+rEn+uSvy5KvHnqsSfqxJ/rkr8uSrx56rEn6sSf65KwrkqCeeqJJyrknCuSsK5KgnnqiScq5JwrkrCuSoJ56pEzlWJnKsSOVclcq5K5FyVyLkqkXNVIueqRM5ViZyrkniuSuK5KonnqiSeq5J4rkriuSqJ56oknquSeK5K4rkqSeeqJJ2rknSuStK5KknnqiSdq5J0rkrSuSpJ56oknauS+VyVzOeqZD5XJfO5KpnPVcl8rkrmc1Uyn6uS+VyVzOeqJJ+rknyuSvK5KsnnqiSfq5J8rkryuSrJ56okn6uSfK5KyrkqKeeqpJyrknKuSsq5KinnqqScq5JyrkrKuSopp6rET9O509y50/y508K50+TcafHcaencafO50/K5085Vybns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NW/yF7L+vDeLa5zG6e9qJJ5Xk8r/tNpWzvOVnqfxW04s63hZFvDKaaG8yrb1hqOszUcb2s4wdZwxNZwoq3h2LoqF1tX5WLrqlxMXZXDZOqqHCZTV+Uwmboqh8nUVTlMV1+Vd1/FdBtPNDaeZGw8s7HxZGPjKbbG4358bb6f5s6d5s+dtnlNuq1iLlt43NYK4wE0l+awvt03zemxsc7WTgc3q7xsInO7X4SDz07TtG6ANYWnHbCm9DEBMT6BOC0KpBjCxgRi6xNIrU9gbn0CufUJlMYnsP0cRksTcK1PwLc+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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "get_private_nfts",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "page_index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "tuple",
            "fields": [
              {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              },
              {
                "kind": "boolean"
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3fjuw8cuX7Ln3dFyIZ/DevMjgwbI9n0EDDHtieAxwM/O4n91ZJmfUVJVbxUyqCEeumsbtbzGT8VpQYK6ik/u9f/se//NP/+V//8Ld//Z//9h9/+W///f/+5e//9s//+J9/+7d/ffy3//tff/3LP/373/7+97/9r394/Z//svz6Dxfc7wH/8b//8V9//ff/+M9//Pf//Mt/cwu58te//Mu//o/f/8758SH/829//5fHf3P0X3/9cn0u6ePqstB+bXGNS6OPH5fGuDw/Nqb/+n/++piOv2I6JeRtOrGeT4dC/biUUvk6nXDJdApt06nlfDpp2egkn75Oh66YTvX+4+oaYmc6Zfm4NC8NsWJzOqG47QtcqNl1puPr4j4uD0t6Cdp9fEu65VvyLd9SbvmWese30HLLt7hbvsXf8i3hlm+hW77llr99uuVvn27526db/vbplr/9eMvffrzlbz/e8rcfb/nbj7f87cdb/vbjLX/78Za//XjL33685W8/3fK3n27520+3/O2nW/720y1/++mWv/10y99+uuVvP93yt59u+dvPt/zt51v+9vMtf/v5lr/9fMvffr7lbz/f8refb/nbz7f87edb/vbLLX/75Za//XLL33655W+/3PK3X2752y+3/O2XW/72yy1/++WWv/16y99+veVvv97yt19v+duvt/zt11v+9ustf/v1kr/9sMS0f0t93XCp67eUW76l3vAtfllu+RZ3y7f4W77lkr/98NjL277F+/rpW75e/WiXbXN69E7882ofWrueJXxcHMPL30hK6/yJYf5l3/l81IClM/+Y8r6LnErYr87LGkCcPYA0ewB59gDK7AHUyQNwy+wBuNkD8LMHEGYPYPaV2MlfiTNthVPMkV4DaLiL6LbCyceXaTcvLnGbRsmvz3I1bYvbH1l7MHt+MPnWxeVpcT5d+pu4/NJBG3H5tY424vKLM23E5VeTyoh7+eWvNuLy63VtxOUbDG3E5TsibcQJxG8mDs95N3F4zruJw3PeTRye827i8Jw3Ew/wnHcTh+e8mzg8593E4TnvJk4gfjNxeM67icNz3k0cnvNu4vCcdxOH57yZOMFz3k0cnvNu4vCcdxOfwXO6J/FyDtGV/RcnrvrQ+WhHdTvUzsXsXz/6NxsCm0M2M/g4LjYzOC4uNjN4Iy42M7gYLjYz+A0mNnEGZ8DFZoYa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",
      "brillig_names": [
        "get_private_nfts"
      ]
    },
    {
      "name": "finalize_transfer_to_private",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17922298012674089187": {
            "error_kind": "string",
            "string": "Cannot complete a PartialNFTNote with a value of 0"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "finalize_transfer_to_private"
      ]
    },
    {
      "name": "get_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQAFLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFi40qC3IiUlA8AQECJg==",
      "debug_symbols": "5ZXdisIwEIXfJde9yGRm8uOrLItUjVIordS6sIjvvok0tdayXUR6szfiyDeek5wMcxE7vzkf1kW1r09i9XERZb3N26KuQnW5ZmLTFGVZHNbDn4WMH4Zv/OmYV7E8tXnTihWgYpkJX+3id7Qc/mNflD5UQNfsmZdKJVySGtAwQZPW0NGkjexp4yZgy5I72LKCIfyZCSvfY9+5hAO4Be2/6fbZ9rdv524f2JhEa8Tf7Tt26axOI43sO3y3fVCP9qOIXUAEpF5CBWBSRYWXkdoUE86omPBeO9wEfiZBpdNoOmV5lCCA/oujx3PHPgUv9r2oh/Rin5vqI7qPMJn7wLOcChWI+1AH8w5x1J7DYUspHC1nwjFoMcE0eC+TMAAa3Rsh6cZZEv2Ts15D9ZU3Rb4pfbfh9udqO1h47ffRj3bfsam3fndufNyC9wUIcYMolyHdxiEUyBmaoBF0fgA=",
      "brillig_names": [
        "get_admin"
      ]
    },
    {
      "name": "set_minter",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "minter",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "approve",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHxgABAADgEgdAIBJgEkBLgiASAABLgiASQACJQAAAFIlAAAAdigCAAEEgEonAgIEADsNAAEAAigAgEMEAAMoAIBEAQAAKACARQQAACgAgEYBAAEoAIBHBAABJiUAAAJ3HgIAAwAeAgAEADM4AAMABAAFJAIABQAAAJolAAACoCcCAwAFLwwAAwAEHgIAAwEKOAQDBSQCAAUAAAC8JQAAArInAgMAAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBS0MBQYtDgMGACgGAgYtDgMGACgGAgYtDgMGLQ0EBQAoBQIFLQ4FBCsCAAUAAAAAAAAAAAIAAAAAAAAAAC0IAQYnAgcEBQAQAQcBJwMGBAEAKAYCBy0MBwgtDgMIACgIAggtDgMIACgIAggtDgMIACgIAggtDgUILQ0EBQAoBQIFLQ4FBC0NBgUAKAUCBS0OBQYtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgEUABi0IAQcAAAECAS4KgEQABycCCAAGJwIJBAotCAAKLQwFCy0MBAwtDAYNLQwHDi0MCA8AEAAJACUAAALELQQAACcCCAQJLQgACS0MBQotDAQLLQwGDC0MBw0tDAEOABAACAAlAAACxC0EAAAtDQcBCygAAYBEAAgkAgAIAAACGicCCQQAPAkBCScCAQQILQgACC0MBQktDAQKLQwGCy0MBwwAEAABACUAAAPtLQQAAC0NBAEBKAABgEcABS0NBQQKOAQDAQsoAAGARAADJAIAAwAAAmslAAAFABwMAgEAMAwAAQAEJigAgAQEeAANAAAAgASAAyQAgAMAAAKfKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQV51QZevnN00jwBAQImJQAAAnctDQMGLQ0EBwsoAAeARAAIJAIACAAAAuonAgkEADwJAQkLKAAGgEMAByQCAAcAAAN5IwAAAv8tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADJCUAAAUSLgQABoADKACABAQABCUAAAUkLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA2QlAAAFsi0OCgEtDgcCLQ4FAy0OCQQjAAAD7CcCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPtLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFJC4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA+wmJQAAAncuCIBFAAUjAAAD/Q0oAAWAQwAGJAIABgAABG0jAAAEEi0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAASLIwAABPctDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUkLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABPctDAYFIwAAA/0qAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAU/IwAABUouAIADgAUjAAAFsS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWdLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVsKAGABQQAAQMAgAYAAoAGIwAABbEmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3bbuM4DIbfJde9EHUk51UGi6LtZIoAQVKk7QKLou++TjZS3IixECroYmDeFOMJf5P+LIkSnVgfi1/Lx/fn+9Xm9/Z18ePnx2K9fXp4W203w9HH593icbdar1fP9+P/Xpj9H7DuIHh9edjsj1/fHnZvix/gbDB3i+Xm1/7fDsNwkt+r9XI4Av95V9sba7O58XZkDYy1jxGO1j4mU6wTMcYYTDgaY7AwNv7rbogfbxM/UTYHoG+M392If8DCH1v8IaSUraNz0/FToHyxFJ0/j9/DreMH+zX+gxf6Di/Bc16cjbltOIupqILhXIAPxcWoacD+plTWKaA/WqdowvSNSA5dNvaj6FljAJdiCcQbOr9vgeZzrTHw10rZh3MA09fq0eXoPXrb6vLJli4/ongMJ5kWegd+HM5BFAQidBIRO6I6F6CIIjVahonuNJyeBhhIjh2O8t2z5kR2cMg1DCptLhGdzmwJGWuX8vDgRyOX5UK2FvKJrR2Niaxx8Hn8DB7Hpnt+5JRfF7+k/Dr4Ddeg/Lr4afvr4gfa/vr4afvr4mdB+XXxC8qvh58zyq+Ln1d+XfxI+fXw87p+a/LDzCKMio2Zn85fuvgFnT/38YvKr8EvFtv41XTPL2n/7eKHuv7o46f9t4sfafvr46ftr4efM9r++vhp/aWPn65/u/iBV35d/PT5eRc/q/WXPn66fuvi57T+0sdP5881FK8PhRgoOtNloOj0tYYSdE7AQNGJZg0lavZmoGhKrqEkrVMxUDQlM1A0JddQ0CuUGoqm5BoKaUpmoGiVpoLijU7zGSjaUmoo+iMDDso8s4+DHLJ1Np5DmenjhAYUbSk1lJkW/htQ5lk6mIYy02p+A4pXKDUUHWhrKDP9hnsDyjyn+dNQZlrNb0DRlFxDmWk1vwFlntX8BpR5VvOnoaCukhkompJrKDP9eUkDig60FZRgdJXMQNGWwkCZZ0pOPtvaFOTGe4Iwz/x9DUGI5QWUkMz5z8bDTF8bdEuC2os7Cc701Te3JDjPeutVBBOVtz8jVLl4pq+/uSXBeS4bb0gwaC7uJTjPZcYtCepsppNg1EzSS1BnM50Ek7bBXoI6m+kkONMXgl1FkFy5PvI1Qc3FnQRvsSkFYNk9x/rQIDjMn3LwEe0peIDEMSwbKqV0eiHrfiOZQ/D45wYfTfyDg7/Fu4D+v+Dbowa6RvDeZGPwNn1xUVujSbkPohmdmt0kyJc6lqfTiV1wh9it//bYXSyxB5yOPaHLOwglJDNtDOAxlKE3jJ7+/LcfUuKfXYApox8YpLMBLfG7JDREfI1/CKqUFCHZSkQCkUsCkbcSUeRFWLbEsqYCEfnwvB21mMoT/xWrlihIRCQQ8V9haYhIck0kCA8N26OHe1tubkhwLgIjESWByFqJCAWiCzseNkQSTxf6Uyj7vkGE8x9RYTASURCIopOIUCBKEhApCkQooYcXdnc8zWhdqPoTeYkIrxcRv6FWSxQFogvdvSHyEpEAOVmJJytB7iTInQS5v4A8lkmrQ6hEUSAKTiJCgSh6iYgEIr441BChIOcSBolIkKiJBJ7A8FPLFPN0NEVfafj8RKVQQSnWmni9hk9pDY0XaPD6Ofm+LiNSJYnqQiJsqUS+UOQLRb5I5IskvsA4kUrkC6xIFSUqa0QqL1JJesqFvcInxxjgF6Jk84qcfK0RjEvA9+JpP1EQG78IbWiCQEPXM0Av0Aj88MVcwtwOvlShswav1ljjBJrUuB5GA9e3N8u/62Jaw+9sOK1xRqC5PkdbDwKNwI9gLmAFcwEbBPcnXtkOPoejvx92q4fH9fJ1UOw/fN88va22m+Ph2z8v+ZPH3Wq9Xj3fv+y2T8tf77vl/Xr7tP9sYY5/ftqQ7mzCQ24cDgfAd2Dp0H32h8M6YlhBDF4Hz/8C",
      "brillig_names": [
        "set_minter"
      ]
    },
    {
      "name": "private_get_name",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2111772463301017956": {
            "error_kind": "string",
            "string": "Function private_get_name can only be called statically"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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IUImpBAiZEIKIUGmpV5kvrBMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyBSQQoiQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkiUggRMiGFECETUggRMiGFECETQSYJMiGFECETUggRMiGFECETUggRMiGFkCBTQgohQiakECJkQgohQiakECJkIsgkQSakECJkQgohQiakECJkQgohQiakEBJkykghRMiEFEKETEghRMiEFEKETASZJMiEFEKETEghRMiEFEKETEghRMiEFEKATLQhhRAhE1IIETIhhRAhE1IIETIRZJIgE1IIETIhhRAhE1IIETIhhRAhE1IICTIZpBAiZEIKIUImpBAiZEIKIUImgkwSZEIKIUImpBAiZEIKIUImpBAiZEIKIUEmixRChExIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTI5JBCiJAJKYQImZBCiJAJKYQImQgySZAJKYQImZBCXCSTJX8gTDWZKB8y+W3LzzIhhRAhE1IIETIhhZAgEyGFECETUggRMiGFECETUggRMhFkkiATUggRMiGFECETUggRMiGFECETUggJMnmkECJkQgohQiakECJkQgohQiaCTBJkQgohQiakECJkQgohQiakECJkQgohQaaAFEKETEghRMiEFEKETEghRMhEkEmCTEghRMiEFEKETEghRMiEFEKETEghJMgUkUKIkAkphAiZkEKIkAkphAiZCDJJkAkphAiZkEKIkAkphAiZkEKIkAkphASZElIIETIhhRAhE1IIETIhhRAhE0EmCTIhhRAhE1IIETIhhRAhE1IIETIhhZAgU0YKIUImpBAiZEIKIUImpBAiZCLIJEEmpBAiZEIKIUImpBAiZEIKIUImpBACZLr9b5BJgkxIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTIZJBCiJAJKYQImZBCiJAJKYQImQgySZAJKYQImZBCiJAJKYQImZBCiJAJKYQEmSxSCBEyIYUQIRNSCBEyIYUQIRNBJgkyIYUQIRNSCBEyIYUQIRNSCBEyIYWQIJNDCiFCJqQQImRCCiFCJqQQImQiyCRBJqQQImRCCiFCJqQQImRCCiFCJqQQEmQipBAi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/+tO1/91p+v/utP1f92Z4+/i7c/ncuaoqLdPGuUXT414czyD5R19+4r7abHttNR2Wm44zW8vnm6g44mx22m+gs/cktCDdv59d++xY799ienxJbbHl7geX0I9vsT3+JLQ40tihy8x28VXsttXcPQp735Ld/sKe/1XuOu/gq7/Cn/9V4TrvyJe/xUcfcq7H4rdviJf/hV2u/4rzMV9yu0r7PVf4a7/Crr+K/z1XxGu/4p4/Vek678iX/4VL+7ebvE47de/81+X/Be3ZLeYj5Z6SyY8nebbTgttp8W208rCbsm587SHXdf303LTaS9uZlVPM22nvdAtn/vPbzmYp9NekLxFVPtpZtueSFJqOy03neZN09zKd+vqp734w8nZPQzSP51Gbaf5ttNC22lluW+H5vM0+yjA3xrkSj2+JHf4kvIuip99ydv7erevMNd/hb3+K9ynX3E/jdpO822nhaarT2i7RIa2S2Rou0S+uF9YPc20nWbbTnNtp1Hbab7ttBfP//vjwhrj408+S62ZjdvxtE609q9f8eL2D+tXmOu/wl7/Fe76r6Drv8Jf/xXh+q+I139Fuv4rrv/rztf/defr/7rz9X/d+fq/7nz9X3e+/q87X//Xna//687X/3Xnj/+6f51mtq3tNNN2mm07zbWdRm2n+bbTQttpse201HZaW5WYtioxbVVi2qrEtFWJaasS01Ylpq1KTFuVmLYqMW1VYtuqxLZViW2rEttWJbatSmxbldi2KrFtVWLbqsS2VYlrqxLXViWurUpcW5W4tipxbVXi2qrEtVWJa6sS11Yl1FYl1FYl1FYl1FYl1FYl1FYl1FYl1FYl1FYl1FYlvq1KfFuV+LYq8W1V4tuqxLdViW+rEt9WJb6tSnxblYS2KgltVRLaqiS0VUloq5LQViWhrUpCW5WEtioJbVUS26oktlVJbKuS2FYlsa1KYluVxLYqiW1VEtuqJLZVSWqrktRWJamtSlJblaS2KkltVZLaqiS1VUlqq5LUViW5rUpyW5XktirJbVWS26okt1VJbquS3FYlua1K2rJX25a92rbs1bZlr7Yte7Vt2atty15tW/Zq27JX25a92rbs1bZlr7Yte7Vt2atty15tW/Zq27JX25a92rbs1bZlr7Yte7Vt2atty15tW/Zq27JX25a92rbs1bZlr7Yte7Vt2atty15tW/Zq27JX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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "transfer_to_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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fy1Ff4oBFAMpuigGUQymGEIxlGIiiokpJqGYlGIyiskppqCYkmIqiqkppqGYlmI6iukpZqAYRjGcYkaKmShmppildjF0eoj087T197QN8LQN9LR1edoGedoGe9qGeNqGetom8rRN7GmbxNM2qadtMk/b5J62KTxtU3rapvK0Te1pm8bTNq2nbTpP2/Sethk8bcM8bcM9bTN62mbytM3saZtlPBbDrPS1s1HMTjEHxZwUc1HMTTEPxbwU81EEFI4ipEhRpCkyFFmKHEVEkaeYn2IBigUpFqJYmGIRikUpFqNYnGIJiiVrF8OsHiKzedpm97TN4Wmb09M2l6dtbk/bPJ62eT1t83naAk+b87SFnraUpy3tact42rKetpynLfK05T1t83vaFvC0LehpW8jTtrCnbRFP26KetsU8bYt72pbwtC05HothKfrapSmWoViWYjmK5SlWoFiRYiWKlSlWoViVYjWK1SnWoFiTYi2KtSnWoViXYj2K9Sk2oNiQYiOKjSk2odiUokBRpCjVLoalPESW9rQt42lb1tO2nKdteU/bCp62FT1tK3naVva0reJpW9XTtpqnbXVP2xqetjU9bWt52tb2tK3jaVvX07aep219T9sGnrYNPW0bedo29rRt4mnb1NNW8LQVPW2l8VgMMX1tmaJCsRnF5hRbUGxJsRXF1hTbUGxLsR3F9hQ7UOxIsRPFzhS7UOxKsRvF7hR7UOxJsRfF3hT7UOxLsR/FCIr9KQ6oXQyxh0jZ01bxtG3madvc07aFp21LT9tWnratPW3beNq29bRt52nb3tO2g6dtR0/bTp62nT1tu3jadvW07eZp293TtoenbU9P216etr09bft42vb1tO3naRvhadvf03bAeCyGA+lrD6I4mOIQikMpDqM4nOIIiiMpjqI4muIYimMpjqM4nuIEihMpTqI4meIUilMpTqM4neIMijMpzqI4m+IcinMpzqM4v3YxHOghcpCn7WBP2yGetkM9bYd52g73tB3haTvS03aUp+1oT9sxnrZjPW3HedqO97Sd4Gk70dN2kqftZE/bKZ62Uz1tp3naTve0neFpO9PTdpan7WxP2zmetnM9bed52s4fj8VwAX3thRQXUVxMcQnFpRSXUVxOcQXFlRRXUVxNcQ3FtRTXUVxPcQPFjRQ3UdxMcQvFrRS3UdxOcQfFnRR3UdxNcQ/F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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "_finish_transfer_to_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHxgABAADgEguCIBIAAEuCIBJAAIlAAAASyUAAABvKAIAAQSASicCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAmUeAgADAB4CAAQAMzgAAwAEAAUkAgAFAAAAkyUAAAKOHgIAAwEeAgAEAAo4AwQFJAIABQAAAK8lAAACoCcCAwAALQgBBCcCBQQEABABBQEnAwQEAQAoBAIFLQwFBi0OAwYAKAYCBi0OAwYAKAYCBi0OAwYtDQQFACgFAgUtDgUEKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFABABBwEnAwYEAQAoBgIHLQwHCC0OAwgAKAgCCC0OAwgAKAgCCC0OAwgAKAgCCC0OBQgtDQQFACgFAgUtDgUELQ0GBQAoBQIFLQ4FBi0IAQUAAAECAS0OBAUtCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARQAGLQgBBwAAAQIBLgqARAAHJwIIAAknAgkECi0IAAotDAULLQwEDC0MBg0tDAcOLQwIDwAQAAkAJQAAArItBAAAJwIIBAktCAAJLQwFCi0MBAstDAYMLQwHDS0MAg4AEAAIACUAAAKyLQQAAC0NBwILKAACgEQACCQCAAgAAAINJwIJBAA8CQEJJwICBAgtCAAILQwFCS0MBAotDAYLLQwHDAAQAAIAJQAAA9stBAAALQ0EAgEoAAKARwAFLQ0FBAo4BAMCCygAAoBEAAMkAgADAAACXiUAAATuMAwAAQAEJigAgAQEeAANAAAAgASAAyQAgAMAAAKNKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQVjmNPyHedZZDwBAQImJQAAAmUtDQMGLQ0EBwsoAAeARAAIJAIACAAAAtgnAgkEADwJAQkLKAAGgEMAByQCAAcAAANnIwAAAu0tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADEiUAAAUALgQABoADKACABAQABCUAAAUSLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA1IlAAAFoC0OCgEtDgcCLQ4FAy0OCQQjAAAD2icCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPbLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFEi4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA9omJQAAAmUuCIBFAAUjAAAD6w0oAAWAQwAGJAIABgAABFsjAAAEAC0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAAR5IwAABOUtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUSLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABOUtDAYFIwAAA+sqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUtIwAABTguAIADgAUjAAAFny4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWLLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVaKAGABQQAAQMAgAYAAoAGIwAABZ8mKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3dbts6DMffJde9ECVKlPYqw0HRj6wIECRFmh7goOi7H6eLHCemrZjKNgzmTTHP/IfyL5Qo0bH8sXhePr6/3K82P7Zvi2/fPxbr7dPDfrXdNEcfn3eLx91qvV693Hf/e2EOfwDCl+Dt9WFzOH7bP+z2i2/grDd3i+Xm+fBvF33zIT9W62VzBPh517c31mZzg7ZjDYw1hgBHawxkWmtKjHH0xh+No7fQNf7nbgEWbtP+lLI5QPqd7b8Rfx9b/rHEHzxRtg7Ojbc/+ZQvNgWHl+13eOv2gz1v/8EL2t/ihVgvkFIrswZCwQtGhzk6YqcvDEQH2TY6Il3S9fx12053s+f9DX9xvPprGCGeteigC1amIyPUeZ4cupMOw4mcN2zABHcaFk4dBcix3SocjZvvp7V1zjO2lDBTppROn2xTZKwd5TDHTg+0XJOthfzB1nb6NmvsMY8DHmPX9EAwGiVYSRCVYCXBpATrCCaNwVqCGoN1BJv8rAQrCUYlWEcQrBKsJEhKsI7gQK1CCV5PMCjBOoJOV3VXEIy5XuI7xbRMEJVgJUGdUVcSRKcEiwRDaxvOTQ8Eg/biWoK6JqkkSNqLawlqDFYSjBqDtQQ1BisJJq3N1BLUdXEdQWe0NlNLUO+4VxIErc3UEkQlWElQazOVBK3OqC8JfmHR20ccFqdzXxaLTmg5LKgzBBaLTj1ZLJrLOSxeEzSLRetYHJagCZrFogmaw0JaRmKxaIJmsWiC5rDocxMslqSTfxaLRguLRccWBgvO9i6Fg9xk62y4xDLbWw8FLBotLJa5ji3jWGZb+S9gmWvlfxyLm+tSsYBFh1wWiw65HBZExcJh0WjhsMy28l/AMtfK/ziW2Vb+C1jmWvkfx0K6gmaxaIJmseiQy2GJOuSyWHQFzWGZ7XMjBSxzTdCE2daSlxs3DL2ZazafwhBCzDtdAhnbYzjXHHdDhqB9uZrhbLfduSXDuVZlJzGk1O6rHOEyL/vZbr1zS4aoDKsZal6uZohzXXrckqHObaoZes0p9Qx1blPNMGgc1jNEZVjNUOc2VzBMrr2+hD2GpHm5muFtXp4BsWPtCwy9T7n5IdruG1GIo9i+EobotEksRPuz+f6vbn5yf3Pzw232Ivpzzb9m/Ojo+OajyT4ALZ056VtH4/IAEo0/fTT7hiOKLr/si2Iy48YAGH07kPnO3ZafL0QKie8qph1LwMR0MTyEgYczRkVk+KgG3xbugC4LdwQgESWByKJExOdriKENFdMDMfDrNrSdiOl5GvjtV0FEAlEAicgLRCS5pihpXuT7tMf2y/UEl6KB+7MFUZouigYFooFnXgoiLxBZiaeB/tQktywKcPl4UxzYTqYgIoFoYM+NcdFAuaIgkoAY+E3juChI6A088u1O80PnbU8UBKKBSWVBhBJRFIgGuntBJACRDEhEEk9gJCKUiATIkx1AHtqZlovQE0WBaOCxjHHRwHZFBVEQiDxIREkgCoKcm4JgHpEIJCKBJzD81JJCno5SwJ6Gz0+pXfYnCn1NnK7hU1pBE6ZrBoJ1dE7enPUiVZKoBhJhSSXyFUS+gsgXiXyRyFcUfV9R5CuJritFgarpWiJVkKjAiFR+8hgD/EI02bwiT9jXCMYl4HvxuB8UtI1fhBY0NF3DL0HHGYTpYyaQwA+/F1CKOQ7OarpHDT/zLWgkflLhehhNmh5vlv95aUFD0zVgBZrpOdryT74XNAI/grmAFcwFLAq+H5wYB5/N0b8Pu9XD43r51igOJ983T/vVdnM83P/3ms887lbr9erl/nW3fVo+v++W9+vt0+Hcwhz/fLdNoa25b/GVQ5rD5ou8Axu+QvRwlkJzNjZeG8//Aw==",
      "brillig_names": [
        "_finish_transfer_to_public"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "8359297168692325491": {
            "error_kind": "string",
            "string": "Function is_minter can only be called statically"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          },
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "11988194033336150524": {
            "error_kind": "string",
            "string": "Function _store_nft_set_partial_note can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14466155340988305413": {
            "error_kind": "string",
            "string": "caller is not a minter"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17922298012674089187": {
            "error_kind": "string",
            "string": "Cannot complete a PartialNFTNote with a value of 0"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBqJwAABAMnAgIEAScCAwQAHxgAAwACgGkuCIBpAAElAAAARSUAAAGcKAIAAQSAaicCAgQAOw0AAQACKQCAQwA7msoAKACARAAAASkAgEUAR9rNcygAgEYEAAEsAIBHADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAKACASAQAAygAgEkBAAAoAIBKBAAAKACASwAAACgAgEwBAAEoAIBNBAACKACATgQABCgAgE8AAAQoAIBQAAAUKACAUQQAHygAgFIAACMoAIBTAAAzKACAVAQAPygAgFUAAE0oAIBWAABPKACAVwAAUSgAgFgAAFMoAIBZAABmKACAWgAAdSgAgFsAAIgoAIBcAACKKACAXQAAjSgAgF4AAKgoAIBfAACrKACAYAAArigAgGEAALQoAIBiAAC1KACAYwAAtygAgGQAALgoAIBlAAC5KwCAZgAAAAAAAAAAAgAAAAAAAAAAKwCAZwAAAAAAAAAAAwAAAAAAAAAAKwCAaAAAAAAAAAAABAAAAAAAAAAAJiUAACcmKQIAAgDcd+0TCjgBAgMnAgQEACcCBgQDADgEBgUtCAECABABBQEnAwIEAQAoAgIFLQ4EBQAoBQIFLQ4EBScCBQQDADgCBQQnAgQABicCBQAFJwIGAAMkAgADAAACBCMAAAZqLQgBBycCCARAABABCAEnAwcEAQAoBwIIHySARoBUAAgtDQcIACgIAggtDggHLQgBCAAAAQIBLQgBCQAAAQIBASgAB4BGAAstDQsKLQ4HCC4KgEYACScCCwQMLQgADC0MCA0tDAkOLQwEDwAQAAsAJQAAJ08tBAAALQwNBy0NBwsAKAsCCy0OCwcnAgwEDS0IAA0tDAgOLQwJDy0MBBAAEAAMACUAACdPLQQAAC0MDgstDQsIACgIAggtDggLLQgBCAAAAQIBLgqASQAILQgBCQAAAQIBLgqASwAJLQgBDAAAAQIBLgqAZQAMHgIADQA2OAANAA4ADwAcDA8QAAQ4EA4RJAIADwAAAxcnAg4EADwJAQ42OAANAA4ADwIcDA8NAAQ4DQ4QJAIADwAAAzsnAg0EADwJAQ0tCAENJwIOBAIAEAEOAScDDQQBACgNAg4fJIBKgEYADi0NDQ4AKA4CDi0ODg0BKAANgEYADy0NDw4cDA4PBBwMDw0AJwIPBBItCAASLgiASQATLgiASwAULgiAZQAVABAADwAlAAApXC0EAAAtDBMOJwIPAA0tCAESJwITBAQAEAETAScDEgQBACgSAhMtDBMULQ4PFAAoFAIULQ4NFAAoFAIULQ4OFC0NEg0AKA0CDS0ODRInAhQEFS0IABUuCIBnABYAEAAUACUAADzOLQQAAC0MFg0tDBcOLQwYDy0MGRMtDQ0UACgUAhQtDhQNLQ0OFAAoFAIULQ4UDi0IARQAAAECAS0ODRQtCAENAAABAgEtDg4NLQgBDgAAAQIBLQ4PDi0IAQ8AAAECAS0OEw8uCIBKAAMjAAAEdQ0oAAOASAATJAIAEwAAJtwjAAAEiicCEgQVLQgAFS0MFBYtDA0XLQwOGC0MDxkAEAASACUAAD1uLQQAAC0MFgMKOBADDSQCAA0AAATHJQAAPeILKAARgEsAAx4CAA0BCjgRDQ4SOAMODSQCAA0AAATrJQAAPfQLKAAKgEsAAwsoAAOASQANJAIADQAABQglAAA+BicCAwQNLQgADS0MCA4tDAkPLQwMEC0MBREtDAoSABAAAwAlAAA+GC0EAAAnAhAEES0IABEtDAgSLQwJEy0MDBQtDAQVLgiAVQAWLQwKFwAQABAAJQAAPiQtBAAALQwSAy0MEw0tDBQOLQwVDycCCgQQLQgAEC0MAxEtDA0SLQwOEy0MDxQuCIBMABUAEAAKACUAAECNLQQAACcCCgQNLQgADS0MBw4uCIBMAA8AEAAKACUAAECeLQQAAC0MDgMnAgcEDS0IAA0tDAgOLQwJDy0MDBAtDAYRLQwDEgAQAAcAJQAAQZEtBAAAJwIHBA0tCAANLQwLDi4IgEwADwAQAAcAJQAAQJ4tBAAALQwOAycCBwQNLQgADS0MCA4tDAkPLQwMEC4IgEQAES0MAxIAEAAHACUAAEGRLQQAAB4CAAMANAIAAwAoAgIILQ0IBycCCQQCADgICQM7DQADAAcjAAAGaikCAAMAli3rAgo4AQMHLQ0CAwAoAwIDLQ4DAiQCAAcAAAaSIwAAB+wtCAEDJwIHBAIAEAEHAScDAwQBACgDAgcfJIBGgEYABy0NAwcAKAcCBy0OBwMtCAEHAAABAgEtDgMHLQgBAwAAAQIBLgqASgADJwIJBAotCAAKLQwHCy0MAwwuCIBPAA0AEAAJACUAAEK/LQQAAC0MCwgtCAEDAAABAgEuCoBJAAMtCAEHAAABAgEuCoBLAActCAEJAAABAgEuCoBkAAknAgoECy0IAAstDAMMLQwHDS0MCQ4AEAAKACUAAENWLQQAACcCCwQMLQgADC0MAw0tDAcOLQwJDy0MBRAAEAALACUAAEN7LQQAAC0MDQoeAgALAQo4CgsMJAIADAAAB5YlAABDiycCCgQLLQgACy0MAwwtDAcNLQwJDi0MBQ8tDAgQABAACgAlAAA+GC0EAAAtDQIDACgDAgMtDgMCACgCAggtDQgHJwIJBAIAOAgJAzsNAAMAByMAAAfsKQIAAwB0rCkNCjgBAwckAgAHAAAIByMAAAnTLQgBAycCBwQDABABBwEnAwMEAQAoAwIHHySARoBNAActDQMHACgHAgctDgcDLQgBBwAAAQIBLQ4DBy0IAQMAAAECAS4KgEoAAycCCQQKLQgACi0MBwstDAMMLgiATwANABAACQAlAABDnS0EAAAtDAsIJwIKBAstCAALLQwHDC0MAw0AEAAKACUAAEQ0LQQAAC0MDAkBKAAJgEYABy0NBwMcDAMJARwMCQcAHAwHAwEtCAEHAAABAgEuCoBJAActCAEJAAABAgEuCoBLAAktCAEKAAABAgEuCoBjAAonAgsEDC0IAAwtDAcNLQwJDi0MCg8AEAALACUAAENWLQQAACcCDAQNLQgADS0MBw4tDAkPLQwKEC0MBREAEAAMACUAAEN7LQQAAC0MDgseAgAMAQo4CwwNJAIADQAACUklAABDiycCDwQQLQgAEC0MBxEtDAkSLQwKEy0MBBQuCIBVABUtDAgWABAADwAlAAA+JC0EAAAtDBELLQwSDC0MEw0tDBQOJwIHBA8tCAAPLQwLEC0MDBEtDA0SLQwOEy0MAxQAEAAHACUAAECNLQQAAAAoAgIILQ0IBycCCQQCADgICQM7DQADAAcjAAAJ0ykCAAMA6v/ysQo4AQMHJwIDAAgnAggACSQCAAcAAAn4IwAADPctCAEHJwIJBAMAEAEJAScDBwQBACgHAgkfJIBGgE0ACS0NBwkAKAkCCS0OCQctCAEJAAABAgEtDgcJLQgBBwAAAQIBLgqASgAHJwILBAwtCAAMLQwJDS0MBw4uCIBPAA8AEAALACUAAEOdLQQAAC0MDQonAgwEDS0IAA0tDAkOLQwHDy4IgFAAEAAQAAwAJQAARKstBAAALQwOCy0IAQcAAAECAS4KgEkABy0IAQkAAAECAS4KgEsACS0IAQwAAAECAS4KgGIADCcCDQQOLQgADi0MBw8tDAkQLQwMEQAQAA0AJQAAQ1YtBAAACygAC4BLAA0LKAANgEkADiQCAA4AAAsAJQAARUIeAgANAScCEgQTLQgAEy0MBxQtDAkVLQwMFi0MBBcuCIBVABgtDA0ZABAAEgAlAAA+JC0EAAAtDBQOLQwVDy0MFhAtDBcRJwISBBMtCAATLQwOFC0MDxUtDBAWLQwRFwAQABIAJQAARVQtBAAALQwUDSQCAA0AAAt+JQAARXMnAhEEEi0IABItDAcTLQwJFC0MDBUtDAMWLgiAVwAXLQwLGAAQABEAJQAARYUtBAAALQwTDS0MFA4tDBUPLQwWECcCEgQTLQgAEy0MDRQtDA4VLQwPFi0MEBcAEAASACUAAEVULQQAAC0MFBELKAARgEkADSQCAA0AAAv/JQAAR+4nAhEEEi0IABItDAcTLQwJFC0MDBUtDAMWLgiAVwAXLQwLGAAQABEAJQAARYUtBAAALQwTDS0MFA4tDBUPLQwWECcCEQQSLQgAEi0MDRMtDA4ULQwPFS0MEBYuCIBMABcAEAARACUAAECNLQQAACcCEQQSLQgAEi0MBxMtDAkULQwMFS0MCBYuCIBYABctDAsYABAAEQAlAABIAC0EAAAtDBMNLQwUDi0MFQ8tDBYQJwIHBBEtCAARLQwNEi0MDhMtDA8ULQwQFS0MChYAEAAHACUAAD4YLQQAAAAoAgIKLQ0KCScCCwQCADgKCwc7DQAHAAkjAAAM9ykCAAcAyLvXtAo4AQcJJAIACQAADRIjAAAN4S0IAQcAAAECAS4KgEkABy0IAQkAAAECAS4KgEsACS0IAQoAAAECAS4KgGEACicCCwQMLQgADC0MBw0tDAkOLQwKDwAQAAsAJQAAQ1YtBAAAHgIABwkLKAAHgEQACSQCAAkAAA18JQAASmkvDAAGAAcnAgkEAScCCwQDADgJCwotCAEGABABCgEnAwYEAQAoBgIKLQ4JCgAoCgIKLQ4JCicCCgQDADgGCgktDAkKLQ4HCgAoBgIKLQ0KCScCCwQCADgKCwc7DQAHAAkjAAAN4SkCAAYAzeXfSQo4AQYHJAIABwAADfwjAAAOyy0IAQYAAAECAS4KgEkABi0IAQcAAAECAS4KgEsABy0IAQkAAAECAS4KgGAACScCCgQLLQgACy0MBgwtDAcNLQwJDgAQAAoAJQAAQ1YtBAAAHgIABgkLKAAGgEQAByQCAAcAAA5mJQAASnsvCIBEAAYnAgkEAScCCwQDADgJCwotCAEHABABCgEnAwcEAQAoBwIKLQ4JCgAoCgIKLQ4JCicCCgQDADgHCgktDAkKLQ4GCgAoBwIKLQ0KCScCCwQCADgKCwY7DQAGAAkjAAAOyykCAAYAKxGxmgo4AQYHJAIABwAADuYjAAAP2i0IAQYAAAECAS4KgEkABi0IAQcAAAECAS4KgEsABy0IAQkAAAECAS4KgF8ACScCCgQLLQgACy0MBgwtDAcNLQwJDgAQAAoAJQAAQ1YtBAAAHgIACgkLKAAKgEQACyQCAAsAAA9QJQAASo0nAgsEDC0IAAwtDAYNLQwHDi0MCQ8tDAUQABAACwAlAABDey0EAAAtDA0KJwIGBAEnAgkEAwA4BgkHLQgBBQAQAQcBJwMFBAEAKAUCBy0OBgcAKAcCBy0OBgcnAgcEAwA4BQcGLQwGBy0OCgcAKAUCCS0NCQcnAgoEAgA4CQoGOw0ABgAHIwAAD9opAgAFAMWaghYKOAEFBiQCAAYAAA/1IwAAEaEtCAEFJwIGBAIAEAEGAScDBQQBACgFAgYfJIBGgEYABi0NBQYAKAYCBi0OBgUtCAEGAAABAgEtDgUGLQgBBQAAAQIBLgqASgAFJwIJBAotCAAKLQwGCy0MBQwuCIBPAA0AEAAJACUAAEK/LQQAAC0MCwctCAEFAAABAgEuCoBJAAUtCAEGAAABAgEuCoBLAAYtCAEJAAABAgEuCoBeAAknAgoECy0IAAstDAUMLQwGDS0MCQ4AEAAKACUAAENWLQQAAB4CAAoJCygACoBEAAskAgALAAAQ0SUAAEqfJwIOBA8tCAAPLQwFEC0MBhEtDAkSLQwEEy4IgFUAFC0MBxUAEAAOACUAAD4kLQQAAC0MEAotDBELLQwSDC0MEw0nAgUEDi0IAA4tDAoPLQwLEC0MDBEtDA0SABAABQAlAABFVC0EAAAtDA8EHAwEBQAnAgYEAScCCQQDADgGCQctCAEEABABBwEnAwQEAQAoBAIHLQ4GBwAoBwIHLQ4GBycCBwQDADgEBwYtDAYHLQ4FBwAoBAIHLQ0HBicCCQQCADgHCQU7DQAFAAYjAAARoSkCAAQAhTJ28Qo4AQQFJAIABQAAEbwjAAAYES0IAQQnAgUEBQAQAQUBJwMEBAEAKAQCBR8kgEaATgAFLQ0EBQAoBQIFLQ4FBC0IAQUAAAECAS0OBAUtCAEEAAABAgEuCoBKAAQnAgcECS0IAAktDAUKLQwECy4IgE8ADAAQAAcAJQAASrEtBAAALQwKBicCCQQKLQgACi0MBQstDAQMLgiATwANABAACQAlAABKsS0EAAAtDAsHJwIKBAstCAALLQwFDC0MBA0uCIBQAA4AEAAKACUAAEtILQQAAC0MDAknAgsEDC0IAAwtDAUNLQwEDi4IgFAADwAQAAsAJQAAS0gtBAAALQwNCi0IAQQAAAECAS4KgEkABC0IAQUAAAECAS4KgEsABS0IAQsAAAECAS4KgF0ACycCDAQNLQgADS0MBA4tDAUPLQwLEAAQAAwAJQAAQ1YtBAAAHgIADAEKOAYMDSQCAA0AABcwIwAAExAtDQQMLQ0FDS0NCw4eAgAPAS0IARAnAhEEAgAQAREBJwMQBAEAKBACER8kgEqARgARLQ0QEQAoEQIRLQ4REAEoABCARgASLQ0SERwMERIEHAwSEAAnAhIEEy0IABMtDAwULQwNFS0MDhYAEAASACUAAClcLQQAAC0MFBEtCAEMJwINBAQAEAENAScDDAQBACgMAg0tDA0OLQ4PDgAoDgIOLQ4QDgAoDgIOLQ4RDicCDQAtLQgBDicCDwQFABABDwEnAw4EAQAoDgIPLQwPEC0ODRAAKBACEC0ODRAAKBACEC0ODRAAKBACEC0ODRAtCAENAAABAgEtDg4NLgiASgAKIwAAFBUNKAAKgEgADiQCAA4AABbOIwAAFCotDQ0MLQ0MDQAoDQINLQ4NDCcCEQQSLQgAEi4IgGgAEwAQABEAJQAAPM4tBAAALQwTDS0MFA4tDBUPLQwWEC0NDREAKBECES0OEQ0tDQ4RACgRAhEtDhEOLQgBEQAAAQIBLQ4NES0IAQ0AAAECAS0ODg0tCAEOAAABAgEtDg8OLQgBDwAAAQIBLQ4QDy4IgEoACiMAABTBDSgACoBOABAkAgAQAAAWhCMAABTWJwIMBBItCAASLQwREy0MDRQtDA4VLQwPFgAQAAwAJQAAPW4tBAAALQwTCikCAAwAJxaxZicCDgQDJwIQBAMAOA4QDy0IAQ0AEAEPAScDDQQBACgNAg8tDg4PACgPAg8tDg4PJwIPBAMAOA0PDi0MDg8tDgwPACgPAg8tDgYPACgPAg8tDgoPLQ0NCgAoCgIKLQ4KDS0IAQonAgwEAwAQAQwBJwMKBAEAKAoCDC0MDA4uCoBHAA4AKA4CDi4KgEcADgAoCgIMACgNAhAtDRAPJwIRBAIAOBARDjnVAAyARAAOAA8gAgAKIQIADC0IAQ4AKA4CES0NERAnAhIEAgA4ERIPIjSASgAMAA8tDAwQJwISBAMAOBASEQAQAREBJwMOBAEAKA4CEi0OEBIAKBICEi0OEBItDBANBigNAg0tDQ4MACgMAgwtDgwOJAIACgAAFkkjAAAWLQAoDgIPLQ0PDCcCEAQCADgPEAo8DQoMIwAAFkkLKAANgEYACiQCAAoAABZeJQAAS98BKAAOgEgADC0NDAoLKAAKgEUADCQCAAwAABZ/JQAAS/EjAAAXSgAoDAISADgSChMtDRMQJwISBBMtCAATLQwRFC0MDRUtDA4WLQwPFy0MEBgAEAASACUAAEwDLQQAAAEoAAqARgAQLQwQCiMAABTBLQ0NDgEoAAqARgAPACgMAhEAOBEKEi0NEhANKAAPgE4AESQCABEAABb9JQAATSwuBAAOgAMoAIAEBAAFJQAATT4uCIAFABEAKBECEgA4Eg8TLQ4QEy0OEQ0tDA8KIwAAFBULKAAKgEsADCQCAAwAABdFJQAATcwjAAAXSicCDwQQLQgAEC0MBBEtDAUSLQwLEy0MCBQuCIBYABUtDAkWABAADwAlAABIAC0EAAAtDBEKLQwSDC0MEw0tDBQOJwIFBA8tCAAPLQwKEC0MDBEtDA0SLQwOEwAQAAUAJQAAQ3stBAAALQwQBAo4BAYFJAIABQAAF8glAABN3icCBAQPLQgADy0MChAtDAwRLQwNEi0MDhMtDAcUABAABAAlAAA+GC0EAAAAKAICBi0NBgUnAgcEAgA4BgcEOw0ABAAFIwAAGBEpAgAEADebihQKOAEEBSQCAAUAABgsIwAAGTQtCAEEJwIFBAIAEAEFAScDBAQBACgEAgUfJIBGgEYABS0NBAUAKAUCBS0OBQQtCAEFAAABAgEtDgQFLQgBBAAAAQIBLgqASgAEJwIHBAktCAAJLQwFCi0MBAsAEAAHACUAAE3wLQQAAC0MCgYBKAAGgEYABS0NBQQtCAEFAAABAgEuCoBJAAUtCAEGAAABAgEuCoBLAAYtCAEHAAABAgEuCoBcAAcnAgkECi0IAAotDAULLQwGDC0MBw0AEAAJACUAAENWLQQAAB4CAAUBHgIABgAKOAUGByQCAAcAABkQJQAATk0wCIBEAAQAKAICBi0NBgUnAgcEAgA4BgcEOw0ABAAFIwAAGTQpAgAEAMALw9oKOAEEBSQCAAUAABlPIwAAHLstCAEFJwIGBAMAEAEGAScDBQQBACgFAgYfJIBGgE0ABi0NBQYAKAYCBi0OBgUtCAEGAAABAgEtDgUGLQgBBQAAAQIBLgqASgAFJwIJBAotCAAKLQwGCy0MBQwuCIBQAA0AEAAJACUAAESrLQQAAC0MCwcnAgoECy0IAAstDAYMLQwFDQAQAAoAJQAARDQtBAAALQwMCQEoAAmARgAGLQ0GBS0IAQYAAAECAS4KgEkABi0IAQkAAAECAS4KgEsACS0IAQoAAAECAS4KgFsACicCCwQMLQgADC0MBg0tDAkOLQwKDwAQAAsAJQAAQ1YtBAAAHgIACwEnAhAEES0IABEtDAYSLQwJEy0MChQtDAgVLgiAWAAWLQwHFwAQABAAJQAASAAtBAAALQwSDC0MEw0tDBQOLQwVDycCCQQQLQgAEC0MDBEtDA0SLQwOEy0MDxQAEAAJACUAAEN7LQQAAC0MEQYKOAYLCSQCAAkAABrDJQAATl8nAgYEEC0IABAtDAwRLQwNEi0MDhMtDA8ULgiASwAVABAABgAlAAA+GC0EAAAvDAAFAAYcDAYKARwMCgkAHAwJBgEkAgAGAAAbEiUAAE5xCygAB4BLAAYLKAAGgEkACSQCAAkAABsvJQAAToMnAgkEAicCCwQDADgJCwotCAEGABABCgEnAwYEAQAoBgIKLQ4JCgAoCgIKLQ4JCicCCgQDADgGCgktDAkKLQ4FCgAoCgIKLQ4HCgAoBgILLQ0LCicCDAQCADgLDAk3DQAJAAotCAEGJwIJBAQAEAEJAScDBgQBACgGAgktDAkKLgqARAAKACgKAgotDgUKACgKAgotDgcKLQ0GBQAoBQIFLQ4FBicCCwQMLQgADC4IgGcADQAQAAsAJQAAPM4tBAAALQwNBS0MDgctDA8JLQwQCi0NBQsAKAsCCy0OCwUtDQcLACgLAgstDgsHLQgBCwAAAQIBLQ4FCy0IAQUAAAECAS0OBwUtCAEHAAABAgEtDgkHLQgBCQAAAQIBLQ4KCS4IgEoABCMAABxZDSgABIBIAAokAgAKAAAmkiMAABxuJwIGBAwtCAAMLQwLDS0MBQ4tDAcPLQwJEAAQAAYAJQAAPW4tBAAALQwNBDICAAQAKAICBi0NBgUnAgcEAgA4BgcEOw0ABAAFIwAAHLspAgAEAEVlizEKOAEEBSQCAAUAABzWIwAAII4tCAEFJwIGBAQAEAEGAScDBQQBACgFAgYfJIBGgEgABi0NBQYAKAYCBi0OBgUtCAEGAAABAgEtDgUGLQgBBQAAAQIBLgqASgAFJwIJBAotCAAKLQwGCy0MBQwAEAAJACUAAE6VLQQAAC0MCwcBKAAHgEYACi0NCgknAgoECy0IAAstDAYMLQwFDQAQAAoAJQAATpUtBAAALQwMBwEoAAeARgALLQ0LCicCCwQMLQgADC0MBg0tDAUOABAACwAlAABOlS0EAAAtDA0HASgAB4BGAAYtDQYFLQgBBgAAAQIBLgqASQAGLQgBBwAAAQIBLgqASwAHLQgBCwAAAQIBLgqAWgALJwIMBA0tCAANLQwGDi0MBw8tDAsQABAADAAlAABDVi0EAAAeAgAMAR4CAA0ACjgMDQ4kAgAOAAAeGCUAAE8MJwIQBBEtCAARLQwGEi0MBxMtDAsULQwIFS4IgFgAFi0MChcAEAAQACUAAEgALQQAAC0MEgwtDBMNLQwUDi0MFQ8nAgcEEC0IABAtDAwRLQwNEi0MDhMtDA8UABAABwAlAABDey0EAAAtDBEGCjgGCQckAgAHAAAeliUAAE5fJwIGBBAtCAAQLQwMES0MDRItDA4TLQwPFC4IgEsAFQAQAAYAJQAAPhgtBAAALwwABQAGHAwGCQEcDAkHABwMBwYBJAIABgAAHuUlAABOcQsoAAqASwAGCygABoBJAAckAgAHAAAfAiUAAE6DJwIHBAInAgsEAwA4BwsJLQgBBgAQAQkBJwMGBAEAKAYCCS0OBwkAKAkCCS0OBwknAgkEAwA4BgkHLQwHCS0OBQkAKAkCCS0OCgkAKAYCCy0NCwknAgwEAgA4CwwHNw0ABwAJLQgBBicCBwQEABABBwEnAwYEAQAoBgIHLQwHCS4KgEQACQAoCQIJLQ4FCQAoCQIJLQ4KCS0NBgUAKAUCBS0OBQYnAgsEDC0IAAwuCIBnAA0AEAALACUAADzOLQQAAC0MDQUtDA4HLQwPCS0MEAotDQULACgLAgstDgsFLQ0HCwAoCwILLQ4LBy0IAQsAAAECAS0OBQstCAEFAAABAgEtDgcFLQgBBwAAAQIBLQ4JBy0IAQkAAAECAS0OCgkuCIBKAAQjAAAgLA0oAASASAAKJAIACgAAJkgjAAAgQScCBgQMLQgADC0MCw0tDAUOLQwHDy0MCRAAEAAGACUAAD1uLQQAAC0MDQQyAgAEACgCAgYtDQYFJwIHBAIAOAYHBDsNAAQABSMAACCOKQIABAAleEkUCjgBBAUkAgAFAAAgqSMAACI6LQgBBCcCBQQDABABBQEnAwQEAQAoBAIFHySARoBNAAUtDQQFACgFAgUtDgUELQgBBQAAAQIBLQ4EBS0IAQQAAAECAS4KgEoABCcCBwQJLQgACS0MBQotDAQLLgiATwAMABAABwAlAABDnS0EAAAtDAoGJwIJBAotCAAKLQwFCy0MBAwuCIBQAA0AEAAJACUAAESrLQQAAC0MCwctCAEEAAABAgEuCoBJAAQtCAEFAAABAgEuCoBLAAUtCAEJAAABAgEuCoBZAAknAgoECy0IAAstDAQMLQwFDS0MCQ4AEAAKACUAAENWLQQAAB4CAAoBHgIACwAKOAoLDCQCAAwAACGwJQAATx4nAg4EDy0IAA8tDAQQLQwFES0MCRItDAgTLgiAWAAULQwHFQAQAA4AJQAASAAtBAAALQwQCi0MEQstDBIMLQwTDScCBAQOLQgADi0MCg8tDAsQLQwMES0MDRItDAYTABAABAAlAAA+GC0EAAAAKAICBi0NBgUnAgcEAgA4BgcEOw0ABAAFIwAAIjopAgACAPhBCA0KOAECBCQCAAQAACJVIwAAJHstCAECJwIEBAIAEAEEAScDAgQBACgCAgQfJIBGgEYABC0NAgQAKAQCBC0OBAItCAEEAAABAgEtDgIELQgBAgAAAQIBLgqASgACJwIGBAktCAAJLQwECi0MAgsAEAAGACUAAE3wLQQAAC0MCgUBKAAFgEYABC0NBAItCAEEAAABAgEuCoBJAAQtCAEFAAABAgEuCoBLAAUtCAEGAAABAgEuCoBTAAYnAgcECS0IAAktDAQKLQwFCy0MBgwAEAAHACUAAENWLQQAAB4CAAcJCygAB4BEAAkkAgAJAAAjNyUAAE8wJwIMBA0tCAANLQwEDi0MBQ8tDAYQLQwDES4IgFcAEi0MAhMAEAAMACUAAEWFLQQAAC0MDgctDA8JLQwQCi0MEQsnAgwEDS0IAA0tDAcOLQwJDy0MChAtDAsRABAADAAlAABFVC0EAAAtDA4DJAIAAwAAI7AlAABPQicCCwQMLQgADC0MBA0tDAUOLQwGDy0MCBAuCIBYABEtDAISABAACwAlAABIAC0EAAAtDA0DLQwOBy0MDwktDBAKJwIEBAstCAALLQwDDC0MBw0tDAkOLQwKDwAQAAQAJQAAQ3stBAAALQwMAicCBAQBJwIGBAMAOAQGBS0IAQMAEAEFAScDAwQBACgDAgUtDgQFACgFAgUtDgQFJwIFBAMAOAMFBC0MBAUtDgIFACgDAgUtDQUEJwIGBAIAOAUGAjsNAAIABCMAACR7JwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAQAREBJwMQBAEAKBACES0MERItDgISACgSAhItDgMSACgSAhItDgQSACgSAhItDgMSACgSAhItDgUSACgSAhItDgYSACgSAhItDgMSACgSAhItDgcSACgSAhItDggSACgSAhItDgkSACgSAhItDgoSACgSAhItDgkSACgSAhItDgsSACgSAhItDgwSACgSAhItDgUSACgSAhItDg0SACgSAhItDgcSACgSAhItDg4SACgSAhItDggSACgSAhItDgkSACgSAhItDgoSACgSAhItDgkSACgSAhItDgsSACgSAhItDgwSACgSAhItDgUSACgSAhItDg0SACgSAhItDg8SCyCASYBMAAIkAgACAAAmRycCAwQeLQgBBCcCBQQeABABBQEtDAQFKgMABQUnRkiy9UEXvQAoBQIFACgQAgYnAgcEGy4EAAaAAy4EAAWABC4EAAeABSUAAE9UJwIGBBsAOAUGBS4KgEYABQAoBQIFLQ4BBQAoBQIFPA0EAyYAKAYCDAA4DAQNLQ0NCicCDAQNLQgADS0MCw4tDAUPLQwHEC0MCREtDAoSABAADAAlAABMAy0EAAABKAAEgEYACi0MCgQjAAAgLAAoBgIMADgMBA0tDQ0KJwIMBA0tCAANLQwLDi0MBQ8tDAcQLQwJES0MChIAEAAMACUAAEwDLQQAAAEoAASARgAKLQwKBCMAABxZACgSAhUAOBUDFi0NFhMnAhUEFi0IABYtDBQXLQwNGC0MDhktDA8aLQwTGwAQABUAJQAATAMtBAAAASgAA4BGABMtDBMDIwAABHUoAIAEBHgADQAAAIAEgAMkAIADAAAnTioBAAEF96Hzr6Wt1Mo8AQECJiUAACcmLQgBBScCBgQgABABBgEnAwUEAQAoBQIGJwIHBB8AOAcGBy0MBggMOAgHCRYMCQkkAgAJAAAnmy4KgEsACAAoCAIIIwAAJ3otCAEGAAABAgEtDgUGLgiASgAEIwAAJ7MNKAAEgFEAAyQCAAMAACjbIwAAJ8gtDQEELQ0CBQEoAAWAUQAHDjgFBwgkAgAIAAAn6iUAAE+aLQ4EAS0OBwItDQYBJwICAgAtCAEEJwIFBCAAEAEFAScDBAQBACgEAgUnAgYEHwA4BgUGLQwFBww4BwYIFgwICCQCAAgAAChALQ4CBwAoBwIHIwAAKCEtCAECAAABAgEtDgQCLgiASgADIwAAKFgNKAADgFEABCQCAAQAACh/IwAAKG0tDQIBLQ0BAgAoAgICLQ4CASYtDQIEACgBAgYAOAYDBy0NBwUcDAUHAhwMBwYAHAwGBQIuBAAEgAMoAIAEBAAgJQAATT4uCIAFAAYAKAYCBwA4BwMILQ4FCC0OBgIBKAADgEYABC0MBAMjAAAoWC0NBgMtDQEFLQ0CBwA4BwQIDjgHCAkkAgAJAAAo/iUAAE+aDSgACIBUAAckAgAHAAApEyUAAE0sACgFAgkAOAkICi0NCgcuBAADgAMoAIAEBAAgJQAATT4uCIAFAAUAKAUCCAA4CAQJLQ4HCS0OBQYBKAAEgEYAAy0MAwQjAAAnsyUAACcmLQgBBAAAAQIBLQ4BBC0IAQUAAAECAS0OAgUkAgABAAA8ySMAACmICygAA4BTAAInAgYALCQCAAIAADuJIwAAKaILKAADgFkAAiQCAAIAADn5IwAAKbcLKAADgFoAAiQCAAIAADfYIwAAKcwLKAADgFsAAiQCAAIAADZIIwAAKeELKAADgFwAAiQCAAIAADUXIwAAKfYLKAADgF0AAiQCAAIAADLbIwAAKgsLKAADgF4AAiQCAAIAADGqIwAAKiALKAADgF8AAiQCAAIAADGEIwAAKjULKAADgGAAAiQCAAIAADFeIwAAKkoLKAADgGEAAiQCAAIAADE4IwAAKl8LKAADgGIAAiQCAAIAAC+oIwAAKnQLKAADgGMAAiQCAAIAAC4YIwAAKokLKAADgGQAAiQCAAIAACznIwAAKp4LKAADgGUAByQCAAcAACq3JwIIBAA8CQEILQgBAycCBwRAABABBwEnAwMEAQAoAwIHHySARoBUAActCAEHJwIIBEEAEAEIAScDBwQBACgHAggnAgkEQAA4CQgJLQwICgw4CgkLFgwLCyQCAAsAACscLQ4GCgAoCgIKIwAAKv0tCAEGAAABAgEtDgcGJwIHBEAuCIBKAAIjAAArOQ0oAAKAVAAIJAIACAAALIgjAAArTi0NBgMtDQMGACgGAgYtDgYDKwIABgAAAAAAAAAAQAAAAAAAAAAAJwIMBA0tCAANLQwGDgAQAAwAJQAAPM4tBAAALQwOCC0MDwktDBAKLQwRCy0NCAYAKAYCBi0OBggtDQkGACgGAgYtDgYJLQgBBgAAAQIBLQ4IBi0IAQgAAAECAS0OCQgtCAEJAAABAgEtDgoJLQgBCgAAAQIBLQ4LCi4IgEoAAiMAACv4DDgCBwskAgALAAAsPiMAACwKJwIDBAstCAALLQwGDC0MCA0tDAkOLQwKDwAQAAMAJQAAPW4tBAAALQwMAi0MAgEjAAA8ugAoAwIMADgMAg0tDQ0LJwIMBA0tCAANLQwGDi0MCA8tDAkQLQwKES0MCxIAEAAMACUAAEwDLQQAAAEoAAKARgALLQwLAiMAACv4LQ0GCAEoAAKARgAJACgDAgsAOAsCDC0NDAoMOAkHCyQCAAsAACy0JQAATSwuBAAIgAMoAIAEBABBJQAATT4uCIAFAAsAKAsCDAA4DAkNLQ4KDS0OCwYtDAkCIwAAKzktCAECJwIDBAIAEAEDAScDAgQBACgCAgMfJIBGgEYAAwEoAAKARgAHLQ0HAycCCgQLLQgACy4IgGYADAAQAAoAJQAAPM4tBAAALQwMAi0MDQctDA4ILQwPCS0NAgoAKAoCCi0OCgItDQcKACgKAgotDgoHLQgBCgAAAQIBLQ4CCi0IAQIAAAECAS0OBwItCAEHAAABAgEtDggHLQgBCAAAAQIBLQ4JCCcCCQQLLQgACy0MCgwtDAINLQwHDi0MCA8tDAYQABAACQAlAABMAy0EAAAnAgYECy0IAAstDAoMLQwCDS0MBw4tDAgPLQwDEAAQAAYAJQAATAMtBAAAJwIGBAstCAALLQwKDC0MAg0tDAcOLQwIDwAQAAYAJQAAPW4tBAAALQwMAy0MAwEjAAA8ui0IAQMnAgcEAwAQAQcBJwMDBAEAKAMCBx8kgEaATQAHASgAA4BGAAgtDQgHASgAA4BNAAktDQkILQgBAycCCQQEABABCQEnAwMEAQAoAwIJLQwJCi0OBgoAKAoCCi0OBwoAKAoCCi0OCAotDQMGACgGAgYtDgYDJwIKBAstCAALLgiAZwAMABAACgAlAAA8zi0EAAAtDAwGLQwNBy0MDggtDA8JLQ0GCgAoCgIKLQ4KBi0NBwoAKAoCCi0OCgctCAEKAAABAgEtDgYKLQgBBgAAAQIBLQ4HBi0IAQcAAAECAS0OCActCAEIAAABAgEtDgkILgiASgACIwAALxUNKAACgEgACSQCAAkAAC9eIwAALyonAgMECy0IAAstDAoMLQwGDS0MBw4tDAgPABAAAwAlAAA9bi0EAAAtDAwCLQwCASMAADy6ACgDAgsAOAsCDC0NDAknAgsEDC0IAAwtDAoNLQwGDi0MBw8tDAgQLQwJEQAQAAsAJQAATAMtBAAAASgAAoBGAAktDAkCIwAALxUtCAEDJwIHBAMAEAEHAScDAwQBACgDAgcfJIBGgE0ABwEoAAOARgAILQ0IBwEoAAOATQAJLQ0JCC0IAQMnAgkEBAAQAQkBJwMDBAEAKAMCCS0MCQotDgYKACgKAgotDgcKACgKAgotDggKLQ0DBgAoBgIGLQ4GAycCCgQLLQgACy4IgGcADAAQAAoAJQAAPM4tBAAALQwMBi0MDQctDA4ILQwPCS0NBgoAKAoCCi0OCgYtDQcKACgKAgotDgoHLQgBCgAAAQIBLQ4GCi0IAQYAAAECAS0OBwYtCAEHAAABAgEtDggHLQgBCAAAAQIBLQ4JCC4IgEoAAiMAADClDSgAAoBIAAkkAgAJAAAw7iMAADC6JwIDBAstCAALLQwKDC0MBg0tDAcOLQwIDwAQAAMAJQAAPW4tBAAALQwMAi0MAgEjAAA8ugAoAwILADgLAgwtDQwJJwILBAwtCAAMLQwKDS0MBg4tDAcPLQwIEC0MCREAEAALACUAAEwDLQQAAAEoAAKARgAJLQwJAiMAADClLQgBAgAAAQIBJwMCBAEAKAICAx8kgEaASgADLgiASwABIwAAPLotCAECAAABAgEnAwIEAQAoAgIDHySARoBKAAMuCIBLAAEjAAA8ui0IAQIAAAECAScDAgQBACgCAgMfJIBGgEoAAy4IgEsAASMAADy6LQgBAicCAwQCABABAwEnAwIEAQAoAgIDHySARoBGAAMBKAACgEYABy0NBwMnAgoECy0IAAsuCIBmAAwAEAAKACUAADzOLQQAAC0MDAItDA0HLQwOCC0MDwktDQIKACgKAgotDgoCLQ0HCgAoCgIKLQ4KBy0IAQoAAAECAS0OAgotCAECAAABAgEtDgcCLQgBBwAAAQIBLQ4IBy0IAQgAAAECAS0OCQgnAgkECy0IAAstDAoMLQwCDS0MBw4tDAgPLQwGEAAQAAkAJQAATAMtBAAAJwIGBAstCAALLQwKDC0MAg0tDAcOLQwIDy0MAxAAEAAGACUAAEwDLQQAACcCBgQLLQgACy0MCgwtDAINLQwHDi0MCA8AEAAGACUAAD1uLQQAAC0MDAMtDAMBIwAAPLotCAEDJwIHBAUAEAEHAScDAwQBACgDAgcfJIBGgE4ABy0NAwcAKAcCBy0OBwMtCAEHJwIIBAYAEAEIAScDBwQBACgHAggtDAgJLQ4GCQAoCQIJLQ4GCQAoCQIJLQ4GCQAoCQIJLQ4GCQAoCQIJLQ4GCS0IAQYAAAECAS0OBwYnAgcEBS4IgEoAAiMAADNpDSgAAoBOAAgkAgAIAAA0uCMAADN+LQ0GAy0NAwYAKAYCBi0OBgMrAgAGAAAAAAAAAAAFAAAAAAAAAAAnAgwEDS0IAA0tDAYOABAADAAlAAA8zi0EAAAtDA4ILQwPCS0MEAotDBELLQ0IBgAoBgIGLQ4GCC0NCQYAKAYCBi0OBgktCAEGAAABAgEtDggGLQgBCAAAAQIBLQ4JCC0IAQkAAAECAS0OCgktCAEKAAABAgEtDgsKLgiASgACIwAANCgMOAIHCyQCAAsAADRuIwAANDonAgMECy0IAAstDAYMLQwIDS0MCQ4tDAoPABAAAwAlAAA9bi0EAAAtDAwCLQwCASMAADy6ACgDAgwAOAwCDS0NDQsnAgwEDS0IAA0tDAYOLQwIDy0MCRAtDAoRLQwLEgAQAAwAJQAATAMtBAAAASgAAoBGAAstDAsCIwAANCgtDQYIASgAAoBGAAkAKAMCCwA4CwIMLQ0MCgw4CQcLJAIACwAANOQlAABNLC4EAAiAAygAgAQEAAYlAABNPi4IgAUACwAoCwIMADgMCQ0tDgoNLQ4LBi0MCQIjAAAzaS0IAQInAgMEAgAQAQMBJwMCBAEAKAICAx8kgEaARgADASgAAoBGAActDQcDJwIKBAstCAALLgiAZgAMABAACgAlAAA8zi0EAAAtDAwCLQwNBy0MDggtDA8JLQ0CCgAoCgIKLQ4KAi0NBwoAKAoCCi0OCgctCAEKAAABAgEtDgIKLQgBAgAAAQIBLQ4HAi0IAQcAAAECAS0OCActCAEIAAABAgEtDgkIJwIJBAstCAALLQwKDC0MAg0tDAcOLQwIDy0MBhAAEAAJACUAAEwDLQQAACcCBgQLLQgACy0MCgwtDAINLQwHDi0MCA8tDAMQABAABgAlAABMAy0EAAAnAgYECy0IAAstDAoMLQwCDS0MBw4tDAgPABAABgAlAAA9bi0EAAAtDAwDLQwDASMAADy6LQgBAycCBwQDABABBwEnAwMEAQAoAwIHHySARoBNAAcBKAADgEYACC0NCAcBKAADgE0ACS0NCQgtCAEDJwIJBAQAEAEJAScDAwQBACgDAgktDAkKLQ4GCgAoCgIKLQ4HCgAoCgIKLQ4ICi0NAwYAKAYCBi0OBgMnAgoECy0IAAsuCIBnAAwAEAAKACUAADzOLQQAAC0MDAYtDA0HLQwOCC0MDwktDQYKACgKAgotDgoGLQ0HCgAoCgIKLQ4KBy0IAQoAAAECAS0OBgotCAEGAAABAgEtDgcGLQgBBwAAAQIBLQ4IBy0IAQgAAAECAS0OCQguCIBKAAIjAAA3RQ0oAAKASAAJJAIACQAAN44jAAA3WicCAwQLLQgACy0MCgwtDAYNLQwHDi0MCA8AEAADACUAAD1uLQQAAC0MDAItDAIBIwAAPLoAKAMCCwA4CwIMLQ0MCScCCwQMLQgADC0MCg0tDAYOLQwHDy0MCBAtDAkRABAACwAlAABMAy0EAAABKAACgEYACS0MCQIjAAA3RS0IAQMnAgcEBAAQAQcBJwMDBAEAKAMCBx8kgEaASAAHLQ0DBwAoBwIHLQ4HAy0IAQcnAggEBQAQAQgBJwMHBAEAKAcCCC0MCAktDgYJACgJAgktDgYJACgJAgktDgYJACgJAgktDgYJLQgBBgAAAQIBLQ4HBi4IgEoAAiMAADhYDSgAAoBIAAckAgAHAAA5lyMAADhtLQ0GAy0NAwYAKAYCBi0OBgMnAgoECy0IAAsuCIBoAAwAEAAKACUAADzOLQQAAC0MDAYtDA0HLQwOCC0MDwktDQYKACgKAgotDgoGLQ0HCgAoCgIKLQ4KBy0IAQoAAAECAS0OBgotCAEGAAABAgEtDgcGLQgBBwAAAQIBLQ4IBy0IAQgAAAECAS0OCQguCIBKAAIjAAA5BA0oAAKATgAJJAIACQAAOU0jAAA5GScCAwQLLQgACy0MCgwtDAYNLQwHDi0MCA8AEAADACUAAD1uLQQAAC0MDAItDAIBIwAAPLoAKAMCCwA4CwIMLQ0MCScCCwQMLQgADC0MCg0tDAYOLQwHDy0MCBAtDAkRABAACwAlAABMAy0EAAABKAACgEYACS0MCQIjAAA5BC0NBgcBKAACgEYACAAoAwIKADgKAgstDQsJDSgACIBOAAokAgAKAAA5xiUAAE0sLgQAB4ADKACABAQABSUAAE0+LgiABQAKACgKAgsAOAsIDC0OCQwtDgoGLQwIAiMAADhYLQgBAycCBwQDABABBwEnAwMEAQAoAwIHHySARoBNAAcBKAADgEYACC0NCAcBKAADgE0ACS0NCQgtCAEDJwIJBAQAEAEJAScDAwQBACgDAgktDAkKLQ4GCgAoCgIKLQ4HCgAoCgIKLQ4ICi0NAwYAKAYCBi0OBgMnAgoECy0IAAsuCIBnAAwAEAAKACUAADzOLQQAAC0MDAYtDA0HLQwOCC0MDwktDQYKACgKAgotDgoGLQ0HCgAoCgIKLQ4KBy0IAQoAAAECAS0OBgotCAEGAAABAgEtDgcGLQgBBwAAAQIBLQ4IBy0IAQgAAAECAS0OCQguCIBKAAIjAAA69g0oAAKASAAJJAIACQAAOz8jAAA7CycCAwQLLQgACy0MCgwtDAYNLQwHDi0MCA8AEAADACUAAD1uLQQAAC0MDAItDAIBIwAAPLoAKAMCCwA4CwIMLQ0MCScCCwQMLQgADC0MCg0tDAYOLQwHDy0MCBAtDAkRABAACwAlAABMAy0EAAABKAACgEYACS0MCQIjAAA69i0IAQInAgMEAgAQAQMBJwMCBAEAKAICAx8kgEaARgADASgAAoBGAActDQcDJwIKBAstCAALLgiAZgAMABAACgAlAAA8zi0EAAAtDAwCLQwNBy0MDggtDA8JLQ0CCgAoCgIKLQ4KAi0NBwoAKAoCCi0OCgctCAEKAAABAgEtDgIKLQgBAgAAAQIBLQ4HAi0IAQcAAAECAS0OCActCAEIAAABAgEtDgkIJwIJBAstCAALLQwKDC0MAg0tDAcOLQwIDy0MBhAAEAAJACUAAEwDLQQAACcCBgQLLQgACy0MCgwtDAINLQwHDi0MCA8tDAMQABAABgAlAABMAy0EAAAnAgYECy0IAAstDAoMLQwCDS0MBw4tDAgPABAABgAlAAA9bi0EAAAtDAwDLQwDASMAADy6LgqATAAELQ4BBSMAADzJLQ0FASYlAAAnJi0IAQInAgMEBAAQAQMBJwMCBAEAKAICAy0MAwQuCoBLAAQAKAQCBC4KgEsABAAoBAIELgqASwAELQ0CAwAoAwIDLQ4DAi0IAQMnAgQEBQAQAQQBJwMDBAEAKAMCBC0MBAUuCoBLAAUAKAUCBS4KgEsABQAoBQIFLgqASwAFACgFAgUtDgEFLQwCAS0MAwIuCIBKAAMuCIBJAAQmJQAAJyYtDQQFCygABYBJAAYkAgAGAAA9kCcCBwQAPAkBBycCBQQGLQgABi0MAQctDAIILQwDCS0MBAoAEAAFACUAAE+sLQQAAC0NAQUtDQIGLQ0DBy0OBQEtDgYCLQ4HAy4KgEwABAEoAAaARgACLQ0CASYqAQABBfSAAaZZ0ydCPAEBAiYqAQABBR8AUBJAJCLuPAEBAiYqAQABBQUPhgQj7RZZPAEBAiYlAAAnJjAMAAUABCYlAAAnJi0IAQgnAgkEAwAQAQkBJwMIBAEAKAgCCS0MCQotDgQKACgKAgotDgYKJwILBAwtCAAMLgiAZgANABAACwAlAAA8zi0EAAAtDA0ELQwOBi0MDwktDBAKLQ0ECwAoCwILLQ4LBC0NBgsAKAsCCy0OCwYtCAELAAABAgEtDgQLLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS0OCQYtCAEJAAABAgEtDgoJLgiASgAHIwAAPtgNKAAHgE0ACiQCAAoAAEAxIwAAPu0nAg4EDy0IAA8tDAsQLQwEES0MBhItDAkTABAADgAlAAA9bi0EAAAtDBANCygABYBVAAQLKAANgEsABiQCAAQAAD/2IwAAPzULKAAFgFYABCQCAAQAAD/MIwAAP0oLKAAFgFcABCQCAAQAAD+iIwAAP18LKAAFgFgABCQCAAQAAD94JwIJBAA8CQEJCygABoBJAAQkAgAEAAA/jSUAAFC6LQwBBy0MAggtDAMKLQwNDCMAAEAgCygABoBJAAQkAgAEAAA/tyUAAFC6LQwBBy0MAggtDAMKLQwNDCMAAEAgCygABoBJAAQkAgAEAAA/4SUAAFC6LQwBBy0MAggtDAMKLQwNDCMAAEAgCygABoBJAAQkAgAEAABACyUAAFC6LQwBBy0MAggtDAMKLQwNDCMAAEAgLQwKAy0MBwEtDAgCLQwMBCYkAgAKAABAPiMAAEB8ACgIAgwAOAwHDS0NDQonAgwEDS0IAA0tDAsOLQwEDy0MBhAtDAkRLQwKEgAQAAwAJQAATAMtBAAAIwAAQHwBKAAHgEYACi0MCgcjAAA+2CUAACcmHAwFBgAwDAAGAAQmJQAAJyYtCAEEAAABAgEuCoBLAAQtCAEFAAABAgEuCoBEAAUoAgAGAAEALgiASgADIwAAQNMNKAADgFEAByQCAAcAAEDtIwAAQOgtDQQBJi0IAQcAAAECAS0OAwckAgACAABBByMAAEE1AzCAUQADAAgDKAAIgEYACQ8wgEYACAAKJAIACgAAQSwlAABQzC0OCQcjAABBNS0NBAgtDQcJDSgACYBRAAckAgAHAABBUiUAAE0sACgBAgoAOAoJCy0NCwccDAcJAC0NBQcEOAkHCgA4CAoJLQ4JBAQ4BwYILQ4IBQEoAAOARgAHLQwHAyMAAEDTJQAAJyYBMIBDAAQABi8MAAYABwsoAAeASwAIJAIACAAAQbklAABQ3igCAAcA3q0wDAAHAAYrAgAGAAAAAAAAAAABAAAAAAAAAAAnAgsEDC0IAAwtDAYNABAACwAlAAA8zi0EAAAtDA0HLQwOCC0MDwktDBAKLQ0HBgAoBgIGLQ4GBy0NCAYAKAYCBi0OBggtCAEGAAABAgEtDgcGLQgBBwAAAQIBLQ4IBy0IAQgAAAECAS0OCQgtCAEJAAABAgEtDgoJJwIKBAstCAALLQwGDC0MBw0tDAgOLQwJDy0MBRAAEAAKACUAAEwDLQQAACcCCwQMLQgADC0MBg0tDAcOLQwIDy0MCRAAEAALACUAAD1uLQQAAC0MDQowDAAFAAQBKAAEgEQABTAMAAoABSYlAAAnJicCBgQHLQgABy0MAQgtDAIJABAABgAlAABN8C0EAAAtDAgFCygAA4BPAAEBKAAFgEYABi0NBgIkAgABAABDSCMAAEMICygAA4BQAAEkAgABAABDPyMAAEMdCygAA4BSAAEkAgABAABDNicCBQQAPAkBBS0MAgQjAABDUS0MAgQjAABDUS0MAgQjAABDUS0MBAEmJQAAJyYeAgAEAB4CAAUAMzgABAAFAAYkAgAGAABDeiUAAFDwJiUAACcmLwwABAAFLQwFASYqAQABBXnVBl6+c3TSPAEBAiYlAAAnJicCBgQHLQgABy0MAQgtDAIJABAABgAlAABENC0EAAAtDAgFCygAA4BPAAEBKAAFgEYABi0NBgIkAgABAABEJiMAAEPmCygAA4BQAAEkAgABAABEHSMAAEP7CygAA4BSAAEkAgABAABEFCcCBQQAPAkBBS0MAgQjAABELy0MAgQjAABELy0MAgQjAABELy0MBAEmJQAAJyYtDQEDLQ0CBA0oAASATQAFJAIABQAARFYlAABNLAAoAwIGADgGBActDQcFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgBKAAEgEYABQ44BAUHJAIABwAARJ4lAABPmi0OAwEtDgUCLQwGASYlAAAnJicCBgQHLQgABy0MAQgtDAIJABAABgAlAABENC0EAAAtDAgFCygAA4BPAAEBKAAFgEYABi0NBgIkAgABAABFNCMAAET0CygAA4BQAAEkAgABAABFKyMAAEUJCygAA4BSAAEkAgABAABFIicCBQQAPAkBBS0MAgQjAABFPS0MAgQjAABFPS0MAgQjAABFPS0MBAEmKgEAAQVaa2tNiHofZzwBAQImJQAAJyYvDAAEAAUcDAUGARwMBgQAHAwEBQEtDAUBJioBAAEFyMIboz06UAU8AQECJiUAACcmLQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgonAgsEDC0IAAwuCIBmAA0AEAALACUAADzOLQQAAC0MDQQtDA4GLQwPCS0MEAotDQQLACgLAgstDgsELQ0GCwAoCwILLQ4LBi0IAQsAAAECAS0OBAstCAEEAAABAgEtDgYELQgBBgAAAQIBLQ4JBi0IAQkAAAECAS0OCgkuCIBKAAcjAABGOQ0oAAeATQAKJAIACgAAR5IjAABGTicCDgQPLQgADy0MCxAtDAQRLQwGEi0MCRMAEAAOACUAAD1uLQQAAC0MEA0LKAAFgFUABAsoAA2ASwAGJAIABAAAR1cjAABGlgsoAAWAVgAEJAIABAAARy0jAABGqwsoAAWAVwAEJAIABAAARwMjAABGwAsoAAWAWAAEJAIABAAARtknAgkEADwJAQkLKAAGgEkABCQCAAQAAEbuJQAAULotDAEHLQwCCC0MAwotDA0MIwAAR4ELKAAGgEkABCQCAAQAAEcYJQAAULotDAEHLQwCCC0MAwotDA0MIwAAR4ELKAAGgEkABCQCAAQAAEdCJQAAULotDAEHLQwCCC0MAwotDA0MIwAAR4ELKAAGgEkABCQCAAQAAEdsJQAAULotDAEHLQwCCC0MAwotDA0MIwAAR4EtDAoDLQwHAS0MCAItDAwEJiQCAAoAAEefIwAAR90AKAgCDAA4DAcNLQ0NCicCDAQNLQgADS0MCw4tDAQPLQwGEC0MCREtDAoSABAADAAlAABMAy0EAAAjAABH3QEoAAeARgAKLQwKByMAAEY5KgEAAQWBBBWe7dZF0jwBAQImJQAAJyYtCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCicCCwQMLQgADC4IgGYADQAQAAsAJQAAPM4tBAAALQwNBC0MDgYtDA8JLQwQCi0NBAsAKAsCCy0OCwQtDQYLACgLAgstDgsGLQgBCwAAAQIBLQ4ECy0IAQQAAAECAS0OBgQtCAEGAAABAgEtDgkGLQgBCQAAAQIBLQ4KCS4IgEoAByMAAEi0DSgAB4BNAAokAgAKAABKDSMAAEjJJwIOBA8tCAAPLQwLEC0MBBEtDAYSLQwJEwAQAA4AJQAAPW4tBAAALQwQDQsoAAWAVQAECygADYBLAAYkAgAEAABJ0iMAAEkRCygABYBWAAQkAgAEAABJqCMAAEkmCygABYBXAAQkAgAEAABJfiMAAEk7CygABYBYAAQkAgAEAABJVCcCCQQAPAkBCQsoAAaASQAEJAIABAAASWklAABQui0MAQctDAIILQwDCi0MDQwjAABJ/AsoAAaASQAEJAIABAAASZMlAABQui0MAQctDAIILQwDCi0MDQwjAABJ/AsoAAaASQAEJAIABAAASb0lAABQui0MAQctDAIILQwDCi0MDQwjAABJ/AsoAAaASQAEJAIABAAASeclAABQui0MAQctDAIILQwDCi0MDQwjAABJ/C0MCgMtDAcBLQwIAi0MDAQmJAIACgAAShojAABKWAAoCAIMADgMBw0tDQ0KJwIMBA0tCAANLQwLDi0MBA8tDAYQLQwJES0MChIAEAAMACUAAEwDLQQAACMAAEpYASgAB4BGAAotDAoHIwAASLQqAQABBftC3tO8Eo0CPAEBAiYqAQABBdBN6s+si/1jPAEBAiYqAQABBYuNKgtyIlJQPAEBAiYqAQABBXQCMHxH1axzPAEBAiYlAAAnJicCBgQHLQgABy0MAQgtDAIJABAABgAlAABRAi0EAAAtDAgFCygAA4BPAAEBKAAFgEYABi0NBgIkAgABAABLOiMAAEr6CygAA4BQAAEkAgABAABLMSMAAEsPCygAA4BSAAEkAgABAABLKCcCBQQAPAkBBS0MAgQjAABLQy0MAgQjAABLQy0MAgQjAABLQy0MBAEmJQAAJyYnAgYEBy0IAActDAEILQwCCQAQAAYAJQAAUQItBAAALQwIBQsoAAOATwABASgABYBGAAYtDQYCJAIAAQAAS9EjAABLkQsoAAOAUAABJAIAAQAAS8gjAABLpgsoAAOAUgABJAIAAQAAS78nAgUEADwJAQUtDAIEIwAAS9otDAIEIwAAS9otDAIEIwAAS9otDAQBJioBAAEFDQou8vbC++88AQECJioBAAEFRI2qKaKhQLc8AQECJiUAACcmLQ0DBi0NBAcLKAAHgEkACCQCAAgAAEwpJwIJBAA8CQEJCygABoBIAAckAgAHAABMuCMAAEw+LQ0BBi0NAgctDQMILQ0ECQ0oAAiASAAKJAIACgAATGMlAABNLC4EAAaAAygAgAQEAAQlAABNPi4IgAUACgAoCgILADgLCAwtDgUMASgACIBGAAUOOAgFBiQCAAYAAEyjJQAAT5otDgoBLQ4HAi0OBQMtDgkEIwAATSsnAgYEBy0IAActDAEILQwCCS0MAwotDAQLABAABgAlAABPrC0EAAAtDQEGLQ0CBy0NBAguBAAGgAMoAIAEBAAEJQAATT4uCIAFAAkAKAkCCgEoAAqASgALLQ4FCy0OCQEtDgcCLgqARgADLQ4IBCMAAE0rJioBAAEFxWvEWg4QAAI8AQECJi4BgAOABgsAgAYAAoAHJACABwAATVkjAABNZC4AgAOABSMAAE3LLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAATbcuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAATYYoAYAFBAABAwCABgACgAYjAABNyyYqAQABBYydEbQ59GaQPAEBAiYqAQABBZaHLyYENfT2PAEBAiYlAAAnJi0NAQMtDQIECygABIBKAAUkAgAFAABOEiUAAE0sASgAA4BGAAUtDQUELQgBBScCBgQCABABBgEnAwUEAQAoBQIGLQwGBy0OBActDgMBLgqARgACLQwFASYqAQABBaZenvUHdWn8PAEBAiYqAQABBUy0RpwQyvfvPAEBAiYqAQABBX9HTss9arW+PAEBAiYqAQABBfi4yxYMIODjPAEBAiYlAAAnJi0NAQMtDQIEDSgABIBIAAUkAgAFAABOtyUAAE0sACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASARgAFDjgEBQckAgAHAABO/yUAAE+aLQ4DAS0OBQItDAYBJioBAAEF7FAZWNnuATg8AQECJioBAAEFY5jT8h3nWWQ8AQECJioBAAEFgw2jMUCxgSA8AQECJioBAAEFhUwVuY+esCk8AQECJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAABPmS4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAABPaCYqAQABBUWnynEZQeQVPAEBAiYlAAAnJi4IgEoABSMAAE+8DSgABYBIAAYkAgAGAABQJyMAAE/RLQ0BBS0NAgYtDQMHLQ0ECC0IAQknAgoEBQAQAQoBJwMJBAEAKAYCCicCCwQEACgJAgw/DwAKAAwtDQkGACgGAgYtDgYJLQ4FAS0OCQItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEYABiQCAAcAAFBFIwAAULEtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAE0+LgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAAULEtDAYFIwAAT7wqAQABBQLcbieAdhKdPAEBAiYqAQABBSiGkrBH3P1DPAEBAiYqAQABBR8KLSfcgoeiPAEBAiYqAQABBb4eP/8+pPb6PAEBAiYlAAAnJi0NAQMtDQIEDSgABIBOAAUkAgAFAABRJCUAAE0sACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASARgAFDjgEBQckAgAHAABRbCUAAE+aLQ4DAS0OBQItDAYBJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "transfer_in_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954044801249163952": {
            "error_kind": "string",
            "string": "NFT not found when transferring"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdBZwUR/O9IHechYMEiAfiQGR61mYjxN3dZXdnN+7u7u7uQkKIu7u7u7uHuJJ/VzIXdpdZTubV/KvybX+//u4YLk29rlfV9Xq696Zq+KcVhtn/m/6f76eyvW/wtY/tw6uedX4t/75/yM+1hjxrD3k2MOTZoJBnQ21frOrZrCE/Nzzk2YiQZ7OFPJs7eFbepgq+LhZ8TTjpZLKYcYsmYXKOm817KSeZyqc945mUl/JdL5Eoekkvk81nM07WJBNFU0plEyXnn0b/WOdYTqTmFjjtnKr3dqaqH5Btg23vV26rHX9i8P08DZO+H1n2/VTBz3T+d33sn/va3s/2/n0nPe9sfavmwInWzCjgWH364nzTCOOQ5SPj/I0GjtUXOH9NwPkL43ZjGbebyr7vV/Z9/ypuD7B/bra9xfbWEG73Aftm7gbcfLbh5tOU52MadzjzPLQBedXONA/twTz0q5qD8jYVeF6mauDJMQ1YO/NhY0+WyCIv2sCJnQdo19TAREbkGlJGJE5yTQ1OwJ1tYF9Gg2lw9LgdfbEk5cDd0XfSBIPGdaZErqjzMAhXYfucdg7uvZ3J6gdhVcigsmqDWuf3fcq+H1xVhUxj/zyt7UNsHxpDhT0AuGJOA4ylYcwV4rAy30xb9v2Qsu+HVvlmOvvn6W2fwfYZQ3yD5udMfXXE+8y9t9OtftCVUp2u7PuZyr6fucpXs9g/z0pVm+0jAl/1a5i021CrLYaZb9O5QzOleXeiNTNdTPxwojUzC4OdU9UyNiqZO4AJkQhHyb5/w+QNPcnzNPCQoQFkZyGT8ZJZk+Gcg1mUBER7X9m+6rSzXObOFmTN2fsqCb6KveayfQwOm2n8vgzjouZiNmBlNgeTj+Yo22Pp2xCPDJ6dQQaXr/xzagqWKZVdc3az7JrL/nlu2+exfWTfyTfMkNiBzvt7G4BsR29uzg4MvLnAqwYHH+cEzmEy4+cKfiaB5PmcAH/kPDeVcL1iQ1lDz+Uo3BZKidPO0b23M1H9ICwHjarxkrJcBo6uykHz2j/PZ/v8ti9QJv36NcSzqMz7vyp3uOxDVlfF0j9NanXl4Oxyy6srZwoVsBOt/f2WWdsetcHNcyYscZkaiWtKxZNr/5ywPWl7qixxxfVSyGWohqml+zIanA4hXlRy0KTTnk1bg75JH9wQ3lD2Mo3rMo3r8IzrMo07aX7RPAMepeLCXh+3Pm593P/guMCx/96pGtgQ3kD/Rt2P9XHr49bH/c+Oq2Rso9PunFe3O067/6kJqNHXHYLvM1ZXe7ZnbV/Q9oVsX9j2RWwfY/uipLttX9z2JWxf0valbF/a9mVsX9b25Wxf3vYVbF/R9pVsX9n2VWxf1fbVbF/d9jVsX9P2tWxf2/Z1bF/X9vVsX9/2DWzf0PaNbN/Y9k1s39T2zWzP2Z63vWC7b3vR9pLtm9u+he1b2r6V7Vvbvo3t29q+ne3b276D7TvavpPtO9u+i+272r6b7bvbvofte9q+l+17276P7fvavp/t+9t+gO0H2n6Q7Qfbfojth9p+mO2H236E7UfafpTtR9t+jO3H2n6c7cfbfoLtJ9p+ku0n236K7afafprtp9t+hu1n2n6W7Wfbfo7t59p+nu3n236B7RfafpHtF9t+ie2X2n5Z34bKe2HkzKmqnpEzB1Q9GxPyc0uG/NzSIT+3QsjPrRTyc6uH/NyaIT+3XsjPbRDyc5uG/Fwu5OdKIT+3RcjPbRvyc9uH/NwuIT+3W8jP7R3yc/uG/NxBIT93SMjPHRnyc0eH/NwJIT93UsjPnR7yc2eG/Nx5IT93QcjPXRr8HP25paGeUP4zCaXhn930xoZJm2vlC0ZD2TNqiwVfnWjNEG9AYzlcNnoKbMwqsHFBBTYupMDGhRXYuIgCG8cosHFRBTYupsDGxRXYuIQCG5dUYONSCmxcWoGNyyiwcVkFNi6nwMblFdi4ggIbV1Rg40oKbFxZgY2rKLBxVQU2rqbAxtUV2LiGAhvXVGDjWgpsXFuBjesosHFdBTaup8DG9RXYuIECGzdUYONGCmzcWIGNmyiwcVMFNm6mwMacAhvzCmwsKLDRV2BjUYGNJQU2bq7Axi0U2LilAhu3UmDj1gps3EaBjdsqsHE7BTZur8DGHRTYuKMCG3dSYOPOCmzcRYGNuyqwcTcFNu6uwMY9FNi4pwIb91Jg494KbNxHgY37KrBxPwU27q/AxgMU2HigAhsPUmDjwQpsPESBjYcqsPEwBTYersDGIxTYeKQCG49SYOPRCmw8RoGNxyqw8TgFNh6vwMYTFNh4ogIbT1Jg48kKbDxFgY2nKrDxNAU2nq7AxjMU2HimAhvPUmDj2QpsPEeBjecqsPE8BTaer8DGCxTYeKECGy9SYOPFCmy8RIGNlyqw8TKgjeWfvr9Z8P1YO/7ltl9h+zjbr7R9vO1X2X617dfYfq3t19l+ve032H6j7TfZfrPtt9h+q+232X677XfYfqftd9l+t+332H6v7ffZfr/tD9j+oO0P2f6w7Y/Y/qjtj9n+uO1P2P6k7U/Z/rTtz9j+rO3P2f687S/Y/qLtL9n+su2v2P6q7a/Z/rrtb9j+pu1v2f627e/Y/q7t79n+vu0f2P6h7R/Z/rHtn9j+qe2f2f657V/Y/qXtX9n+te3f2P6t7RNs/872723/wfYfbf/J9p9t/8X2X23/zfbfbf/D9j9tn2j7X7bThypNZXsf2/va3s/2/rY3Bg5p6vePTzoCnwywf262vcX2VtvbbG+3fWrbB9reYfsg2wfbPo3t09o+xPahtg8Lxpyu/Fd50ldybPWHe10X8uyWkGd3hTx7IOTZYyHPngl59lLIszdCnr0X8uyTkGdfhTz7PuTZryHP/gp5Rs6pfkZOGV71rDnkWUvIs9aQZ20hz9pDnk0d8mxgyLOOkGeDQp4NDnk2TcizaUOeDQl5NjTk2bCQZ9MFz8pb3+DrYsFXJ1pDfpBYxQcDRf1tGdP3w9nV0IBfZOiDSKbvN/m4UXHPgMPtlHNphhAu9QHbvjTQ/zOC/f+/Fj8z9cMWalriZ6YhsnETr2diwD3zEHxhHhYvke0ExjXQ1wY4fyzrDX34zMwMvJmFab2ZJYb1ZiVgvpw1pvUmqp3D//vxw5J32eJHOG7i9XAG3LMqWW9GAOMF6Gszq/D1hj5waAQDb2ZjWm9mi2G9WRO43syuZL2Z478fPyx5lyt+hgvHTbyegwH3CCXrzZzAeAH62owQvt7Qh0zNycCbuZjWm7liWG82AK43cytZb+b578cPS97lip/ZhOMmXs/DgHt2JevNSGC8AH1tZhe+3tAHi41k4M0opvVmVAzrTQ643oxWst7M+9+PH5a8yxU/cwjHTbyelwH3nErWm/mA8QL0tZlT+HpDHyY3HwNv5mdab+aPYb3ZArjeLKBkvXH++/HDkne54mcu4biJ1w4D7rmVrDcGGC9AX5u5ha839AGChoE3LtN648aw3mwPXG8SStab5H8/fljyLlf8zCMcN/E6yYB7pJL1JgWMF6CvzUjh6w19aGSKgTdppvUmHcN6sxtwvckoWW+8/378sORdrvgZJRw38dpjwD1ayXqTBcYL0NdmtPD1hj4oNMvAmwWZ1psFY1hv9gWuNwspWW8W/u/HD0ve5YqfeYXjJl4vzIB7PiXrzSLAeAH62swnfL2hD4ddhIE3Y5jWmzExrDeHANebRZWsN4v99+OHJe9yxc/8wnH/zWsG3AsoWW8WB8YL0NdmAeHrDX0g8OIMvFmCab1ZIob15mjgerOkkvVmqf9+/LDkXa74cYTjJl4vxYDbKFlvlgbGC9DXxghfb+hDoJdm4M0yTOvNMjGsNycB15tllaw3y/3344cl73LFjyscN/F6OQbcCSXrzfLAeAH62iSErzf0wd/LM/BmBab1ZoUY1pszgevNikrWm5X++/HDkne54icpHDfxeiUG3Ckl683KwHgB+tqkhK83F1hHrMzAm1WY1ptVYlhvLgCuN6sqWW9W++/HjxPGFSda+zd+UOMRX1ZjiMemfjx5HD2f5XZGxTwdELMdqmFoGd7yJtBXpvObEHNhY5fPxer9/vm6Rr+Gyg/rXj0gc/mzNfp1/QHeyEns5VhuMJZZHUjKNYDO7QkpnWjNDAAEU+mfFhsp1wxIuVY1KdcMIeVa3SClE61VTGJUUq4JJOVaYOeiyUcBuCbDqrgmeFWs445mX/EfDuUoTgg7uLrIDADGzNrAOSScLQ2TN6SPOPi5dj/5Nq6DtvF/kezrAiWOVrKvq4Ds62khO7iygpIdWe6vj3OIqzVw1lcQOBvUAyeyjSVk4GyIc0hCa+BsqCBwNqoHTmQbi8jA2RjnkKTWwNlYQeBsUtcl0cm+KW4SU1rJvqkCsm9WXyUi21hArhI5nEPSWgMnpyBw8lIDp1wsr4NfJSreuTnRWsUWYFS8NAZ6Duk3p3e+J0WO6wk/tEaY18MnXTMWeIAHuKNmPObDLFGxXh7wEOnfDRhyw+VA/6I3ftAxfAVTblhYQW7YiCE3XAHkDnDvw3D7IyrWcUw8HKOAh5sw8HAckIfArQQzRvgadSXDGrUZwxp1JdC/aPWM9sl4Bp/kGXwyHuiTfD/ZeatTUzRgx2Wx9XJFtl6hyNZximy9UpGt45lsVXrI3ISYixq74jxvIZhzv/o8r6/sQHkBuCHlAx0Z54HyZoUHyosBAUvVBCyGHCgvxXCgvBlIyiKQlCXhB8opAIsMarYovCrUijvq6z2KkwLDu+xmYMxsXj9QbjbvJ9/GLaS/y9ZA9i3rB8rNlgrIvpUWsqMPbiDJjiz3t64fKDdbKwicbeqBE/1AOTJwtq0fKDfbKgic7eqBE/1AOTJwtq8fKDfbKwicHeq6JDrZd6wfKDc7KiD7TvVVIvqBcuQqsXP9QLnZWUHg7CL9QDmRcguGwx8F4I7TFuAD5egDOVf1/Sf5IOduKwafXAU8kIPeqUL75GoGn2zD4JOrgT7ZRrhPrmHwyXYMPrkG6JPthPvkWgaf7MDgk2uBPtlBuE+uY/DJTgw+uQ7ok52E++R6Bp/swuCT64E+QRavYWedOC5HDmCYU+QVesA5rNg/bXbX4BzWbtXnsHYNOYe1W9k5LLSDO6+N91Pi4KhnxHYF2rUbE/HQiRaJeXdgwg7jsxOt/X3zImzXCpEIUWMhd632EO4P4sse/fB5aw9wccOVVyUvnHsKP+vZuQnUgB2XxdarFdl6jSJbr1Vk63WKbL2eydYwUdLZBN8AckPMZSn89wrmfO/qwn+vkMJ/77LCv7NJvhW0F3Bx2hvo3J6Q0onWTAtgUY37VtA+ASn3rSblPiGk3LcbpHSitYpJjErKfYCk3BfsXDT5KAD3Yai29xFeKWrFHfWMBsXJXgwHklqAMbMfcA61nqvYr598G/eXfiBJA9kPAG7HaCX7AQrIfqAWsqNP3yHJjiz3D8I5RO2toIMUBM7B9cCJfisIGTiH4Byi9lbQIQoC59B64ES/FYQMnMNwDlF7K+gwBYFzeF2XRCf7EbhJVHsr6AgFZD+yvkpEvxWEXCWOwjlE7a2goxQEztFSA6dcLO/PcCBkL+CO0/7AwKEx+oDn8Ia+/yQf5NwdyOCTG4AnhtE7VWif3Mjgk4MZfHIj0CcHC/fJTQw+OZTBJzcBfXKocJ/czOCTwxl8cjPQJ4cL98ktDD45ksEntwB9cqRwn9zK4JOjGXxyK9An8OI1aGjfIIXVMcwH1xEH/gsMR0qOBeIOO9eG9jnNQTPQZhpvT4Z4RH6GDuAMX+w3yo4LzvAdX32G77iQM3zH9+O7UdbMFDibCP89S53ERuPedAjP4tAIxs8VgFHPfx4HtOt4YCIE8tkAOBLLTUSkL05gLiCcaM1QgXMsQz44UfhZXPLLiQpwc3H8GCDHTwJzvLP1A/scmftP/u/m2H8bR9zRpvNJ/Sb5WLKtNyqy9SZFtt6syNZbFNl6K5OtYQK+swm+LZkIMZdF1J4SzPmp1aL2lBBRe2qZqO1skm9LngJcNE8FOrcnpHSiNdMKWOzjvi15WkDK06tJeVoIKU/vBimdaK1iEqOS8jQgKU8HOxdNPgrA0xiUymnCFZpW3FHPrlGcnMJwULMVGDNnAOeQcGo8b3ZGP/k2nin9oKYGsp8FlPpayX6WArKfrYXs6FPJSLIjy/1zcA5Re1vyHAWBc249cKLflkQGznk4h6i9LXmegsA5vx440W9LIgPnApxD1N6WvEBB4FxY1yXRyX4RbhLV3pa8SAHZL66vEtFvSyJXiUtwDlF7W/ISBYFzqdTAKRfLZzKcEj4FuON0JjBwaAz0QaTb+v6TfJBzdzaDT24D3qRA71ShfXI7g0/OZfDJ7UCfnCvcJ3cw+OR8Bp/cAfTJ+cJ9cieDTy5k8MmdQJ9cKNwndzH45GIGn9wF9MnFwn1yN4NPLmXwyd1An8CL16ChfYMUVpcxX3ZAHHo/Fi90DfKW6LFAf4wFcjDsvB06/mgeW4BzSYdhT2Y4QgQ4Dxj7zcvLg/OAV1SfB7w85DzgFf1q37x0orW/f2vCMQxO2Vb4zQcuMm7HdPOyP9hO5PnPy4FJ8gpgwgFy0Gyn5LYk0hfjmAsIJ1ozVOCMZYjhK/vJzl3klysV4Obi+GVAjo8Hc7yzoS+RXPXfzYv/No5YoY3i8f0m+UWyrbcrsvUORbbeqcjWuxTZejeTrWHitrMJvuGYDDGXRTxeHcz5NdXi8eoQ8XhNmXjsbJJvOF4NXNyvATq3J6R0ojXTBljs477heG1AyuuqSXltCCmv6wYpnWitYhKjkvJaICmvAzsXTT4KwGsZ1MW1wlWVVtxRz5tRnFzNcLiyDRgz1wPnkHBqPCN2fT/5Nt4g/XClBrLfCJT6Wsl+owKy36SF7OiTxEiyI8v9m3EOUXvD8WYFgXNLPXCi33BEBs6tOIeoveF4q4LAua0eONFvOCID53acQ9TecLxdQeDcUdclgPPVuElUe8PxTgVkv6u+SkS/4YhcJe7GOUTtDce7FQTOPVIDp1ws38Bw0v5q4I7TDcDAoTHQh4fu6ftP8kHO3U0MPrkHePsBvVOF9sm9DD65hcEn9wJ9cotwn9zH4JPbGHxyH9Antwn3yf0MPrmDwSf3A31yh3CfPMDgk7sYfPIA0Cd3CffJgww+uYfBJw8CfQIvXoOG9g1SWN3LfEEBcVB9LF7oGuTNzrFAf9wH5GDYeTt0/NE8tgLnkg7DXsVwhAhwHjD2G473B+cBH6g+D3h/yHnAB/rx3XAkB1/G4JR9hN984CLjvkpuOCLPf94PTJIPABMOkINmXyU3HJG+eJC5gHCiNUMFzn0MMfxQP9m5i/zykALcXBy/F8jxh8Ec72zoSySP/Hfz4r+NI1Zoo/jhfpP8ItnWexXZep8iW+9XZOsDimx9kMnWMHHb2QTfcEyFmMsiHh8N5vyxavH4aIh4fKxMPHY2yTccHwUu7o8BndsTUjrRmmkHLPZx33B8PCDlE9WkfDyElE90g5ROtFYxiVFJ+TiQlE+AnYsmHwXg4wzq4nHhqkor7qjnzShOHmU4XNkOjJkngXNIODWeEXuyn3wbn5J+uFID2Z8GSn2tZH9aAdmf0UJ29EliJNmR5f6zOIeoveH4rILAea4eONFvOCID53mcQ9TecHxeQeC8UA+c6DcckYHzIs4ham84vqggcF6q65LoZH8ZN4lqbzi+rIDsr9RXieg3HJGrxKs4h6i94fiqgsB5TWrglIvlpxhO2j8K3HF6Chg4NAb68NBDff9JPsi5e4bBJw8Bbz+gd6rQPnmYwSfPMfjkYaBPnhPuk0cYfPICg08eAfrkBeE+eZTBJy9xrCdAn7wk3CePMfjkFQafPAb0ySvCffI4g09eY/DJ40CfwIvXoMFzGLA+fJ35ggLioPp9eKFrkDc77wP64w0gB8PO26Hjj+axDTiXdBj2EYYjRIDzgLHfcHwzOA/4VvV5wDdDzgO+1Y/vhiM5+F4Gpxwt/OYDFxmPUXLDEXn+801gknwLmHCAHDTHKLnhiPTF28wFhBOtGSpw3mCI4Xf6yc5d5Jd3FODm4vjrQI6/C+Z4Z0NfInnvv5sX/20csUIbxe/2m+QXybY+rMjWRxTZ+qgiWx9TZOvjTLaGidvOJviGYzrEXBbx+H4w5x9Ui8f3Q8TjB2XisbNJvuH4PnBx/wDo3J6Q0onWzNSAxT7uG44fBqT8qJqUH4aQ8qNukNKJ1iomMSopPwSS8iOwc9HkowD8kEFdfChcVWnFHfW8GcXJ+wyHK6cGxszHwDkknBrPiH3cT76Nn0g/XKmB7J8Cpb5Wsn+qgOyfaSE7+iQxkuzIcv9znEPU3nD8XEHgfFEPnOg3HJGB8yXOIWpvOH6pIHC+qgdO9BuOyMD5GucQtTccv1YQON/UdUl0sn+Lm0S1Nxy/VUD2CfVVIvoNR+Qq8R3OIWpvOH6nIHC+lxo45WL5E4aT9u8Dd5w+AQYOjYE+PPRE33+SD3LuPmPwyRPA2w/onSq0T55k8MkXDD55EuiTL4T75CkGn3zF4JOngD75SrhPnmbwyTcMPnka6JNvhPvkGQafTGDwyTNAn0wQ7pNnGXzyPYNPngX6BF68Bg3tG6Sw+oH5ggLioPobeKFrkDc73wD640cgB8PO26Hjj+axHTiXdBj2PYYjRIDzgLHfcPwpOA/4c/V5wJ9CzgP+3I/vhiM5+HUGp5wl/OYDFxnPVnLDEXn+8ydgkvwZmHCAHDRnK7nhiPTFL8wFhBOtGSpwfmSI4V/7yc5d5JdfFeDm4vgPQI7/BuZ4Z0NfIvn9v5sX/20csUIbxb/1m+QXybY+qcjWpxTZ+rQiW59RZOuzTLaGidvOJviGYybEXBbx+Ecw539Wi8c/QsTjn2XisbNJvuH4B3Bx/xPo3J6Q0onWzEDAYh/3DceJASn/qiblxBBS/tUNUjrRWsUkRiXlRCAp/wI7F00+CsCJDOpionBVpRV31PNmFCd/MByuHAiMGdr+Qs0h4dR4Rgw5B1w2ToW28X+R7H1wk6j2hmMfBWTvq4Xs6JPESLIjy/1+OIeoveHYT0Hg9K8HTvQbjsjAacQ5RO0Nx0YFgdNUD5zoNxyRgTMA5xC1NxwHKAic5rouiU72Ftwkqr3h2KKA7K31VSL6DUfkKtGGc4jaG45tCgKnXWrglItl2mIDrxIV79ycaK1iC1DiDcfn+v6TfJBz15fBJ88Bbz+gd6rQPnmewSf9GXzyPNAn/YX75AUGnzQx+OQFoE+ahPvkRQafNDP45EWgT5qF++QlBp+0MvjkJaBPWoX75GUGn7Qz+ORloE/aGQpsDt8ghdXUwDelNAa6Xu+8oIA+2oS82fkj0B8DgRyM44YjzePUwLmkw7C/MxwhApwHjP2GY0dwY21Q/4bKs3/0F9XnAemHhgf/Icevi/iBwSlXCL/5wEXGcUpuOCLPf3YANzUGARctIAfNOCU3HJG+GMxcQDjRmqECZ2B/fAxP01927iK/TKMANxfHpwZyfFowxzsb+hLJkP9uXvy3ccQKbRRP23+SXyTb+rwiW19QZOuLimx9SZGtLzPZqvSGoxdiLot4HBrM+bBq8Tg0RDwOKxOPnU3yDcehwMV9WH+cc+O84dih8IbjdAEpp68m5XQhpJy+G6R0orWKSYxKyumApJy+P9a5aPJRAE7HoC6mE66qtOKOet6M4mQo/vVNpgO4dT5D/YajmaG/fBtnlH64UgPZZ6rfcDQzKSD7zFrIjj5JjCQ7styfpX7D0cyiIHBmrQdO9BuOyMAZXr/haIYrCJwR9cCJfsMRGTiz1W84mtkUBM7sdV0Snexz1G84mjkUkH3O+ioR/YYjcpWYq37D0cylIHDmln7DkUg5I8NJ+6HAHacZhd9wfKXvP8kHOXczM/jkFeDtB/ROFdonrzL4ZFYGn7wK9Mmswn3yGoNPRjD45DWgT0YI98nrDD6ZncEnrwN9Mrtwn7zB4JM5GXzyBtAncwr3yZsMPpmbwSdvAn0CL16DhvYNUljNI/yGY+cFBfTRJuTNzoFAf4xUdsPxb/8AbzjSYdghDEeIOhTecBwVnAccXX0ecFTIecDRjDccycFTMzjlVuE3H7jIeJuSG47I85+jgElyNDB5AzloblNywxHpi3mZCwgnWjNU4IxkiOH5hJ/FJb/MpwA3F8fnAXJ8fjDHOxv6EskC/928+G/jiBXaKJ6//yS/SLb1VUW2vqbI1tcV2fqGIlvfZLJV6Q3HbIi5LOLRCebcVItHJ0Q8mm5cJpN0w9EBLu4Gd8MxG+cNx0EKbzi6ASkT1aR0Q0iZiOGG4yAgKV0gKRP9sc5Fk48C0GVQF65wVaUVd9TzZhQnDsPhykHAw5XJ+g1Hk+wv38aU9MOVGsiert9wNGkFZM9oITv6JDGS7Mhy36vfcDSegsDJ1gMn+g1HZOAsWL/haBZUEDgL1QMn+g1HZOAsXL/haBZWEDiL1HVJdLKPqd9wNGMUkH3R+ioR/YYjcpVYrH7D0SymIHAWl37DkUiZYjhp7wB3nFLAwKEx0IeH3ur7T/JBzl2GwSdvAW8/oHeq0D55m8EnWQafvA30SVa4T95h8MlCDD55B+iThYT75F0GnyzC4JN3gT5ZRLhP3mPwyaIMPnkP6JNFhfvkfQafLM7gk/eBPoEXr0FD+wYprJYQfsOx84IC+mgT8mbnSKA/llR2w5HmEfHbBDrHo8OwCzAcIRqk8IbjUsF5wKWrzwMuFXIecGnGG47k4HkYnPKI8JsPXGR8VMkNR+T5z6WASXJpYPIGctA8quSGI9IXyzAXEE60ZqjAWZIhhpcVfhaX/LKsAtxcHF8CyPHlwBzvbOhLJMv/d/Piv40jVmijeLn+k/wi2da3Fdn6jiJb31Vk63uKbH2fyValNxxzIeayiMcVgjlfsVo8rhAiHlfsxmUySTccVwAu7ivibjjm4rzhOFjhDceVAlKuXE3KlUJIuXIMNxwHA0m5EpCUK/fHOhdNPgrAlRjUxUrCVZVW3FHPm1GcrMBwuHIw8HDlKvUbjmaV/vJtXFX64UoNZF+tfsPRrKaA7KtrITv6JDGS7Mhyf436DUezhoLAWbMeONFvOCIDZ636DUezloLAWbseONFvOCIDZ536DUezjoLAWbeuS6KTfb36DUezngKyr19fJaLfcESuEhvUbziaDRQEzobSbzgSKVdlOGm/AnDHaVVg4NAY6MNDH/T9J/kg5251Bp98ALz9gN6pQvvkQwafrMngkw+BPllTuE8+YvDJ2gw++Qjok7WF++RjBp+sy+CTj4E+WVe4Tz5h8Mn6DD75BOiT9YX75FMGn2zI4JNPgT6BF69BQ/sGKaw2En7DsfOCAvpoE/Jm55JAf2ys7IYjzSPitwl0jkeHYZdnOEI0WOENx02C84CbVp8H3CTkPOCmjDccycFLMDjlZeE3H7jI+IqSG47I85+bAJPkpsDkDeSgeUXJDUekLzZjLiCcaM1QgbMxQwznhJ/FJb/kFODm4vhGQI7nwRzvbOhLJIX/bl78t3HECm0U5/tP8otkWz9UZOtHimz9WJGtnyiy9VMmW5XecMyHmMsiHv1gzovV4tEPEY/Fblwmk3TD0Qcu7kXcDcd8nDccp1F4w7EUkHLzalKWQki5eQw3HKcBkrIEJOXm/bHORZOPArDEoC5KwlWVVtxRz5tRnPgMhyunAR6u3KJ+w9Fs0V++jVtKP1ypgexb1W84mq0UkH1rLWRHnyRGkh1Z7m9Tv+FotlEQONvWAyf6DUdk4GxXv+FotlMQONvXAyf6DUdk4OxQv+FodlAQODvWdUl0su9Uv+FodlJA9p3rq0T0G47IVWKX+g1Hs4uCwNlV+g1HIuWWDCftfeCO05bAwKEx0IeHPuv7T/JBzt3WDD75DHj7Ab1ThfbJ5ww+2ZbBJ58DfbKtcJ98weCT7Rl88gXQJ9sL98mXDD7ZkcEnXwJ9sqNwn3zF4JOdGXzyFdAnOwv3ydcMPtmVwSdfA30CL16DhvYNUljtJvyGY+cFBfTRJuTNzo2B/thd2Q1HmkfEbxPoHI8OwxYYjhBNo/CG4x7BecA9q88D7hFyHnBPxhuO5OCNGJzykfCbD1xk/FjJDUfk+c89gElyT2DyBnLQfKzkhiPSF3sxFxBOtGaowNmdIYb3Fn4Wl/yytwLcXBzfDcjxfcAc72zoSyT7/nfz4r+NI1Zoo3if/pP8ItnWzxXZ+oUiW79UZOtXimz9mslWpTccCyHmsojH/YI5379aPO4XIh7378ZlMkk3HPcDLu774244FuK84TitwhuOBwSkPLCalAeEkPLAGG44Tgsk5QFAUh7YH+tcNPkoAA9gUBcHCFdVWnFHPW9GcbIfw+HKaYGHKw+q33A0B/WXb+PB0g9XaiD7IfUbjuYQBWQ/VAvZ0SeJkWRHlvuH1W84msMUBM7h9cCJfsMRGThH1G84miMUBM6R9cCJfsMRGThH1W84mqMUBM7RdV0SnezH1G84mmMUkP3Y+ioR/YYjcpU4rn7D0RynIHCOl37DkUh5MMNJ+/2AO04HAwOHxkAfHvqm7z/JBzl3hzL45Bvg7Qf0ThXaJ98y+ORwBp98C/TJ4cJ9MoHBJ0cy+GQC0CdHCvfJdww+OZrBJ98BfXK0cJ98z+CTYxl88j3QJ8cK98kPDD45nsEnPwB9Ai9eg4b2DVJYnSD8hmPnBQX00Sbkzc7dgf44UdkNR5pHxG8T6ByPDsPuy3CEaFqFNxxPCs4Dnlx9HvCkkPOAJzPecCQH78bglB+E33zgIuOPSm44Is9/ngRMkicDkzeQg+ZHJTcckb44hbmAcKI1QwXOiQwxfKrws7jkl1MV4Obi+AlAjp8G5nhnQ18iOf2/mxf/bRyxQhvFp/Wf5BfJtn6ryNYJimz9TpGt3yuy9QcmW5XecPRDzGURj2cEc35mtXg8I0Q8ntmNy2SSbjieAVzcz8TdcPTjvOE4ROENx7MCUp5dTcqzQkh5dgw3HIcASXkWkJRn98c6F00+CsCzGNTFWcJVlVbcUc+bUZycwXC4cgjwcOU59RuO5pz+8m08V/rhSg1kP69+w9Gcp4Ds52shO/okMZLsyHL/gvoNR3OBgsC5sB440W84IgPnovoNR3ORgsC5uB440W84IgPnkvoNR3OJgsC5tK5LopP9svoNR3OZArKPra8S0W84IleJy+s3HM3lCgLnCuk3HImU5zKctD8DuON0LjBwaAz04aEf+/6TfJBzdz6DT34E3n5A71ShffITg08uZPDJT0CfXCjcJz8z+ORiBp/8DPTJxcJ98guDTy5l8MkvQJ9cKtwnvzL4ZCyDT34F+mSscJ/8xuCTKxh88hvQJ/DiNWho3yCF1TjhNxw7LyigjzYhb3aeCPTHlcpuONI8In6bQOd4dBj2dIYjREMU3nAcH5wHvKr6POD4kPOAVzHecCQHn8DglL5DsQkXjZuLjP2G8iw0/cF2Is9/jgcmyauAyRvIQQPwayw3HJG+uJq5gHCiNUMFzpUMMXyN8LO45JdrFODm4vg4IMevBXO8s6EvkVz3382L/zaOWKGN4mv7T/KLZFt/UmTrz4ps/UWRrb8qsvU3JluV3nAshpjLIh6vD+b8hmrxeH2IeLyhTDx2Nsk3HK8HLu434G44FuO84ThU4Q3HGwNS3lRNyhtDSHlTDDcchwJJeSOQlDf1xzoXTT4KwBsZ1MWNwlWVVtxRz5tRnFzPcLhyKPBw5c31G47m5v7ybbxF+uFKDWS/tX7D0dyqgOy3aSE7+iQxkuzIcv/2+g1Hc7uCwLmjHjjRbzgiA+fO+g1Hc6eCwLmrHjjRbzgiA+fu+g1Hc7eCwLmnrkuik/3e+g1Hc68Cst9XXyWi33BErhL31284mvsVBM4D0m84EilvYThpfz1wx+kWYODQGOjDQ7/3/Sf5IOfuNgaf/A68/YDeqUL75A8Gn9zB4JM/gD65Q7hP/mTwyV0MPvkT6JO7hPtkIoNP7mHwyUSgT+4R7pO/GHxyH4NP/gL65D7hPmnoh/fJAww+aQCqc3jxGjS0b5DC6kHhNxw7LyigjzYhb3ZeCfTHQ8puONI8In6bQOd4dBj2OoYjREMV3nB8ODgP+Ej1ecCHQ84DPsJ4w5EcPI7BKYOF33zgIuM0Sm44Is9/PgxMko8AkzeQg2YaJTcckb54lLmAcKI1QwXOQwwx/Jjws7jkl8cU4Obi+INAjj8O5nhnQ18ieeK/mxf/bRyxQhvFj/ef5BfJtv6hyNY/Fdk6UZGtfymylTZoOGxVesOxFGIui3h8Mpjzp6rF45Mh4vGpblwmk3TD8Ung4v4U7oZjKc4bjsMU3nB8OiDlM9WkfDqElM/EcMNxGJCUTwNJ+Ux/rHPR5KMAfJpBXTwtXFVpxR31vBnFyZMMhyuHAV/fPFu/4Wie7S/fxuekH67UQPbn6zcczfMKyP6CFrKjTxIjyY4s91+s33A0LyoInJfqgRP9hiMycF6u33A0LysInFfqgRP9hiMycF6t33A0ryoInNfquiQ62V+v33A0rysg+xv1VSL6DUfkKvFm/YajeVNB4Lwl/YYjkfI5hpP2TwJ3nJ4DBg6NgT48NFWQfJBz9wKDT6YCrtzonSq0T/ow+OQlBp/0AfrkJeE+6cvgk1cYfNIX6JNXhPukH4NPXmPwST+gT14T7pP+DD55g8En/YE+eUO4TxoZfPIWg08agT6BF69BQ/sGKazeFn7DsfOCAvpoE/Jm50NAf7yj7IYjzSPitwl0jkeHYZ9gOEI0DHdINbbzgO8G5wHfqz4P+G7IecD3ys4Dop1MDkYGTKeT0YdokecV3wUG9Xv9eciHXliQmN9nXlicaM3QwvcOQ6L5QPgZTfLLBwpxIzat3u6Pn8+p+snG3YcJdx/huPsy4e4rHHc/Jtz9hOPuz4S7v3DcjUy4G8G4Oxsaf6Gf7DqDxlu9H77WnQpo47i+uLHGDMEK2GENk+aOgz/kmyv64v1+RV+e+GmA2unyjW3+4Winz4YH339oc9VHtn9s+ye2f2r7Z7Z/bvsXtn9p+1e2f237N7Z/a/sE27+z/Xvbf7D9R9t/sv1n23+x/Vfbf7P9d9v/sP1P2yfa/hcJ50b779vex/a+jQ2VopmMGVD17KOQZx+HPPsk5NmnIc8+C3n2ecizL0KefRny7KuQZ1+HPPsm5Nm3Ic8mhDz7LuTZ9yHPfgh59mPIs59Cnv0c8uyXkGe/hjz7LeTZ7yHP/gh59mfIs4khz/4KeUZkqn42VcizPiHP+gbPylu/4OtiwdcoR24o5D7ujxjrn/D9JPpY/26mfArcWJiL6eOhIL5I/mun+SwaZqcMs/k8ylhuxfyZL4C+mFumL5wqO82XvcScLk2G2XzVu7G8kPkzXwN9MY80X3ihdppveo45UwOz+banY2Vqzp+ZAPTFSDm+cKdgp/muJ5gzU8Rsvu/+WIUu5s/8APTFKAm+yHRpp/mxe5idbmA2P3VnLKdb82d+Bvpi9P+vL1LdtNP80hXmZLcxm1+nOFay1IP5M78BfTHv/5cvMj2y0/xeG7PXQ8zmjxpjZUs9nj/zJ9AX88XvC6cXdpqJYZidXmE2f00+lunl/BnSZShfzB+nL/xe22mmqsSciIDZ9Ckbyy1Fmj/TF+iLBZh8MXWVL5xorWKzLyrmDyEa/u/PNjIfAV/CL4zb2DVADW+AGtQANZQBagADrGENsAYzwBrCANdAA8zhBpmDaA2wYfTvy4byBn9R3YjKI74pt7dfI6PBNDjqVFOn8f0agW+DgYsb1xySjdj7pn4Fbidii/NjIPvC7PZZ35SVz0VjEGBN1W+rGhsnP/bZFPJWAX1WGpdJHNMIDKAmJueij1UiMQ8AJrOGBnzA0et0Shbo4w6rA+95IJN4s3B/EF+agQsCA+5Yq6I+sFyW9cvtbWlkNLgFXhVl/RYgcVuFV0U0h63wqijrtwKDgAM3Jc1m4cm4GcidNnAy7mzoggAZL+1AzHFW5n1gdmcLIeayVOZTB0l+YHVlPnVIZT4whsoct5o5ZmogKQcyORcdiEjMHcIrQUqO7QyV4CDhiyD5ZZAC3FwcRy7Wg4VzvDnwNbrgQRYpg4BjTQNe/ONSYVPB1q18otzeaRsZDZ4WrsLyiWmBDhwiXIXRHA6Bq7B8YojwBYiS5jQMC9BQJQsQkpfDlKqdqWB2590Qc1nUznRBMp2+Wu1MF6J2po9B7eBWDcdMByTl9EzORQciEvMMwitBSo7DGJLujMIXG/LLjApwc3F8RiDHZ2LmOEKVhKkdJ1ozyHdaSLUzM3PsIfgyc6NsTs+iVDE2wNZ+r1Ru76yNjAbPCleMXmlWoAOHC1eMNIfD4YrRKw1XoBhnYVjERyhZxJG8nE2pYmyA2e0VQ8xlUYyzB8l0jmrFOHuIYpwjBsWIWzUcMzuQlHMwORcdiEjMcwpXjJQcZ2NIunMJX2zIL3MpwM3F8bmAHJ9bOMdrKRQnWjNIhTKPcJVHPp6nUTYPRypVeX/B7r65Trm9oxoZDR4FV3muMwrowNHCVR7N4Wi4ynOd0QpU3kiGhXdeJQsvkpfzKVV5f8Eu6JpSiLksKm/+IJkuUK3y5g9ReQvEoPL+At6Ynh9IygUaeZyLDkQkZkd4BUzJcT6GpGuELzbkF6MANxfHDZDjrnCO11IoTrRmkAolIVzlkY8TjbJ5mFSq8ibC1mu/QuWlGhkNTsFVnu+kgA5MC1d5NIdpuMrznbQClZdkWHgzShZeJC89pSpvIkzlFWJTedkgmS5YrfKyISpvwRhU3kSgyssCSblgI49z0YGIxLyQ8AqYkqPHkHQXFr7YkF8WVoCbi+MLAzm+iHCO11IoTrRmkApljHCVRz4e0yibh4sqVXl/wtbrdMXnzy3WyGkwXOWlzWJABy4uXOXRHC4OV3npCtxOxMaBm1TeogwL7xJKFl4kL5dUqvL+hKm8dGyfNbhUkEyXrlZ5S4WovKVjUHl/AlXeUkBSLt3I41x0ICIxLyO8AqbkuCRD0l1W+GJDfllWAW4uji8L5PhywjleS6E40ZpBKpTlhas88vHyjbJ5uIJSlfcH7l2eV27vio2MBq+If5fnrQh04ErCVR7N4Ur4d3neSgpU3goMC+/KShZeJC9XUary/oCpPD8TYi6Lyls1SKarVau8VUNU3moxqLw/gCpvVSApV2vkcS46EJGYVxdeAVNyXIUh6a4hfLEhv6yhADcXx9cAcnxN4RyvpVCcaM0gFcpawlUe+XitRtk8XFupyvsdtl4ns+X2rtPIaPA6cJWXzK4DdOC6wlUezeG6cJWXzK6rQOWtzbDwrqdk4UXycn2lKu93mMpLeiHmsqi8DYJkumG1ytsgROVtGIPK+x2o8jYAknLDRh7nogMRiXkj4RUwJcf1GZLuxsIXG/LLxgpwc3F8YyDHNxHO8VoKxYnWDFKhbCpc5ZGPN22UzcPNlKq832Drdb7ixGaukdHgHFzl5U0O6MC8cJVHc5iHq7x8BW4nYuPATSpvM4aFt6Bk4UXy0leq8n6Dqbx8bCc2i0EyLVWrvGKIyivFoPJ+A6q8IpCUpUYe56IDEYl5c+EVMCVHnyHpbiF8sSG/bKEANxfHtwByfEvhHK+lUJxozSAVylbCVR75eKtG2TzcWqnK+xWn8grl9m7TyGjwNniVV9gG6MBthas8msNt8SqvsK0Clbc1w8K7nZKFF8nL7ZWqvF9xKi8fYi6LytshSKY7Vqu8HUJU3o4xqLxfgSpvByApd2zkcS46EJGYdxJeAVNy3J4h6e4sfLEhv+ysADcXx3cGcnwX4RyvpVCcaM0gFcquwlUe+XjXRtk83E2pyvsFd2IzX27v7o2MBu+OP7GZ3x3owD2Eqzyawz3wJzbzeyhQebsxLLx7Kll4kbzcS6nK+wV3YjMXYi6Lyts7SKb7VKu8vUNU3j4xqLxfgCpvbyAp92nkcS46EJGY9xVeAVNy3Ish6e4nfLEhv+ynADcXx/cDcnx/4RyvpVCcaM0gFcoBwlUe+fiARtk8PFCpyvsZtl57Fb9J4aBGRoMPgqs8zzkI6MCDhas8msOD4SrPcw5WoPIOZFh4D1Gy8CJ5eahSlfczTOVlSiHmsqi8w4Jkeni1yjssROUdHoPK+xmo8g4DkvLwRh7nogMRifkI4RUwJcdDGZLukcIXG/LLkQpwc3H8SCDHjxLO8VoKxYnWDFKhHC1c5ZGPj26UzcNjlKq8n5hU3rGNjAYfy6DyjgU68DjhKo/m8DgGlXecApV3DMPCe7yShRfJyxOUqryfFKq8E4NkelK1yjsxROWdFIPK+wmo8k4EkvIkJSoPiflk4RUwJccTGJLuKcIXG/LLKQpwc3H8FCDHTxXO8VoKxYnWDFKhnCZc5ZGPT2uUzcPTlaq8H2Hrda7iMzbPaGQ0+Ay4ystlzwA68EzhKo/m8Ey4ystlz1Sg8k5nWHjPUrLwInl5tlKV9yNM5eVi+4zNc4Jkem61yjsnROWdG4PK+xGo8s4BkvLcRh7nogMRifk84RUwJcezGZLu+cIXG/LL+Qpwc3H8fCDHLxDO8VoKxYnWDFKhXChc5ZGPL2yUzcOLlKq8H3AqL1lu78WNjAZfjFd5yYuBDrxEuMqjObwEr/KSlyhQeRcxLLyXKll4kby8TKnK+wGn8hIh5rKovLFBMr28WuWNDVF5l8eg8n4AqryxQFJe3sjjXHQgIjFfIbwCpuR4GUPSHSd8sSG/jFOAm4vj44Acv1I4x2spFCdaM0iFMl64yiMfj2+UzcOrlKq873G/Fb3iXd7VjYwGXw1XeX72aqADrxGu8mgOr4GrPD97jQKVdxXDwnutkoUXycvrlKq873G/FT22d3nXB8n0hmqVd32IyrshBpX3PVDlXQ8k5Q2NPM5FByIS843CK2BKjtcxJN2bhC825JebFODm4vhNQI7fLJzjtRSKE60ZpEK5RbjKIx/f0iibh7cqVXnfwdbrQrHc3tsaGQ2+Da7yCsXbgA68XbjKozm8Ha7yCsXbFai8WxkW3juULLxIXt6pVOV9B1N5BT/EXBaVd1eQTO+uVnl3hai8u2NQed8BVd5dQFLe3cjjXHQgIjHfI7wCpuR4J0PSvVf4YkN+uVcBbi6O3wvk+H3COV5LoTjRmkEqlPuFqzzy8f2Nsnn4gFKVNwG2XpuKd3kPNjIa/CBc5Znsg0AHPiRc5dEcPgRXeSb7kAKV9wDDwvuwkoUXyctHlKq8CTCVZ2J7l/dokEwfq1Z5j4aovMdiUHkTgCrvUSApH2vkcS46EJGYHxdeAVNyfIQh6T4hfLEhvzyhADcXx58AcvxJ4RyvpVCcaM0gFcpTwlUe+fipRtk8fFqpyvsW91vRK1TeM42MBj8DV3n57DNABz4rXOXRHD4LV3n57LMKVN7TDAvvc0oWXiQvn1eq8r7F/Vb02FTeC0EyfbFa5b0QovJejEHlfQtUeS8ASfliI49z0YGIxPyS8AqYkuPzDEn3ZeGLDfnlZQW4uTj+MpDjrwjneC2F4kRrBqlQXhWu8sjHrzbK5uFrSlXeN7jfpOCV2/t6I6PBr8NVnue9DnTgG8JVHs3hG3CV53lvKFB5rzEsvG8qWXiRvHxLqcr7BqbyvEyIuSwq7+0gmb5TrfLeDlF578Sg8r4Bqry3gaR8p5HHuehARGJ+V3gFTMnxLYak+57wxYb88p4C3Fwcfw/I8feFc7yWQnGiNYNUKB8IV3nk4w8aZfPwQ6Uq72vYep2sUHkfNTIa/BFc5SW9j4AO/Fi4yqM5/Biu8pLexwpU3ocMC+8nShZeJC8/VaryvoapvGRsKu+zIJl+Xq3yPgtReZ/HoPK+Bqq8z4Ck/LyRx7noQERi/kJ4BUzJ8VOGpPul8MWG/PKlAtxcHP8SyPGvhHO8lkJxojWDVChfC1d55OOvG2Xz8BulKu8r2HqdNeX2ftvIaPC3cJWXNd8CHThBuMqjOZwAV3nZCtxOxMaBm1TeNwwL73dKFl4kL79XqvK+gqm8rBNiLovK+yFIpj9Wq7wfQlTejzGovK+AKu8HICl/bORxLjoQkZh/El4BU3L8niHp/ix8sSG//KwANxfHfwZy/BfhHK+lUJxozSAVyq/CVR75+NdG2Tz8TanK+xK2Xmeccnt/b2Q0+He4yss4vwMd+IdwlUdz+Adc5WWcPxSovN8YFt4/lSy8SF5OVKryvoSpvHQpxFwWlfdXZzJtaqhUdH+FqDz6IW6V9yVQ5f2FTJZNPM5FByIS81RNOL82NOADjpLjRIak26dJ9mJDfiEbpePm4ni5nVHH6iuc47UUihOtGaRC6cccLwgfk42Sedi/CVv0xKXyvsB9+krFb1JobGI0uLEJrfLyxUagA5uAxOKaw6YmtMrLF5uEL7yk8vozLLwDlCy8SF42gxNeXCrvC9ynr8T2mxRagmTaWq3yWpomV3mtMai8L4AqrwVIytYmHueiAxGJuU14BUzJsZkh6bYLX2zIL+0KcHNxvB3I8amFc7yWQnGiNYNUKAOFqzzy8cAm2TzsUKryPoet127Fu7xBTYwGD4KrPNcZBHTgYOEqj+ZwMFzluc5gBSqvg2HhnUbJwovk5bRKVd7nuN+kENu7vCFBMh1arfKGhKi8oTGovM+BKm8IkJRDm3iciw5EJOZhwitgSo7TMiTd6YQvNuSX6RTg5uL4dECOTy+c47UUihOtGaRCmUG4yiMfz9Akm4czKlV5n+HW60K5vTM1MRo8E1zlOYWZgA6cWbjKozmcGa7ynMLMClTejAwL7yxKFl4kL2dVqvI+g6k8Jx9iLovKGx4k0xHVKm94iMobEYPKA64aZjiQlCOaeJyLDkQk5tmEV8CUHGdlSLqzC19syC+zK8DNxfHZgRyfQzjHaykUJ1ozSIUyp3CVRz6es0k2D+dSqvI+ha3X6YoTm3M3MRo8N1zlpYtzAx04j3CVR3M4D1zlpYvzKFB5czEsvCOVLLxIXo5SqvI+xd3Li+3E5uggmc5brfJGh6i8eWNQeZ8CVd5oICnnbeJxLjoQkZjnE14BU3IcxZB05xe+2JBf5leAm4vj8wM5voBwjtdSKE60ZpAKxRGu8sjHTpNsHhqlKu8T2HptKj5j021iNNiFqzxjXKADE8JVHs1hAq7yTAVuJ2LjwE0qzzAsvEklCy+SlymlKu8T3InN2D5jMx0k00y1ykuHqLxMDCrvE6DKSwNJmcGd2GQNRCRmT3gFTMkxxZB0s8IXG/JLVgFuLo5ngRxfUDjHaykUJ1ozSIWykHCVRz5eqEk2DxdWqvI+xh1gqriXt0gTo8GLNOHHHSNcmRHuMU2TJhg0LpuaWphhgVtUyQKH5NJizAscxCcx8fJ/YSFZXOlC8hHTQrJEE6PBSzAsJEsKX0gI95KKFpLFGRaSpZQsJEguLS18ISGfLF1fSGBjLaN0IfmwP24Oyu1dtonR4GUZyLAs0IHLCV+UaA6XY0j0yyl477QMA+7llSxwSF6uIHwrkHyyAoOvVxTOcYrtFZkWdi5ergjk5UrCeVmrmHGiNYMsZlYWznHy8coMc4jk4SoK1sJVGPLjYKbfgDM1GP8oIOYPga/hPwIW5KsCc+FcQ3FjzQ0cax7gWCOBY40CjjUaONa8wLHmA441P3CsBXBjOXGKcWC8Vojx1ZoYDV6NYVd3deECmnCvzlBkE9lo2D4N/GQb1cCzUA8H2/kh6lWHcRzQaxND/wd5l2/++QI4DGk6v4l8fc5M+jbiB66Y8j9E+ohOU/nHCL/UwVQ/6PWvATSTP+rlL443YQ+/7s1YJvzxNz0fy9T6i297Opap/VcTejaWmdJffteTscyU//r77o/VxUiO80N3x+pyJMf5sXtjdWMkx/mpO2N1ayTH+bnrsbo5kuP80tVY3R7JcX6d8lg9GMlxfpvSWD0ayXF+rz1WD0dynD9qjdXjkRznz/CxejGS40wMG6tXIznOX5OP1cuRbK1SvUHR65FskV05VoSRHKdP+ViRRnKcvsBNmHIhsQbV+ugdIyqkBzfy7HAhJ6HzYscaZYKHY/dsdYadzcHAXx+5JlClkuAZ0BCuroeD56AuJHoyUl1I9GykupDo2Uh1IdGzkepComcj1YWE08NWFxI9a3Uh0UO7Gia1tYLN87XDBIUTrRkqUNdQcuaa7FyT4TX8OsKPHxAB1mHAvS74FVqn6KNxDwjGRc/F2kxzsR7TXKw3hbmIajMXL9YfyhsPXdhX6MI+Ng5sAMY9HMx9EuWwXBUIc9B4/4pzyHhlAh0wXoVIjzxelVCPON5kYj3SeCGCPcJ4oaK91+PVEO69HK+meO/VeFMQ8L0Yb4oivsfjdSHkezhel2K+R+N1Q9D3YLxuifpuj9dNYd/N8bot7rs1Xg8EfjfG65HI73K8Hgr9Lsbrsdif4ni9EPxTGK9Xor/meL0U/jXG67X4Dx0vwgZAyHiRNgEmGy/iRkDVeJE3AyrGA2wIrMPwggpYn5sNwMc/mxvCT+Q19HAOutIA5WNy6G3UnJS/rFu/TLPAjV4HbHSngF1/Cm9wuximy/Ahm9dnEHJbgYVcZ+vXQ5/1ZOMpsnhtkplgkL4o5+UGZRsrvfVPV3OO9M+GZWOZRMLGhp8xJb+USGWybt6kE+l0KVnKpL2kX0olc36maJK5hJstZpyS8YrFTCpRyKRLWb+QLpUnbeMnEkk/my+YlJvO5R3PT+ScUjKTcJ2cn8j4fsJLp3OJhJ/2Sl7Wc91cKeE5qUwm66TdRNbl8s+GgX+mdGpB8jHt8kVso2CDfGMtCZzLvo0YkvUmTAvXJoy70DQXGzPMxaZMc7Ep4y40Fy+2Eb4LzcWBbYfKzgOUZDlUDdDfZtu6qqluZiMmVbOZRlWzGbOq2YwhMWz3P6hqck0yE8x2TFVzTpmqyQNVzbZAVcPln3yZqqm1KEjejuK0k2uBKWhcYArMC0yBYYHZnmmB6Q+2E5nAfOBYyG0z5GK1PVMy9LuxWEWd02ITblGo2DYTtFhx+af4H9qCKwVbcJtz3KqrdbDUidbMmuCVmwt3H0bcUW3cQvi2KBFzC4bFeEumwmRLxm3RzZnmYiumudiKcVuUixc7Cd8W5eLAzgq2RbdgyKVAf5ud69ui1e3v/I2ak/ICa2tO1boFU0LcmlG1ks1bMySGXZRsi24BLIq2aZKZYHZhUjLbxLAtivTPtsBt0Z2BSpPLP9t2Q2kO76G/umj1j6jo0Uj1j6jo2Uj1j6jo2Uj1j6jo2Uj1j6jo2Uj1j6hwetjqH1HRs1b/iIoe2tUwqW0X7M5vr0X0ctm3HYPA3YFJ7O/AuBNMc7E9w1zsyDQXOzLuBHPx4lThO8FcHDhNwcc0wHJVIE5B4/0rUCHjlYlUwHgVQjXyeFViNeJ4kwnWSOOFiNYI44UK116PV0O89nK8mgK2V+NNQcT2YrwpCtkej9eFmO3heF0K2h6N1w1R24PxuiVsuz1eN8VtN8frtsDt1ng9ELndGK9HQrfL8XoodrsYr8eCd4rj9UL0TmG8XgnfmuP1UvzWGK/XAjh0vAgiOGS8SEJ4svEiiuGq8SIL4orxAKKY4809sD43p9Xf3Fc3sx3Tm/udNL6534n5zf1ODELusv/BN/c7N8lMMJcxvRneWdmb+12Ab+5PA7655/LPLv8PF5qQR6447eRaYHbVuMDsyrzA7MqwwIxVcqEJmcB2A46FPBqGXKzGMiXD3WK40LQ78ELTzkNlLlZc/tm9zD8jwH6h89vA34L191sA2HjBWwDQeP++BYCMV/YWADBexVuAyONVvQWION5kbwEijRfyFiDCeKFvAXo9Xo23AL0cr+ZbgF6NN4W3AL0Yb4pvAXo8XhdvAXo4XpdvAXo0XjfeAvRgvG69Bej2eN18C9DN8br9FqBb4/XgLUA3xuvRW4Aux+vhW4AuxuvxW4ApjteLtwBTGK9XbwFqjtfLtwA1xuv1W4DQ8SK8BQgZL9JbgMHgI3GDwcfiBoOPxtF4na0GD3vcGsoaWt/uAdxMJNsGN0zSO/RnGn9i8P3YvpO+v7zs+8HB953/3Z72v9nL9r1t36dp0vPO1hc7v8btixtrT6B23he8D1Ptm33LfLNX2fd7l32/T1Olb/azf96fNJTtBwa+6crv+5V9f0WZ30dX+f0g+3MH236I7YcGY1Mf0hDPB09c2Te674qlv1ux3N7DmhgNPizktWNU4w8DJoXDgQHBNYeHAzcOO+fw8CYdC8ARODuTYYngiLLgH1cW/Ac11U4ER9q/O8r2o20/pqlyPKTvabFG+r5zTo8VfsycOH8sA+ePVcL543B2JsI4f1wZt8eXcf7IKXD+ePt3J9h+ou0nTYHziF95f3iT7F95fzJz/ES1r8P6bra+kxeiEeOn1AEsRGfri8P7mvAPTmm3WGnuUHVQJ+5TgHUQcA4THHNI8XsKxxUTppfJNO7wYFwtfDpNJp9cGgO9HlB9B8zjhmqL4xn4eTqQn0rFaqnc3jM4xeoZeLFaOgNIsjMViNUz8YV76UzhgoUWp9MZgv8s5h22WuL3rCkIgbPt351j+7m2n8csfs9kmNPzFYjf8xli6HxmLtUSlWdPgUsX2L+70PaLbL+YWVSeKVxUXgJe6Fsa4lnox+JEodNeZuelwUJ/WfB1bPD18uDrFcHXccHXK4Ov44OvVwVfrw6+XhN8vTb4eh3nEVXgMasKVTE2MLr82biQZ1eFPLu2aXJCoAPtehiJE0lOO2/ovZ1+9YOwZHh9WdK7tOz7y8q+v6Hq1dWN9s832X6z7bfE8FpxLLAwvRFYmN7KtEuLnr/LgfN3E3D+blMyf1cA5+9m4Pzdzlwo3VqWA24r+/72su9vqcoNd9g/32n7XbbfHUNuGAf0zR1A39yjhNtXAufvTuD83atk/sYD5+8u4Pzdx5wb7inLAfeWfX9f2fd3V+WG++2fH7D9QdsfiiE3XAX0zf1A3zyshNtXA+fvAeD8PaJk/q4Bzt+DwPl7lDk3PFyWAx4p+/7Rsu8fqsoNj9k/P277E7Y/GUNuuBbom8eAvnmK2TdPlfng8bLvnyj7/skq3zxt//yM7c/a/lyIb9Ca93ncHJTC5uD5MqxPl31/3RQ2AF+wf/ei7S/Z/nLTpCOVcf0urxeAvOhTZucrwSbTq1o2mbjse4VhB/81cDB3bpDRuAcw+upVhrl4nWkuXm/i+7RQLl68JfzTQrk48Lbw40+E+wWGty9Af5u3658+Vd3MK+Dc0tne0PjmpdzoHtrc5bUtsvkNhsTwjpJPn0K+Rn2zSWaCeYfpAyPebOL/9Cmkf94q80/UD/R4G/iBHlz+eSvwD30/oGGS4u6Jf7poZuKUx3MLJZNI2Zlz0rlkyk8nXN/NOH4yVTLWaW42aV1WKiQ933MTJTfjFjrV2ur9/vnauZDR96+UqblXg+/ftl/fsf3dpoaKhjp/3skd5Bu3t4G7C+81YYuHuM5ovse0wL/fxGjw+034cT8AkoEL9wdlwQUad4rbtFHnAfl69x2gfz5UGqwfMgXrR02MBn/EEKwfCw9Wwv1xzMHqRGsVq6ETrUGT6Sfgd1IcavMDhq0NqrxQc/ipgjkcJ3wOPwMn3+ZgHj8pq6bfKfv+06ZJ5zcvL3t+Rdn3nwU/87n9+oXtXwY5h8M/7wr3z1dM/nm7hn++KvNPVz/ztf36je3fMvnng2C9Qe8eTVCQNyYw4P6OGTfi9cmEJtmXGb4HzyEaK+VMoI2GYvw7Bi7+oCAG32XA/aOCGOTA/ROQkxxxQ2v2501Y/vzAMI8/K6l50bh/URA3HLh/FR43VMMDc5qhPPEzwzz+JnzdplobyHFDvPmNYR5/VxCHvzPUkMDLoMYbgtV01ecVa93LGzuF84p/2L/7k/7e9r+aev4RkFH99kcZr9xcyi8mM0U/4Tg5+94un7Hv93I5k8ykXfs6z77nTBVKBZMu+J4x6WI+nXeyeafkppOJQs7NZyvsHcBoMA1eTbSoxtOYKKJNNYB3Qxkxh2TjVOA5nAo3h3+/CWltiOeXK/0BTq7VDTknna1PEGB9g6/9gq/9ya9owpBjKcNrOVvVb8Ck3bTqLE0T15mN+5Z9329A7SzdaP+uyfYBtjcP4P1YiakGyN6JaRnAW9EhkhvQRkO+b+lczRp4sTvR2t9q+jSwmub4jLxW4Ryiz8JDvk2g8Wgu0W9Zy210ojVojmgbwLOgonnYDrMzkeKIZ/rYLODH+Bj6yKYLGOJ5arC/0XVG/yCHo3EPHICtX6prlfaymmTqsu8HTqFW6bB/N4jqNdunGcD7cWqtwmuVacH+6awvadzhwZy3NVSewW1gmu8O4TFGn306NVOdxDWnrQzrlIqLKETcoQ3xqGtEMRB85CCHuv73Mk35XAwJiDy0895wZ+QPKVOWnc+GBtmgvKErvbboW0pu5xWvIcDtqaFg53Io6iFMWQltK6mEefviV9R5gZ+MP2yA/DlE/qaC8nFR/kD+poLpgDsdNGcjaJxgPPI1jT9TX529s4EXtATllDYGNTE9MLb6NEz6dc/lDTU+09ya6QfIt3EGtI0cEqpjAHYRnYFB6s0AtHFGPcFj/peDZ0a0jVzZXfK+xkz1lcLMpIDsMwsn+7+bePBjxv+/n5zTrRWNnIOW6TMDV7RZgKU90h9aV0cNCWOW/9HV0UWujrPWV0czqwKyD5e+Ona+0kCvPiOEH3+gYAQ65+8qYwRDST0cuNrOVtePKpIG0k8NarVPX/k2zl53lGP2aJJv4xxMh7Xgy+acOENdrYSaU0GKnqse+Y45TkHkz113lGOOUOCoebSk6JE4Q1NaCTVSQYoepYVQo3GGprUSarQCQs1bX0ocYxTIsvm0RP78OEM9rYSaX0HkL6CFUA7O0KxWQjkKCGW0EMrFGZrTSihXAaESWgiVxBma10qopAJCpbQQKo0ztKCVUGkFhMpoIZSHM9TXSihPAaGyWgi1IM7QolZCLaiAUAvV93cc87yCVwULa4n8RWCGGrWn9BZREPljtBBqURyhjFZCLaqAUItpIdTiOEKpPW+yuAJCLaGFUEviCJXQSqglFRBqKS2EWhpHqKRWQi2tgFDLaCHUsjhCqT2/s6wCQi2nhVDL4wil9vzO8goItYIWQq2II1RGK6FWVEColbQQamUcodSeM1pZAaFW0UKoVXGEUnvOaFUFhFpNC6FWxxFK7Tmj1RUQag0thFoTRyi154zWVECotbQQam0codSeM1pbAaHW0UKodXGEUnvOaF0FhFpPC6HWxxFK7Tmj9RUQagMthNoQR6iSVkJtqIBQG2kh1MYwQ12156E2VkCoTbQQalMcodSeh9pUAaE200KoHI5Qas9D5RQQKq+FUAUcodSehyooIJSvhVBFHKHUnocqKiBUSQuhNscRSu15qM0VEGoLLYTaEkcoteehtlRAqK20EGprHKHUnofaWgGhttFCqG1xhFJ7HmpbBYTaTguhtscRSu15qO0VEGoHLYTaEUcoteehdlRAqJ20EGpnHKHUnofaWQGhdql/CIVjGhR8yOiudUc5ZpACR+2mJUXvjkvRas/v7K4gRe9Rj3zHjFIQ+XvGFflOtGaa+uGyiB2qoT3EVmp7DQgeDLa9X9kP0Kd6Twy+H9kw6fuZyp7PHHzf+d/tbQfbx/Z9bd9vwD/PqQ+p+ke5Jm1voHfL7d1/AKPB/w7egPN4mEPplzKFOZQY0Pn94CqHHmD/7kDbD7L94AGTnnc29C+SBTrQHDAAN5+HgIlV7ZtDynxwYNn3B5V9f/CASt8cav98mO2H235E4Juu/H5o2XijyjgwusrvR9qfO8r2o20/piyQp7a9f8PkTXIgh5gL9WVf5rkY2SB/Wd1LQY02qoGHU2g7jwTPZR+wfav3++eXp6PGo7HoV6Wi57H8dys7EVsDp8M7JxQtHn8ZyjMB/RgdFRXzsUBiAn97vAH6wnQuOvSV8A4PfDKsYfLFiIOvOhZnl29sM0kd0NfhwffH2Xk53vYTbD/R9pNsP9n2U2w/1fbTbD/d9jNsP9P2s2w/2/ZzbD/X9vNsP9/2C2y/0PaLbL/Y9ktsv9T2y2wfa/vltl9h+zjbr7R9vO1Xdcq4TmKQMdXPjg95dkLIsxNDnp0U8uzkkGenhDw7NeTZaSHPTg95dkbIszNDnp0V8uzskGfnhDw7N+TZeSHPzg95dkHIswtDnl0U8uzikGeXhDy7NOTZZSHPxoY8uzzk2RUhz8aFPLsy5Nn4kGdXBc/K24jg62LBVydaq0g6UReJ4wBjFUvUHHM8aCzCeAJkrH/m68ToY7nBfJmToo6V/HfuzcnRxnLK/GhOiTKWW8EJc2rvx3Kq+GVO6+VY6dJkXDWn924sL4T35ozejOWFxpA5s+djZWrEozmrp2Nlasa2ObtnY7lTyBPmnJ6MlZlizjHndn+sQhf5y5zX3bEyXeZCc373xnK6kVfNBd0Zy+lWjjYXdj1Wqpv53lzU1VjJbq8d5uIpjpUs9WAdMpdMaaxMj9Y0c2ntsbwero/mshpjZUs9XmvN2PCxnF6s2+bysLGcXtUA5orJxzK9rCfMuOqx/F7XJubKyrESEeocM75sLLcUqWYyVw3Aib44XwldBav1fFNu79UDGA2mwau37aIafzXOgeYaYDHONYdkI2pHrXMOrwEHgd0U+tfPcQWBE6n5rLsq5XNxbRBg11WrzWsDx5Y/uy5EgaLfTeIyiWOuBQbQdWDnoslHQXMtMBg7cV+rdEUaD+NR1i+39/oBjAZfD1+Rsv71wBXpBuErEs3hDfAVKevfoHRFGg+zO1sIMZdlRboxCLCbqlekG0NWpJtiWJHGA1ekG4EBdBOTc1EJqNNOJOabgcmsoQG/Wl4TJCD0aQCkFLgFmMzC5tCJ1gz5+BaGSuYWpZXMlbD8k0+U23vrAEaDb4VXMvnErcDgv014JUNzeBu8ksknbmMOfkQCvUV4Ar0dPIedDb3wIjl+BzD24qyAr4TZnXdDzGWpgO8MEvNd1RXwnSEV8F0xVMC4FcgxdwJJeReTc9GBiMR8N3MF7ERrhpLjHQzV2z3Cq1byyz0KcHNx/B4gx+8VzvFaRQqi+EGNdR94wY5L7YyDrTVeqdze+wcwGnw/XO14pfuBDnxAuNqhOXwArna80gPC1Q4luvsGyE7GD4KTcWdDY0Zy/CGlamcczG6vGGIui9p5OEjMj1SrnYdD1M4jMagd3ArkmIeBpHyEybnoQERiflR4JUjJ8SGGqv8x4WqH/PKYAtxcHH8MyPHHhXO8VpHiRGsGWaQ8ofTdzhWwtcat+CiNJwcwGvwkXO24zpPAIHhKuNqhOXwKrnZc5ynhaocS3RMDZCfjp5WoHSTHn1Gqdq6A2W1KIeayqJ1ng8T8XLXaeTZE7TwXg9rBrUCOeRZIyueYnIsORCTm54VXgpQcn2Go+l8QrnbILy8owM3F8ReAHH9ROMdrFSlOtGaQRcpLStXO5bC1xq9QOy8PYDT4Zbja8Z2XgUHwinC1Q3P4Clzt+M4rwtUOJbqXBshOxq8qUTtIjr+mVO1cDrO7EJvaeT1IzG9Uq53XQ9TOGzGoHdwK5JjXgaR8g8m56EBEYn5TeCVIyfE1hqr/LeFqh/zylgLcXBx/C8jxt4VzvFaR4kRrBlmkvKNU7YyFrTXpis/EeHcAo8HvwtVO2rwLDIL3hKsdmsP34GonXYHbidjCcCMS3TsDZCfj95WoHSTHP1CqdsbC7E7H9lkqHwaJ+aNqtfNhiNr5KAa1g1uBHPMhkJQfMTkXHYhIzB8LrwQpOX7AUPV/IlztkF8+UYCbi+OfADn+qXCO1ypSnGjNIIuUz5Sqnctw73a8cns/H8Bo8Of4dzve58Ag+EK42qE5/AL/bsf7QrjaoUT32QDZyfhLJWoHyfGvlKqdy2B2+5kQc1nUztdBYv6mWu18HaJ2volB7eBWIMd8DSTlN0zORQciEvO3witBSo5fMVT9E4SrHfLLBAW4uTg+Acjx74RzvFaR4kRrBlmkfK9U7VwKW2uS2XJ7fxjAaPAPcLWTzP4ADIIfhasdmsMf4Wonmf1RuNqhRPf9ANnJ+CclagfJ8Z+Vqp1LYXYnvRBzWdTOL0Fi/rVa7fwSonZ+jUHt4FYgx/wCJOWvTM5FByIS82/CK0FKjj8zVP2/C1c75JffFeDm4vjvQI7/IZzjtYoUJ1ozyCLlT6Vq5xLYWpOvOMk2cQCjwRPhaidvJgKD4C/haofm8C+42slX4HYitjDciET35wDZybihWYfaQXJ8KiDmONXOJTC+52M7ydan+Z+vfZsbKpUN/UW12qEf4lY7uBXIMX2acaTs28zjXHQgIjH3AycfdMBRcpyqGb8w9G/mXbicaM2QX/orwM3F8f5AjjcK53itIsWJ1gyySGkC8iZOtXMxTu0Uyu0d0MxoMA0OVjuFAcAgaAYGJ9ccNjfD1U6hmXnRQCS6pmbZybhFidpBcrxVqdq5GKd28iHmsqidtiAxt1ernbYQtdMeg9q5GKh22oCkbG/mcS46EJGYpxZeCVJybGWo+gcKVzvkl4EKcHNxfCCQ4x3COV6rSHGiNYMsUgYpVTsX4U6y5cvtHdzMaPBguNpJ5gcDg2Aa4WqH5nAauNpJ5qcRrnYo0Q1qlp2Mp1WidpAcH6JU7VyEO+yUCzGXRe0MDRLzsGq1MzRE7QyLQe1cBFQ7Q4GkHNbM41x0ICIxTye8EqTkOISh6p9euNohv0yvADcXx6cHcnwG4RyvVaQ40ZpBFikzKlU7F8LWGq/iE6hnamY0eCa42vGcmYBBMLNwtUNzODNc7XjOzMLVDiW6GZtlJ+NZlKgdJMdnVap2LoSpnUxsn0A9PEjMI6rVzvAQtTMiBrVzIVDtDAeSckQzj3PRgYjEPJvwSpCS46wMVf/swtUO+WV2Bbi5OD47kONzCOd4rSLFidYMskiZU6nauYBJ7czVzGjwXAxqZy5gEMwtXO3QHM7NoHbmFq52KNHN2Sw7Gc+jRO0gOT5Sqdq5QKHaGRUk5tHVamdUiNoZHYPauQCodkYBSTlaidpBYp5XeCVIyXEkQ9U/n3C1Q36ZTwFuLo7PB+T4/MI5XqtIcaI1gyxSFlCqds6HrTW5is9kc5oZDXbgaieXdYBBYISrHZpDA1c7uawRrnYo0S3QLDsZu0rUDpLjCaVq53yY2snF9plsySAxp6rVTjJE7aRiUDvnA9VOEkjKVDOPc9GBiMScFl4JUnJMMFT9GeFqh/ySUYCbi+MZIMc94RyvVaQ40ZpBFilZpWrnPJzaSZbbu2Azo8EL4tVOckFgECwkXO3QHC6EVzvJhYSrHUp02WbZyXhhJWoHyfFFlKqd83BqJxFiLovaGRMk5kWr1c6YELWzaAxq5zyg2hkDJOWizTzORQciEvNiwitBSo6LMFT9iwtXO+SXxRXg5uL44kCOLyGc47WKFCdaM8giZUmlaudc2FrjV7zbWaqZ0eCl4GrHzy4FDIKlhasdmsOl4WrHzy4tXO1QoluyWXYyXkaJ2kFyfFmlaudc3C+gjO3dznJBYl6+Wu0sF6J2lo9B7ZwLVDvLAUm5fDOPc9GBiMS8gvBKkJLjsgxV/4rC1Q75ZUUFuLk4viKQ4ysJ53itIsWJ1gyySFlZqdo5B7bWFIrl9q7SzGjwKnC1UyiuAgyCVYWrHZrDVeFqp1BcVbjaoUS3crPsZLyaErWD5PjqStXOOTC1U/BDzGVRO2sEiXnNarWzRojaWTMGtXMOUO2sASTlms08zkUHIhLzWsIrQUqOqzNU/WsLVzvkl7UV4Obi+NpAjq8jnOO1ihQnWjPIImVdpWrnbNhaYyre7azXzGjwenC1Y7LrAYNgfeFqh+ZwfbjaMdn1hasdSnTrNstOxhsoUTtIjm+oVO2cDVM7JrZ3OxsFiXnjarWzUYja2TgGtXM2UO1sBCTlxs08zkUHIhLzJsIrQUqOGzJU/ZsKVzvkl00V4Obi+KZAjm8mnOO1ihQnWjPIIiWnVO2chfvtohVqJ9/MaHAernby2TwwCArC1Q7NYQGudvLZgnC1Q4ku1yw7GftK1A6S40Wlaucs3G8XjU3tlILEvHm12imFqJ3NY1A7ZwHVTglIys2beZyLDkQk5i2EV4KUHIsMVf+WwtUO+WVLBbi5OL4lkONbCed4rSLFidYMskjZWqnaORP3CdReub3bNDMavA1c7XjeNsAg2Fa42qE53BaudjxvW+FqhxLd1s2yk/F2StQOkuPbK1U7Z8LUjpcJMZdF7ewQJOYdq9XODiFqZ8cY1M6ZQLWzA5CUOzbzOBcdiEjMOwmvBCk5bs9Q9e8sXO2QX3ZWgJuL4zsDOb6LcI7XKlKcaM0gi5RdlaqdM2BrTbJC7ezWzGjwbnC1k/R2AwbB7sLVDs3h7nC1k/R2F652KNHt2iw7Ge+hRO0gOb6nUrVzBkztJGNTO3sFiXnvarWzV4ja2TsGtXMGUO3sBSTl3s08zkUHIhLzPsIrQUqOezJU/fsKVzvkl30V4Obi+L5Aju8nnOO1ihQnWjPIImV/pWrndNhakzXl9h7QzGjwAXC1kzUHAIPgQOFqh+bwQLjayVbgdiK2MNyIRLd/s+xkfJAStYPk+MFK1c7pMLWTdULMZVE7hwSJ+dBqtXNIiNo5NAa1czpQ7RwCJOWhzTzORQciEvNhwitBSo4HM1T9hwtXO+SXwxXg5uL44UCOHyGc47WKFCdaM8gi5Uilauc02FqTccrtPaqZ0eCj4Gon4xwFDIKjhasdmsOj4Won4xwtXO1QojuyWXYyPkaJ2kFy/Filauc0mNpJl0LMZVE7xwWJ+fhqtXNciNo5Pga1cxpQ7RwHJOXxzTzORQciEvMJwitBSo7HMlT9JwpXO+SXExXg5uL4iUCOnySc47WKFCdaM8gi5WSlaudU3KcUVHwC9SnNjAafAlc7+eIpwCA4VbjaoTk8Fa528sVThasdSnQnN8tOxqcpUTtIjp+uVO2civuUgtg+gfqMIDGfWa12zghRO2fGoHZOBaqdM4CkPLOZx7noQERiPkt4JUjJ8XSGqv9s4WqH/HK2AtxcHD8byPFzhHO8VpHiRGsGWaScq1TtnAJba9yKdzvnNTMafB5c7bjOecAgOF+42qE5PB+udlznfOFqhxLduc2yk/EFStQOkuMXKlU7p+A+gTq2dzsXBYn54mq1c1GI2rk4BrVzClDtXAQk5cXNPM5FByIS8yXCK0FKjhcyVP2XClc75JdLFeDm4vilQI5fJpzjtYoUJ1ozyCJlrFK1czJurSmU23t5M6PBl8PVjlO4HBgEVwhXOzSHV8DVjlO4QrjaoUQ3tll2Mh6nRO0gOX6lUrVzMkztOPkQc1nUzvggMV9VrXbGh6idq2JQO8AVyIwHkvKqZh7nogMRiflq4ZUgJccrGar+a4SrHfLLNQpwc3H8GiDHrxXO8VpFihOtGWSRcp1StXMSbK1JV5xku76Z0eDr4WonXbweGAQ3CFc7NIc3wNVOuniDcLVDie66ZtnJ+EYlagfJ8ZuUqp2TcPd2YjvJdnOQmG+pVjs3h6idW2JQOycB1c7NQFLe0szjXHQgIjHfKrwSpOR4E0PVf5twtUN+uU0Bbi6O3wbk+O3COV6rSHGiNYMsUu5QqnZOhK01puIz2e5sZjT4TrjaMeZOYBDcJVzt0BzeBVc7pgK3E7GF4UYkujuaZSfju5WoHSTH71Gqdk7EnWSL7TPZ7g0S833VaufeELVzXwxq50Sg2rkXSMr7mnmciw5EJOb7hVeClBzvYaj6HxCudsgvDyjAzcXxB4Acf1A4x2sVKU60ZpBFykNK1c4JuMMYFfd2Hm5mNPjhZvy4jwhXKIT7keZJEwwal0VVUEJ5qFl20ntUiapA8vIx5kSP8MljDByPM6Eez5RQH29mNPhxhoT6hPCESrifqCdU2FhPKkmoSF4+JTyhkk+eUp5QjxuAm49ye59uZjT4aYZgfRpItmeEJ2eaw2cY5P0zwvfjNST6Z5UkeiTHnxO+RUI+eY4hXp4Xvg1IeeJ5piKOi5fPA3n5gnBe1spnTrRmkPnsReEcJx+/yCDQkDykgnBYw6RXYeUNbffIBp44b4Da6bK+v5yqbG6HB9+/ZP35su2v2P6q7a/Z/rrtb9j+pu1v2f627e/Y/q7t79n+vu0f2P6h7R/Z/rHtn9j+qe2f2f657V/Y/qXtX9n+te3f2P6t7RNs/872723/ofrd6UvBe9LyZy+HPHsl5NmrIc9eC3n2esizN0KevRny7K2QZ2+HPHsn5Nm7Ic/eC3n2fsizD0KefRjy7KOQZx+HPPsk5NmnIc8+C3n2ecizL0KefRny7KuQZ1+HPPsm5Nm3Ic8mhDz7LuTZ9yHPfmie/J38iODrYsFXJ1qrSDpRk+VLgMTb+X7/ZdBYhPEVyFj/zNer0cdyg/kyr0UdK/nv3JvXo43llPnRvBFlLLeCE+bN3o/lVPHLvNXLsdKlybhq3u7dWF4I7807vRnLC40h827Px8rUiEfzXk/HytSMbfN+z8Zyp5AnzAc9GSszxZxjPuz+WIUu8pf5qLtjZbrMhebj7o3ldCOvmk+6M5bTrRxtPu16rFQ38735rKuxkt1eO8znUxwrWerBOmS+mNJYmR6taebL2mN5PVwfzVc1xsqWerzWmq/Dx3J6sW6bb8LGcnpVA5hvJx/L9LKeMBOqx/J7XZuY7yrHSkSoc8z3ZWO5pUg1k/kBKNLjfHvxA6zW8ytuE/zYzGjwj83o2wS++RHnQPMTYFI5317QHP4E3I3tnMOfwEEQ16lwXPD6sZ0K/zkIsF+qdzZ+bp78VPgvzfynwnGZxDE/AwPoF7Bz0eSjoPkZGIyduH9WuiJ9D+NR1i+399dmRoN/ha9IWf9X4Ir0m/AViebwN/iKlPV/U7oifQ+zO1sIMZdlRfo9CLA/qlek30NWpD9iWJG+B65IvwMD6A8m56JfBCMx/wlMZg0N+NXypyABoV8EI6XARGAyC5tDJ1oz5OOJDJXMRKWVzHew/JNPlNv7VzOjwX/BK5l84i9k8LfIrmRoDslGbCWTT5TjdiK2MNyIBDpReAKdCjyHnQ298CI53geHOdab+t/BckbeDTGXpQLu2/LP134tDZXVbt+WyStg+iHuCvg7YAXcF0jKfi08zkUHIhJzf2AgNjTgA46SY58W/MLQyLxwOdGaIb80KsDNxfFGIMebhHO8VpGCKH5QYw0AL9hxqZ0JsLXGK5Xb29zCaDANjlU7XqkZ6MAW4WqH5rAFrna8UotwtUOJbkCL7GTcCk7GnQ2NGcnxNqVqZwJM7XjFEHNZ1E57kJinrlY77SFqZ+oY1M4EoNppB5Jy6hYe56IDEYl5oPBKkJJjG0PV3yFc7ZBfOhTg5uJ4B5Djg4RzvFaR4kRrBlmkDAbyJk618y1srXErPvVhmhZGg6eBqx3XmQYYBNMKVzs0h9PC1Y7rTCtc7VCiG9wiOxkPUaJ2kBwfqlTtfAtTO5W/cr4BaWeV2hkWJObpqtXOsBC1M10MaudboNoZBiTldC08zkUHIhLz9MIrQUqOQxmq/hmEqx3yywwKcHNxfAYgx2cUzvFaRYoTrRlkkTKTUrXzDe6WWIXambmF0eCZ4WrHd2YGBsEswtUOzeEscLXjO7MIVzuU6GZqkZ2MZ1WidpAcH65U7XwDUzuF2NTOiCAxz1atdkaEqJ3ZYlA73wDVzgggKWdr4XEuOhCRmGcXXglSchzOUPXPIVztkF/mUICbi+NzADk+p3CO1ypSnGjNIIuUuZSqna9ha0264jMx5m5hNHhuuNpJm7mBQTCPcLVDczgPXO2kK3A7EVsYbkSim6tFdjIeqUTtIDk+Sqna+RqmdtKxfZbK6CAxz1utdkaHqJ15Y1A7XwPVzmggKedt4XEuOhCRmOcTXglSchzFUPXPL1ztkF/mV4Cbi+PzAzm+gHCO1ypSnGjNIIsUR6na+Qr3bscrt9e0MBps8O92PAMMAle42qE5dPHvdjxXuNqhROe0yE7GCSVqB8nxpFK18xXuwwUzIeayqJ1UkJjT1WonFaJ20jGona+AaicFJGW6hce56EBEYs4IrwQpOSYZqn5PuNohv3gKcHNx3ANyPCuc47WKFCdaM8giZUGlaudL2FqTzJbbu1ALo8ELwdVOMrsQMAgWFq52aA4XhqudZHZh4WqHEt2CLbKT8SJK1A6S42OUqp0vYWon6YWYy6J2Fg0S82LVamfRELWzWAxq50ug2lkUSMrFWniciw5EJObFhVeClBzHMFT9SwhXO+SXJRTg5uL4EkCOLymc47WKFCdaM8giZSmlaucL3CdQV5xkW7qF0eCl4Wonb5YGBsEywtUOzeEycLWTr8DtRGxhuBGJbqkW2cl4WSVqB8nx5ZSqnS9wn0Ad20m25YPEvEK12lk+RO2sEIPa+QKodpYHknKFFh7nogMRiXlF4ZUgJcflGKr+lYSrHfLLSgpwc3F8JSDHVxbO8VpFihOtGWSRsopStfM5Tu0Uyu1dtYXR4FXxaqewKjAIVhOudmgOV8OrncJqwtUOJbpVWmQn49WVqB0kx9dQqnY+x6mdfIi5LGpnzSAxr1WtdtYMUTtrxaB2PgeqnTWBpFyrhce56EBEYl5beCVIyXENhqp/HeFqh/yyjgLcXBxfB8jxdYVzvFaR4kRrBlmkrKdU7XyGO8mWL7d3/RZGg9fHn2TLrw8Mgg2Eqx2aww3wJ9nyGwhXO5To1muRnYw3VKJ2kBzfSKna+Qx3ki0XYi6L2tk4SMybVKudjUPUziYxqJ3PgGpnYyApN2nhcS46EJGYNxVeCVJy3Iih6t9MuNohv2ymADcXxzcDcjwnnOO1ihQnWjPIIiWvVO18ivvtohWfQF1oYTS4AFc7nlMABoEvXO3QHPpwteM5vnC1Q4ku3yI7GReVqB0kx0tK1c6nMLWTie0TqDcPEvMW1Wpn8xC1s0UMaudToNrZHEjKLVp4nIsORCTmLYVXgpQcSwxV/1bC1Q75ZSsFuLk4vhWQ41sL53itIsWJ1gyySNlGqdr5hEntbNvCaPC2DGpnW2AQbCdc7dAcbsegdrYTrnYo0W3TIjsZb69E7SA5voNStfOJQrWzY5CYd6pWOzuGqJ2dYlA7nwDVzo5AUu6kRO0gMe8svBKk5LgDQ9W/i3C1Q37ZRQFuLo7vAuT4rsI5XqtIcaI1gyxSdlOqdj6GrTW5is9k272F0eDd4Wonl90dGAR7CFc7NId7wNVOLruHcLVDiW63FtnJeE8lagfJ8b2Uqp2PYWonF9tnsu0dJOZ9qtXO3iFqZ58Y1M7HQLWzN5CU+7TwOBcdiEjM+wqvBCk57sVQ9e8nXO2QX/ZTgJuL4/sBOb6/cI7XKlKcaM0gi5QDlKqdj3BqJ1lu74EtjAYfiFc7yQOBQXCQcLVDc3gQXu0kDxKudijRHdAiOxkfrETtIDl+iFK18xFO7SRCzGVRO4cGifmwarVzaIjaOSwGtfMRUO0cCiTlYS08zkUHIhLz4cIrQUqOhzBU/UcIVzvklyMU4O5saI4fAeT4kcI5XqtIcaI1gyxSjlKqdj7E/XbRinc7R7cwGnw0XO342aOBQXCMcLVDc3gMXO342WOEqx1KdEe1yE7GxypRO0iOH6dU7XyI++2isb3bOT5IzCdUq53jQ9TOCTGonQ+Baud4IClPaOFxLjoQkZhPFF4JUnI8jqHqP0m42iG/nKQANxfHTwJy/GThHK9VpDjRmkEWKacoVTsfwNaaQrHc3lNbGA0+Fa52CsVTgUFwmnC1Q3N4GlztFIqnCVc7lOhOaZGdjE9XonaQHD9Dqdr5AKZ2Cn6IuSxq58wgMZ9VrXbODFE7Z8Wgdj4Aqp0zgaQ8q4XHuehARGI+W3glSMnxDIaq/xzhaof8co4C3FwcPwfI8XOFc7xWkeJEawZZpJynVO28D1trTMW7nfNbGA0+H652TPZ8YBBcIFzt0BxeAFc7JnuBcLVDie68FtnJ+EIlagfJ8YuUqp33YWrHxPZu5+IgMV9SrXYuDlE7l8Sgdt4Hqp2LgaS8pIXHuehARGK+VHglSMnxIoaq/zLhaof8cpkC3FwcvwzI8bHCOV6rSHGiNYMsUi5Xqnbew/120Qq1c0ULo8FXwNVOPnsFMAjGCVc7NIfj4Gonnx0nXO1Qoru8RXYyvlKJ2kFyfLxStfMe7reLxqZ2rgoS89XVaueqELVzdQxq5z2g2rkKSMqrW3iciw5EJOZrhFeClBzHM1T91wpXO+SXaxXg5uL4tUCOXyec47WKFCdaM8gi5Xqlaudd3CdQe+X23tDCaPANcLXjeTcAg+BG4WqH5vBGuNrxvBuFqx1KdNe3yE7GNylRO0iO36xU7bwLUzteJsRcFrVzS5CYb61WO7eEqJ1bY1A77wLVzi1AUt7awuNcdCAiMd8mvBKk5HgzQ9V/u3C1Q365XQFuLo7fDuT4HcI5XqtIcaI1gyxS7lSqdt6BrTXJCrVzVwujwXfB1U7SuwsYBHcLVzs0h3fD1U7Su1u42qFEd2eL7GR8jxK1g+T4vUrVzjswtZOMTe3cFyTm+6vVzn0hauf+GNTOO0C1cx+QlPe38DgXHYhIzA8IrwQpOd7LUPU/KFztkF8eVICbi+MPAjn+kHCO1ypSnGjNIIuUh5Wqnbdha03WlNv7SAujwY/A1U7WPAIMgkeFqx2aw0fhaidbgduJ2MJwIxLdwy2yk/FjStQOkuOPK1U7b8PUTtYJMZdF7TwRJOYnq9XOEyFq58kY1M7bQLXzBJCUT7bwOBcdiEjMTwmvBCk5Ps5Q9T8tXO2QX55WgJuL408DOf6McI7XKlKcaM0gi5Rnlaqdt2BrTcYpt/e5FkaDn4OrnYzzHDAInheudmgOn4ernYzzvHC1Q4nu2RbZyfgFJWoHyfEXlaqdt2BqJ10KMZdF7bwUJOaXq9XOSyFq5+UY1M5bQLXzEpCUL7fwOBcdiEjMrwivBCk5vshQ9b8qXO2QX15VgJuL468COf6acI7XKlKcaM0gi5TXlaqdN3GfUlDxCdRvtDAa/AZc7eSLbwCD4E3haofm8E242skX3xSudijRvd4iOxm/pUTtIDn+tlK18ybuUwpi+wTqd4LE/G612nknRO28G4PaeROodt4BkvLdFh7nogMRifk94ZUgJce3Gar+94WrHfLL+wpwc3H8fSDHPxDO8VpFihOtGWSR8qFStfMGbK1xK97tfNTCaPBHcLXjOh8Bg+Bj4WqH5vBjuNpxnY+Fqx1KdB+2yE7GnyhRO0iOf6pU7byB+wTq2N7tfBYk5s+r1c5nIWrn8xjUzhtAtfMZkJSft/A4Fx2ISMxfCK8EKTl+ylD1fylc7ZBfvlSAm4vjXwI5/pVwjtcqUpxozSCLlK+Vqp3XcWtNodzeb1oYDf4GrnacwjfAIPhWuNqhOfwWrnacwrfC1Q4luq9bZCfjCUrUDpLj3ylVO6/D1I6TDzGXRe18HyTmH6rVzvchaueHGNQOcAUy3wNJ+UMLj3PRgYjE/KPwSpCS43cMVf9PwtUO+eUnBbi5OP4TkOM/C+d4rSLFidYMskj5RanaeQ221qQrTrL92sJo8K9wtZMu/goMgt+Eqx2aw9/gaidd/E242qFE90uL7GT8uxK1g+T4H0rVzmu4ezuxnWT7M0jME6vVzp8hamdiDGrnNaDa+RNIyoktPM5FByIS81/CK0FKjn8wVP0NrbLVDvmFbJSOm4vj5XZGHWuqVtkcr1WkONGaQRYpfYC8iVPtvApba0zFZ7L1bWU0mAbHqh1j+gKDoB8wOLnmsF8rWu2YCtxOxBaGG5Ho+rTKTsb9wcm4s6ExIzneiIy9hvjUzqu4k2yxfSZbU5CYB7Q2VCqbptbJ1Q79ELfaeRWodpqApBzQyuNcdCAiMTcLrwQpOTYyVP0twtUO+aVFAW4ujrcAOd4qnOO1ihQnWjPIIqVNqdp5BXcYo+LeTnsro8HtrfhxpxauUAj31K2TJhg0LouqoITS1io76Q1UoiqQvOxgTvQIn3QwcDzOhPoyU0Id1Mpo8CCGhDpYeEIl3IPrCRU21jRKEiqSl9MKT6jkk2mVJ9SXmnHzUW7vkFZGg4cwBOsQINmGCk/ONIdDGeT9UOH78RoS/TAliR7J8emEb5GQT6ZjiJfphW8DUp6YnqmI4+Ll9EBeziCcl7XymROtGWQ+m1E4x8nHMzIINCQPqSAc1jDpVVh5Q9u91wCeOG+A2umyvr+cqmxuhwffz2T9ObPts9g+q+3DbR9h+2y2z277HLbPaftcts9t+zy2j7R9lO2jbZ/X9vlsn9/2BWx3bDe2u7YnbE/anrI9bXvGds/2rO0L2r5Q9bvTmYL3pOXPZg55NkvIs1lDng0PeTYi5NlsIc9mD3k2R8izOUOezRXybO6QZ/OEPBsZ8mxUyLPRIc/mDXk2X8iz+UOeLRDyzAl5ZkKeuSHPEiHPkiHPUiHP0iHPMiHPvJBn2ZBnC4Y8W6h18nfyI4KviwVfnWitIulETZYzARJv5/v9mUFjEcZZIGP9M1+zRh/LDebLDI86VvLfuTcjoo3llPnRzBZlLLeCE2b23o/lVPHLzNHLsdKlybhq5uzdWF4I781cvRnLC40hM3fPx8rUiEczT0/HytSMbTOyZ2O5U8gTZlRPxspMMeeY0d0fq9BF/jLzdnesTJe50MzXvbGcbuRVM393xnK6laPNAl2PlepmvjdOV2Mlu712GDPFsZKlHqxDxp3SWJkerWkmUXssr4fro0nWGCtb6vFaa1LhYzm9WLdNOmwsp1c1gMlMPpbpZT1hvOqx/F7XJiZbOVYiQp1jFiwbyy1FqpnMQkCRHufbi4VgtZ5fcZtg4VZGgxduRd8m8M3COAeaRQCTyvn2guZwEeBubOccLgIOgrhOheOC14/tVPiYIMAWrd7ZGNM6+anwRVv5T4XjMoljxgADaFGwc9Hko6AZAwzGTtxjlK5IC8J4lPXL7V2sldNg+IqU9RcDrkiLC1+RaA4Xh69IWX9xpSvSgjC7s4UQc1lWpCWCAFuyekVaImRFWjKGFWlB4Iq0BDCAlmRyLvpFMBLzUsBk1tCAXy0XCRIQ+kUwUgosDUxmYXPoRGuGfLw0QyWztNJKJgvLP/lEub3LtDIavAy8ksknlgEG/7LCKxmaw2XhlUw+sSxz8CMS6NLCE+hy4DnsbOiFF8nx5YGxF2cFnIXZnXdDzGWpgFcIEvOK1RXwCiEV8IoxVMC4FcgxKwBJuSKTc9GBiMS8EnMF7ERrhpLj8gzV28rCq1byy8oKcHNxfGUgx1cRzvFaRQqi+EGNtSp4wY5L7XiwtcYrldu7WiujwavB1Y5XWg3owNWFqx2aw9XhascrrS5c7VCiW7VVdjJeA5yMOxsaM5LjaypVOx7Mbq8YYi6L2lkrSMxrV6udtULUztoxqB3cCuSYtYCkXJvJuehARGJeR3glSMlxTYaqf13haof8sq4C3FwcXxfI8fWEc7xWkeJEawZZpKyv9N1OBrbWuBWf+rBBK6PBG8DVjutsAAyCDYWrHZrDDeFqx3U2FK52KNGt3yo7GW+kRO0gOb6xUrWTgdld+SvnG5B2VqmdTYLEvGm12tkkRO1sGoPawa1AjtkESMpNmZyLDkQk5s2EV4KUHDdmqPpzwtUO+SWnAHdn68NoZ9Sx8sI5XqtIcaI1gyxSCkrVThq21vgVasdvZTTYh6sd3/GBQVAUrnZoDotwteM7ReFqhxJdoVV2Mi4pUTtIjm+uVO2kYXYXYlM7WwSJectqtbNFiNrZMga1g1uBHLMFkJRbMjkXHYhIzFsJrwQpOW7OUPVvLVztkF+2VoCbi+NbAzm+jXCO1ypSnGjNIIuUbZWqnRRsrUlXfCbGdq2MBm8HVztpsx0wCLYXrnZoDreHq510BW4nYgvDjUh027bKTsY7KFE7SI7vqFTtpGB2p2P7LJWdgsS8c7Xa2SlE7ewcg9rBrUCO2QlIyp2ZnIsORCTmXYRXgpQcd2So+ncVrnbIL7sqwM3F8V2BHN9NOMdrFSlOtGaQRcruStVOEvduxyu3d49WRoP3wL/b8fYABsGewtUOzeGe+Hc73p7C1Q4lut1bZSfjvZSoHSTH91aqdpIwu/1MiLksamefIDHvW6129glRO/vGoHZwK5Bj9gGScl8m56IDEYl5P+GVICXHvRmq/v2Fqx3yy/4KcHNxfH8gxw8QzvFaRYoTrRlkkXKgUrWTgK01yWy5vQe1Mhp8EFztJLMHAYPgYOFqh+bwYLjaSWYPFq52KNEd2Co7GR+iRO0gOX6oUrWTgNmd9ELMZVE7hwWJ+fBqtXNYiNo5PAa1g1uBHHMYkJSHMzkXHYhIzEcIrwQpOR7KUPUfKVztkF+OVICbi+NHAjl+lHCO1ypSnGjNIIuUo5WqHRe21uQrTrId08po8DFwtZM3xwCD4Fjhaofm8Fi42slX4HYitjDciER3dKvsZHycErWD5PjxStWOC7M7H9tJthOCxHxitdo5IUTtnBiD2sGtQI45AUjKE5mciw5EJOaThFeClByPZ6j6TxaudsgvJyvAzcXxk4EcP0U4x2sVKU60ZpBFyqlK1Y7BqZ1Cub2ntTIafBpe7RROAwbB6cLVDs3h6Xi1UzhduNqhRHdqq+xkfIYStYPk+JlK1Y7BFcT5EHNZ1M5ZQWI+u1rtnBWids6OQe3gViDHnAUk5dlMzkUHIhLzOcIrQUqOZzJU/ecKVzvkl3MV4Obi+LlAjp8nnOO1ihQnWjPIIuV8pWrHwZ1ky5fbe0Ero8EX4E+y5S8ABsGFwtUOzeGF+JNs+QuFqx1KdOe3yk7GFylRO0iOX6xU7Ti4w065EHNZ1M4lQWK+tFrtXBKidi6NQe3gViDHXAIk5aVMzkUHIhLzZcIrQUqOFzNU/WOFqx3yy1gFuLk4PhbI8cuFc7xWkeJEawZZpFyhVO0sAFtrvIpPoB7XymjwOLja8ZxxwCC4UrjaoTm8Eq52POdK4WqHEt0VrbKT8XglagfJ8auUqp0FYHZnYvsE6quDxHxNtdq5OkTtXBOD2sGtQI65GkjKa5iciw5EJOZrhVeClByvYqj6rxOudsgv1ynAzcXx64Acv144x2sVKU60ZpBFyg1K1c78TGrnxlZGg29kUDs3AoPgJuFqh+bwJga1c5NwtUOJ7oZW2cn4ZiVqB8nxW5SqnfkVqp1bg8R8W7XauTVE7dwWg9rBrUCOuRVIytuUqB0k5tuFV4KUHG9hqPrvEK52yC93KMDNxfE7gBy/UzjHaxUpTrRmkEXKXUrVznywtSZX8Zlsd7cyGnw3XO3ksncDg+Ae4WqH5vAeuNrJZe8RrnYo0d3VKjsZ36tE7SA5fp9StTMfzO5cbJ/Jdn+QmB+oVjv3h6idB2JQO7gVyDH3A0n5AJNz0YGIxPyg8EqQkuN9DFX/Q8LVDvnlIQW4uTj+EJDjDwvneK0ixYnWDLJIeUSp2pkXp3aS5fY+2spo8KN4tZN8FBgEjwlXOzSHj+HVTvIx4WqHEt0jrbKT8eNK1A6S408oVTvz4griRIi5LGrnySAxP1Wtdp4MUTtPxaB2cCuQY54EkvIpJueiAxGJ+WnhlSAlxycYqv5nhKsd8sszCnBzcfwZIMefFc7xWkWKE60ZZJHynFK1Mxq21vgV73aeb2U0+Hm42vGzzwOD4AXhaofm8AW42vGzLwhXO5TonmuVnYxfVKJ2kBx/SanaGQ2z24/t3c7LQWJ+pVrtvByidl6JQe3gViDHvAwk5StMzkUHIhLzq8IrQUqOLzFU/a8JVzvkl9cU4Obi+GtAjr8unOO1ihQnWjPIIuUNpWpnFGytKRTL7X2zldHgN+Fqp1B8ExgEbwlXOzSHb8HVTqH4lnC1Q4nujVbZyfhtJWoHyfF3lKqdUTC7C36IuSxq590gMb9XrXbeDVE778WgdnArkGPeBZLyPSbnogMRifl94ZUgJcd3GKr+D4SrHfLLBwpwc3H8AyDHPxTO8VpFihOtGWSR8pFStTMSttaYinc7H7cyGvwxXO2Y7MfAIPhEuNqhOfwErnZM9hPhaocS3UetspPxp0rUDpLjnylVOyNhdpvY3u18HiTmL6rVzuchaueLGNQObgVyzOdAUn7B5Fx0ICIxfym8EqTk+BlD1f+VcLVDfvlKAW4ujn8F5PjXwjleq0hxojWDLFK+Uap25oGtNfkKtfNtK6PB38LVTj77LTAIJghXOzSHE+BqJ5+dIFztUKL7plV2Mv5OidpBcvx7pWpnHpjd+djUzg9BYv6xWu38EKJ2foxB7eBWIMf8ACTlj0zORQciEvNPwitBSo7fM1T9PwtXO+SXnxXg5uL4z0CO/yKc47WKFCdaM8gi5Velamdu2FrjeeX2/tbKaPBvcLXjeb8Bg+B34WqH5vB3uNrxvN+Fqx1KdL+2yk7GfyhRO0iO/6lU7cwNs9vLhJjLonYmBon5r2q1MzFE7fwVg9rBrUCOmQgk5V9MzkUHIhJzQ5vsSpCS458MVf9UbbwLlxOtGfIL2SgdNxfHy+2MOlYf4RyvVaQ40ZpBFil9gbyJU+3MBVtrkhVqp18bo8E0OFbtJL1+wCDoDwxOrjns34ZWO0mvP/OigUh0fdtkJ+NGcDLubGjMSI43ATHHqXbmghXEydjUzoAgMTe3NVQqmwFtk6sd+iFutTMXUO0MAJKyuY3HuehARGJuEV4JUnJsYqj6W4WrHfJLqwLcXBxvBXK8TTjHaxUpTrRmkEVKu1K1MydsrcmacnunbmM0eGq42smaqYFBMFC42qE5HAhXO9kK3E7EFoYbkeja22Qn4w4lagfJ8UFK1c6cMLWTdULMZVE7g4PEPE212hkconamiUHtzAlUO4OBpJymjce56EBEYp5WeCVIyXEQQ9U/RLjaIb8MUYCbi+NDgBwfKpzjtYoUJ1ozyCJlmFK1Mwdsrck45fZO18Zo8HRwtZNxpgMGwfTC1Q7N4fRwtZNxpheudijRDWuTnYxnUKJ2kByfUanamQOmdtKlEHNZ1M5MQWKeuVrtzBSidmaOQe3MAVQ7MwFJOXMbj3PRgYjEPIvwSpCS44wMVf+swtUO+WVWBbi5OD4rkOPDhXO8VpHiRGsGWaSMUKp2Zsd9SkHFJ1DP1sZo8GxwtZMvzgYMgtmFqx2aw9nhaidfnF242qFEN6JNdjKeQ4naQXJ8TqVqZ3bcRfbYPoF6riAxz12tduYKUTtzx6B2ZgeqnbmApJy7jce56EBEYp5HeCVIyXFOhqp/pHC1Q34ZqQA3F8dHAjk+SjjHaxUpTrRmkEXKaKVqZzbYWuNWvNuZt43R4Hnhasd15gUGwXzC1Q7N4XxwteM68wlXO5ToRrfJTsbzK1E7SI4voFTtzIb7kOLY3u04QWI21WrHCVE7Jga1MxtQ7ThAUpo2HueiAxGJ2RVeCVJyXICh6k8IVzvkl4QC3FwcTwA5nhTO8VpFihOtGWSRklKqdkbg1ppCub3pNkaD03C14xTSwCDICFc7NIcZuNpxChnhaocSXapNdjL2lKgdJMezStXOCNxnyeVDzGVROwsGiXmharWzYIjaWSgGtQNcgcyCQFIu1MbjXHQgIjEvLLwSpOSYZaj6FxGudsgviyjAzcXxRYAcHyOc47WKFCdaM8giZVGlamc4bK1JV5xkW6yN02C42kkXFwMGweLC1Q7N4eJwtZMuLi5c7VCiW7RNdjJeQonaQXJ8SaVqZzju3k5sJ9mWChLz0tVqZ6kQtbN0DGpnOFDtLAUk5dJtPM5FByIS8zLCK0FKjksyVP3LClc75JdlFeDm4viyQI4vJ5zjtYoUJ1ozyCJleaVqZ1bYWmMqPpNthTZGg1eAqx1jVgAGwYrC1Q7N4YpwtWMqcDsRWxhuRKJbvk12Ml5JidpBcnxlpWpnVtxJttg+k22VIDGvWq12VglRO6vGoHZmBaqdVYCkXLWNx7noQERiXk14JUjJcWWGqn914WqH/LK6AtxcHF8dyPE1hHO8VpHiRGsGWaSsqVTtzAL8hZDl9q7VxmjwWm34cdcWrlAI99ptkyYYNC6LqqCEsmab7KS3jhJVgeTlusyJHuGTdRk4HmdCnZkpoa7XxmjwegwJdX3hCZVwr19PqLCxNlCSUJG83FB4QiWfbKg8oc4E/K2Y5fZu1MZo8EYMwboRkGwbC0/ONIcbM8j7jYXvx2tI9JsoSfRIjm8qfIuEfLIpQ7xsJnwbkPLEZkxFHBcvNwPyMiecl7XymROtGWQ+ywvnOPk4zyDQkDykgnBYw6RXYeUNfrG5gSfOG6B2uqzvL6cqm9vhwfcF60/f9qLtJds3t30L27e0fSvbt7Z9G9u3tX0727e3fQfbd7R9J9t3tn0X23e1fTfbd7d9D9v3tH0v2/e2fR/b97V9P9v3t/0A2w+0/aDqd6eF4D1p+TM/5Fkx5Fkp5NnmIc+2CHm2ZcizrUKebR3ybJuQZ9uGPNsu5Nn2Ic92CHm2Y8iznUKe7RzybJeQZ7uGPNst5NnuIc/2CHm2Z8izvUKe7R3ybJ+QZ/uGPNsv5Nn+Ic8OCHl2YMizg9omfyc/Ivi6WPDVidYqkk7UZFkAJN7O9/s+aCzCWISM9c98laKP5QbzZTaPOlby37k3W0Qbyynzo9kyylhuBSfMVr0fy6nil9m6l2OlS5Nx1WzTu7G8EN6bbXszlhcaQ2a7no+VqRGPZvuejpWpGdtmh56N5U4hT5gdezJWZoo5x+zU/bEKXeQvs3N3x8p0mQvNLt0by+lGXjW7dmcsp1s52uzW9VipbuZ7s3tXYyW7vXaYPaY4VrLUg3XI7DmlsTI9WtPMXrXH8nq4Ppq9a4yVLfV4rTX7hI/l9GLdNvuGjeX0qgYw+00+lullPWH2rx7L73VtYg6oHCsRoc4xB5aN5ZYi1UzmIKBIj/PtxUGwWs+vuE1wcBujwQe3oW8T+OZgnAPNIYBJ5Xx7QXN4CHA3tnMODwEHQVynwnHB68d2KvzQIMAOq97ZOLRt8lPhh7XxnwrHZRLHHAoMoMPAzkWTj4LmUGAwduI+VOmKdCCMR1m/3N7D2xgNPhy+ImX9w4Er0hHCVySawyPgK1LWP0LpinQgzO5sIcRclhXpyCDAjqpekY4MWZGOimFFOhC4Ih0JDKCjmJyLfhGMxHw0MJk1NOBXy0OCBIR+EYyUAscAk1nYHDrRmiEfH8NQyRyjtJI5AJZ/8olye49tYzT4WHglk08cCwz+44RXMjSHx8ErmXziOObgRyTQY4Qn0OPBc9jZ0AsvkuMnAGMvzgr4AJjdeTfEXJYK+MQgMZ9UXQGfGFIBnxRDBYxbgRxzIpCUJzE5Fx2ISMwnM1fATrRmKDmewFC9nSK8aiW/nKIANxfHTwFy/FThHK9VpCCKH9RYp4EX7LjUzv6wtcYrldt7ehujwafD1Y5XOh3owDOEqx2awzPgascrnSFc7VCiO61NdjI+E5yMOxsaM5LjZylVO/vD7PaKIeayqJ2zg8R8TrXaOTtE7ZwTg9rBrUCOORtIynOYnIsORCTmc4VXgpQcz2Ko+s8TrnbIL+cpwM3F8fOAHD9fOMdrFSlOtGaQRcoFSt/t7Adba9yKT324sI3R4Avhasd1LgQGwUXC1Q7N4UVwteM6FwlXO5ToLmiTnYwvVqJ2kBy/RKna2Q9md+WvnG9A2lmldi4NEvNl1Wrn0hC1c1kMage3AjnmUiApL2NyLjoQkZjHCq8EKTlewlD1Xy5c7ZBfLleAm4vjlwM5foVwjtcqUpxozSCLlHFK1c6+sLXGr1A7V7YxGnwlXO34zpXAIBgvXO3QHI6Hqx3fGS9c7VCiG9cmOxlfpUTtIDl+tVK1sy/M7kJsaueaIDFfW612rglRO9fGoHZwK5BjrgGS8lom56IDEYn5OuGVICXHqxmq/uuFqx3yy/UKcHNx/Hogx28QzvFaRYoTrRlkkXKjUrWzD2ytSVd8JsZNbYwG3wRXO2lzEzAIbhaudmgOb4arnXQFbidiC8ONSHQ3tslOxrcoUTtIjt+qVO3sA7M7HdtnqdwWJObbq9XObSFq5/YY1A5uBXLMbUBS3s7kXHQgIjHfIbwSpOR4K0PVf6dwtUN+uVMBbi6O3wnk+F3COV6rSHGiNYMsUu5Wqnb2xr3b8crtvaeN0eB78O92vHuAQXCvcLVDc3gv/t2Od69wtUOJ7u422cn4PiVqB8nx+5Wqnb1hdvuZEHNZ1M4DQWJ+sFrtPBCidh6MQe3gViDHPAAk5YNMzkUHIhLzQ8IrQUqO9zNU/Q8LVzvkl4cV4Obi+MNAjj8inOO1ihQnWjPIIuVRpWpnL9hak8yW2/tYG6PBj8HVTjL7GDAIHheudmgOH4ernWT2ceFqhxLdo22yk/ETStQOkuNPKlU7e8HsTnoh5rKonaeCxPx0tdp5KkTtPB2D2sGtQI55CkjKp5mciw5EJOZnhFeClByfZKj6nxWudsgvzyrAzcXxZ4Ecf044x2sVKU60ZpBFyvNK1c6esLUmX3GS7YU2RoNfgKudvHkBGAQvClc7NIcvwtVOvgK3E7GF4UYkuufbZCfjl5SoHSTHX1aqdvaE2Z2P7STbK0FifrVa7bwSonZejUHt4FYgx7wCJOWrTM5FByIS82vCK0FKji8zVP2vC1c75JfXFeDm4vjrQI6/IZzjtYoUJ1ozyCLlTaVqZw+c2imU2/tWG6PBb+HVTuEtYBC8LVzt0By+jVc7hbeFqx1KdG+2yU7G7yhRO0iOv6tU7eyBK4jzIeayqJ33gsT8frXaeS9E7bwfg9rBrUCOeQ9IyveZnIsORCTmD4RXgpQc32Wo+j8UrnbILx8qwM3F8Q+BHP9IOMdrFSlOtGaQRcrHStXO7riTbPlyez9pYzT4E/xJtvwnwCD4VLjaoTn8FH+SLf+pcLVDie7jNtnJ+DMlagfJ8c+Vqp3dcYedciHmsqidL4LE/GW12vkiRO18GYPawa1AjvkCSMovmZyLDkQk5q+EV4KUHD9nqPq/Fq52yC9fK8DNxfGvgRz/RjjHaxUpTrRmkEXKt0rVzm6wtcar+ATqCW2MBk+Aqx3PmQAMgu+Eqx2aw+/gasdzvhOudijRfdsmOxl/r0TtIDn+g1K1sxvM7kxsn0D9Y5CYf6pWOz+GqJ2fYlA7uBXIMT8CSfkTk3PRgYjE/LPwSpCS4w8MVf8vwtUO+eUXBbi5OP4LkOO/Cud4rSLFidYMskj5Tana2ZVJ7fzexmjw7wxq53dgEPwhXO3QHP7BoHb+EK52KNH91iY7Gf+pRO0gOT5RqdrZVaHa+aszMbc3VCqbv0LUDv0Qt9rBrUCO+QuZeNt1qB0k5qnasckHHXCUHCcyVP192nkXLidaM+QXslE6bi6Ol9sZday+wjleq0hxojWDLFL6AXkTp9rZBbbW5Co+k61/O6PBNDhW7eSy/YFB0AgMTq45bGxHq51ctpF50UAkun7tspNxEzgZdzY0ZiTHBwAxx6l2doGpnVxsn8nWHCTmlmq109w+udppiUHt7AJUO81AUra08zgXHYhIzK3CK0FKjgMYqv424WqH/NKmADcXx9uAHG8XzvFaRYoTrRlkkTK1UrWzM07tJMvtHdjOaPBAvNpJDgQGQYdwtUNz2IFXO8kO4WqHEt3U7bKT8SAlagfJ8cFK1c7OOLWTCDGXRe1MEyTmaavVzjQhamfaGNTOzkC1Mw2QlNO28zgXHYhIzEOEV4KUHAczVP1Dhasd8stQBbi5OD4UyPFhwjleq0hxojWDLFKmU6p2doKtNX7Fu53p2xkNnh6udvzs9MAgmEG42qE5nAGudvzsDMLVDiW66dplJ+MZlagdJMdnUqp2doKpHT+2dzszB4l5lmq1M3OI2pklBrWzE1DtzAwk5SztPM5FByIS86zCK0FKjjMxVP3Dhasd8stwBbi5OD4cyPERwjleq0hxojWDLFJmU6p2doStNYViub2ztzMaPDtc7RSKswODYA7haofmcA642ikU5xCudijRzdYuOxnPqUTtIDk+l1K1syNM7RT8EHNZ1M7cQWKep1rtzB2iduaJQe3sCFQ7cwNJOU87j3PRgYjEPFJ4JUjJcS6Gqn+UcLVDfhmlADcXx0cBOT5aOMdrFSlOtGaQRcq8StXODrC1xlS825mvndHg+eBqx2TnAwbB/MLVDs3h/HC1Y7LzC1c7lOjmbZedjBdQonaQHHeUqp0dYGrHxPZuxwSJ2a1WOyZE7bgxqJ0dgGrHAEnptvM4Fx2ISMwJ4ZUgJUeHoepPClc75JekAtxcHE8COZ4SzvFaRYoTrRlkkZJWqna2h601+Qq1k2lnNDgDVzv2GTAIPOFqh+bQg6udfNYTrnYo0aXbZSfjrBK1g+T4gkrVzvYwtZOPTe0sFCTmhavVzkIhamfhGNTO9kC1sxCQlAu38zgXHYhIzIsIrwQpOS7IUPWPEa52yC9jFODm4vgYIMcXFc7xWkWKE60ZZJGymFK1sx3uE6i9cnsXb2c0eHG42vG8xYFBsIRwtUNzuARc7XjeEsLVzt+Jrl12Ml5SidpBcnwppWpnO5ja8TIh5rKonaWDxLxMtdpZOkTtLBOD2tkOqHaWBpJymXYe56IDEYl5WeGVICXHpRiq/uWEqx3yy3IKcHNxfDkgx5cXzvFaRYoTrRlkkbKCUrWzLWytSVaonRXbGQ1eEa52kt6KwCBYSbjaoTlcCa52kt5KwtUOJboV2mUn45WVqB0kx1dRqna2hamdZGxqZ9UgMa9WrXZWDVE7q8WgdrYFqp1VgaRcrZ3HuehARGJeXXglSMlxFYaqfw3haof8soYC3FwcXwPI8TWFc7xWkeJEawZZpKylVO1sA1trsqbc3rXbGQ1eG652smZtYBCsI1zt0ByuA1c72QrcTsQWhhuR6NZql52M11WidpAcX0+p2tkGpnayToi5LGpn/SAxb1CtdtYPUTsbxKB2tgGqnfWBpNygnce56EBEYt5QeCVIyXE9hqp/I+Fqh/yykQLcXBzfCMjxjYVzvFaR4kRrBlmkbKJU7WwNW2syTrm9m7YzGrwpXO1knE2BQbCZcLVDc7gZXO1knM2Eqx1KdJu0y07GOSVqB8nxvFK1szVM7aRLIeayqJ1CkJj9arVTCFE7fgxqZ2ug2ikASem38zgXHYhIzEXhlSAlxzxD1V8SrnbILyUFuLk4XgJyfHPhHK9VpDjRmkEWKVsoVTtb4T6loOITqLdsZzR4S7jayRe3BAbBVsLVDs3hVnC1ky9uJVztUKLbol12Mt5aidpBcnwbpWpnK9ynFMT2CdTbBol5u2q1s22I2tkuBrWzFVDtbAsk5XbtPM5FByIS8/bCK0FKjtswVP07CFc75JcdFODm4vgOQI7vKJzjtYoUJ1ozyCJlJ6VqZ0vYWuNWvNvZuZ3R4J3hasd1dgYGwS7C1Q7N4S5wteM6uwhXO5TodmqXnYx3VaJ2kBzfTana2RL3CdSxvdvZPUjMe1Srnd1D1M4eMaidLYFqZ3cgKfdo53EuOhCRmPcUXglSctyNoerfS7jaIb/spQA3F8f3AnJ8b+Ecr1WkONGaQRYp+yhVO1vg1ppCub37tjMavC9c7TiFfYFBsJ9wtUNzuB9c7TiF/YSrHUp0+7TLTsb7K1E7SI4foFTtbAFTO04+xFwWtXNgkJgPqlY7B4aonYNiUDvAFcgcCCTlQe08zkUHIhLzwcIrQUqOBzBU/YcIVzvkl0MU4Obi+CFAjh8qnOO1ihQnWjPIIuUwpWpnc9hak644yXZ4O6PBh8PVTrp4ODAIjhCudmgOj4CrnXTxCOFqhxLdYe2yk/GRStQOkuNHKVU7m+Pu7cR2ku3oIDEfU612jg5RO8fEoHY2B6qdo4GkPKadx7noQERiPlZ4JUjJ8SiGqv844WqH/HKcAtxcHD8OyPHjhXO8VpHiRGsGWaScoFTtlGBrjan4TLYT2xkNPhGudow5ERgEJwlXOzSHJ8HVjqnA7URsYbgRie6EdtnJ+GQlagfJ8VOUqp0S7iRbbJ/JdmqQmE+rVjunhqid02JQOyWg2jkVSMrT2nmciw5EJObThVeClBxPYaj6zxCudsgvZyjAzcXxM4AcP1M4x2sVKU60ZpBFyllK1U4Rdxij4t7O2e2MBp/djh/3HOEKhXCf0z5pgkHjsqgKSihntctOeucqURVIXp7HnOgRPjmPgeNxJlSfKaGe385o8PkMCfUC4QmVcF9QT6iwsS5UklCRvLxIeEIln1ykPKEW2nDzUW7vxe2MBl/MEKwXA8l2ifDkTHN4CYO8v0T4fryGRH+pkkSP5PhlwrdIyCeXMcTLWOHbgJQnxjIVcVy8HAvk5eXCeVkrnznRmkHmsyuEc5x8fAWDQEPykArCsjCsKAzH0V/QDwxoiKdiHAd0aJ8yO68MEI6vflFIf3FA1bPxwbPyhn5ROA7owSu7P1ahi7HMePBmeHND+Nvrhh7OZ1d2NzCS8krgnJQH0VXVZLyqffIoqyYekixd2Gq6AnMVkMRXt8PI4JTP6dXdCOaoto8HzgNyTq/pwZx29W+Vz+k1ZUlzQNl8ls+pE62ZiVMezy2UTCJVzKScdC6Z8tMJ13czjp9MlYw12M0m7dSUCknP99xEyc24hYlY+/7mWGdi61xIJjZMWkDo+2vt1+tsv779n1U0rn2X68r8bryE62YSxA/Pd0zSt0uA6/r5pFNwcgW3mE2abCnpJhMFv5C3XMqZklPKFbIl75+xyu29oZ3R4BtCas2oxt8ArLFvFL7vQnN4Y0itGXUObwRXBE0N8Zxnu47pOEgDdn4rKoKbygsA9IYA0JGmfDUoN7qHNhe6Q76beiFCu5r0m4DBfDO4POyc15vLKpeecsHQBotxSk7WdXJOppDO5LO+m/dypUQplfATvZ3XrsiOnNdbmOb1lmBe49S1yGRUnjxvDVbk2ygGORLGTQy7FzcJ38nvbXA4PcAd1cbbhe98ETFvZ9jVvoMpKdwxhWTrRGvmNqa5uJNpLu6MsPB0ZTMXL9LD/l9zSpf7alwcyAyTnQeuC3CjcynQ3wY5h/+VPc9bmfY875qSwnGiNXM7U0K8awoKp4thutxDJZvvYkgMHjgxdLZ+PfRZTwqZqJjvbpeZYJC+KOfl3SF72z31T1dzjvTPPeX7komEjQ0/Y0p+KZHKZN28SSfS6VKylEl7Sb+USub8TNEkcwk3W8w4JeMV7W5vopBJl7J+IV0qT9rGTySSfjZfMCk3ncs7np/IOaVkJmHFr5/I+H7CS6dziYSf9kpe1gpWK4M9J5XJZJ20m8i6XP65p0xpohaFrnY2ysfUsijcq3FRuJd5UbiXYVHIClkUapI48/fd1xIy6dwndFHIMiWd+wCLQlfbfEj/3C90UeDyz/3/oe3HB4LtxwfDth+daK3m3j/yPUjUsYBbmSyH+DrnEH3igWsOo471kHB/UMA8xLCwP8xU5DzMuC36INNcPMI0F48wboty8WIh4duiXBxYWMG26EMM26JAf5uF69ui1e3v/I2ak/LC71FOBfwQU0J8lFEBk82PMiSGRZRsiz4ELIoea5eZYBZhUliPxbAtivTP40AFvDBQAXP55/EQ/6APeCH98wRT/nwCMA9d7dQg5+FJpnl4shvb5JIX8hBzYTwuLxKe0lgkPMVcJDzFUCSMialIiHg6FprkngaOhSwSxjAtQk93o0iIesoW6Z9n2nELO7JI4PLPM4w7TyPtGCMb8HnjWeGHMgnzswz58jkAz//51NsSC26y7zkG3M8L9zdhfp4B9wvCcZN9LzDgflE4brLvRQbcLwnHTfa9xID7ZeG4yb6XGXC/Ihw32fcKA+5XheMm+15lwP2agnXsNQbcrwvHTfa9zoD7DQX+foMB95vCcZN9bzLgfks4brLvLQbcbwvHTfa9zYD7HQXx/Q4D7neF4yb73mXA/Z5w3GTfewy43xeOm+x7nwH3B8Jxk30fMOD+UEFe+5AB90fCcZN9HzHg/lg4brLvYwbcnwjHTfZ9woD7UwXx/SkD7s+E4yb7PmPA/bkCf3/OgPsL4bjJvi8YcH+pwN9fMuD+Sjhusu8rBtxfC8dN9n3NgPsb4bjJvm8YcH+rIL6/ZcA9QThusm8CA+7vFPj7Owbc3wvHTfZ9z4D7BwX+/oEB94/CcZN9PzLg/kk4brLvJwbcPwvHTfb9zID7FwXx/QsD7l+F4yb7fmXA/Ztw3GTfbwy4f1fA898ZcP8hHDfZ9wcD7j8V+PtPBtwTheMm+yYy4P5Lgb//YsDdMLVs3GQfdTTuqYTjJvumYsDdRzhusq8PA+6+wnGTfX0ZcPcTjpvs68eAu79w3JTP+zPgbhSOm+xrZMDdJBw32dfEgHuAcNxk3wAG3M0K4ruZAXeLcNxkXwsD7lYF/m5lwN0mHDfZ18aAu104brKvnQH31MJxk31TM+AeKBw32TeQAXeHgrzWwYB7kHDcZN8gBtyDFfh7MAPuaYTjJvumYcA9rXDcZN+0DLiHKOD5EAbcQ4XjJvuGMuAeJhw32TeMAfd0wnGTfdMx4J5eOG6yb3oG3DMIx032zcCAe0bhuMm+GRlwzyQcN9k3EwPumYXjJvtmZsA9i4K6ZRYG3LMKx032zcqAe7hw3GTfcAbcIxTwfAQD7tmE4yb7ZmPAPbtw3GTf7Ay45xCOm+ybgwH3nArie04G3HMJx032zcWAe24F/p6bAfc8wnGTffMw4B4pHDfZN5IB9ygFPB/FgHu0cNxk32gG3PMq8Pe8DLjnE46b7JuPAff8Cvw9PwPuBYTjJvsWYMDtCMdN9jkMuI1w3GSfYcDtCsdN9rkMuBPCcZN9CQbcSQX5PMmAOyUcN9mXYsCdFo6b7Esz4M4o4HmGAbcnHDfZ5zHgzgrHTfZlGXAvKBw32bcgA+6FhOMm+xZiwL2wcNxk38IMuBcRjpvsW4QB9xgF69gYBtyLCsdN9i3KgHsx4bj/to8B9+LCcZN9izPgXkI4brJvCQbcSyrIa0sy4F5KOG6ybykG3EsLx032Lc2AexkFPF+GAfeywnGTfcsy4F5Ogb+XY8C9vHDcZN/yDLhXEI6b7FuBAfeKCni+IgPulYTjJvtWYsC9sgJ/r8yAexXhuMm+VRhwryocN9m3KgPu1RTwfDUG3KsLx032rc6Aew0F/l6DAfeawnGTfWsy4F5LOG6yby0G3Gsr4PnaDLjXEY6b7FuHAfe6wnGTfesy4F5POG6ybz0G3OsLx032rc+AewPhuMm+DRhwbygcN9m3IQPujYTjJvs2YsC9sYL1e2MG3JsIx032bcKAe1MF/t6UAfdmwnGTfZsx4M4Jx0325Rhw54XjJvvyDLgLwnGTfQUG3L5w3GSfz4C7KBw32VdkwF0SjpvsKzHg3lzB+r05A+4thOMm+7ZgwL2lcNxk35YMuLdSwPOtGHBvLRw32bc1A+5thOMm+7ZhwL2tAp5vy4B7O+G4yb7tGHBvr8Df2zPg3kE4brJvBwbcOwrHTfbtyIB7J+G4yb6dGHDvLBw32bczA+5dhOMm+3ZhwL2rgny+KwPu3YTjJvt2Y8C9u3DcZN/uDLj3UMDzPRhw7ykcN9m3JwPuvRT4ey8G3HsLx0327c2Aex8F/t6HAfe+wnGTffsy4N5POG6ybz8G3Psr4Pn+DLgPEI6b7DuAAfeBwnGTfQcy4D5IOG6y7yAG3AcriO+DGXAfIhw32XcIA+5DheMm+w5lwH2YAp4fxoD7cOG4yb7DGXAfIRw32XcEA+4jheMm+45kwH2UcNxk31EMuI8WjpvsO5oB9zHCcZN9xzDgPlbBOnYsA+7jhOMm+45jwH28An8fz4D7BOG4yb4TGHCfKBw32XciA+6ThOMm+05iwH2ygvg+mQH3KcJxk32nMOA+VYG/T2XAfZpw3GTfaQy4T1fg79MZcJ8hHDfZdwYD7jMV+PtMBtxnCcdN9p3FgPtsBf4+mwH3OcJxk33nMOA+Vzhusu9cBtznKeD5eQy4zxeOm+w7nwH3BcJxk30XMOC+UDhusu9CBtwXCcdN9l3EgPti4bjJvosZcF+iIJ9fwoD7UuG4yb5LGXBfJhw32XcZA+6xwnGTfWMZcF+uIL4vZ8B9hXDcZN8VDLjHCcdN9o1jwH2lcNxk35UMuMcLx032jWfAfZVw3GTfVQy4r1aQz69mwH2NcNxk3zUMuK9V4O9rGXBfJxw32XcdA+7rFfj7egbcNwjHTfbdwID7RgX+vpEB903CcZN9NzHgvlk4brLvZgbctwjHTfbdwoD7VgXxfSsD7tuE4yb7bmPAfbsCf9/OgPsO4bjJvjsYcN8pHDfZdycD7rsU8PwuBtx3C8dN9t3NgPseBf6+hwH3vcJxk333MuC+T4G/72PAfb9w3GTf/Qy4HxCOm+x7gAH3g8Jxk30PMuB+SEF8P8SA+2HhuMm+hxlwPyIcN9n3CAPuRxXw/FEG3I8Jx032PcaA+3EF/n6cAfcTwnGTfU8w4H5Sgb+fZMD9lHDcZN9TDLifFo6b7HuaAfczwnGTfc8w4H5WOG6y71kG3M9Jz2vWvucYcD+vIJ8/z4D7BeG4yb4XGHC/KBw32fciA+6XhOMm+15iwP2ygvh+mQH3K8Jxk32vMOB+VThusu9VBtyvCcdN9r3GgPt14bjJvtcZcL+hIK+9wYD7TeG4yb43GXC/JRw32fcWA+63FfD8bQbc7wjHTfa9w4D7XeG4yb53GXC/Jxw32fceA+73heMm+95nwP2BcNxk3wcMuD9UkM8/ZMD9kXDcZN9HDLg/VuDvjxlwfyIcN9n3CQPuTxX4+1MG3J8Jx032fcaA+3MF/v6cAfcXwnGTfV8w4P5Sgb+/ZMD9lXDcZN9XDLi/Fo6b7PuaAfc3wnGTfd8w4P5WOG6y71sG3BOE4yb7JjDg/k5BPv+OAff3wnGTfd8z4P5Bgb9/YMD9o3DcZN+PDLh/UuDvnxhw/ywcN9n3MwPuXxT4+xcG3L8Kx032/cqA+zcF/v6NAffvwnGTfb8z4P5DOG6y7w8G3H8q4PmfDLgnCsdN9k1kwP2XcNxk318MuBsGyuc52YjGPZVw3GTfVAy4+yjwdx8G3H2F4yb7+jLg7iccN9nXjwF3f+G4yb7+DLgbFcR3IwPuJuG4yb4mBtwDhOMm+wYw4G4Wjpvsa2bA3aIgvlsYcLcKx032tTLgblPg7zYG3O3CcZN97Qy4p1bg76kZcA8UjpvsG8iAu0OBvzsYcA8SjpvsG8SAe7ACfw9mwD2NcNxk3zQMuKdV4O9pGXAPEY6b7BvCgHuocNxk31AG3MOE4yb7hjHgnk44brJvOgbc0wvHTfZNz4B7BuG4yb4ZGHDPKBw32TcjA+6ZhOMm+2ZiwD2zcNxk38wMuGcRjpvsm4UB96zCcZN9szLgHi4cN9k3nAH3COG4yb4RDLhnE46b7JuNAffswnGTfbMz4J5DOG6ybw4G3HMKx032zcmAey7huMm+uRhwzy0cN9k3NwPueYTjJvvmYcA9Ujhusm8kA+5RwnGTfaMYcI8WjpvsG82Ae17huMm+eRlwzyccN9k3HwPu+YXjJvvmZ8C9wEDcWP3sGEPKsJc39HwsAPRXub3OQEaDnYH4cQ3QgVy4zcBJEwwal+2lJMfLWBecXDpbn2r8addLJj03kc9lXJNL5jPpUtYv5Equl3f9nFP0nLSfcXMJL+clTb6Q85y8n3NTGT+XLKaNi+RSomws+y8WnGzJyaW8XKZoB3KKjv0m7xVLaTeXLyQd1zfGFJP2/9yin8zm/bTJp+2/nsob+9+F+drNF7LpTMb+lwU/n0yaVNbN+XmTMQQ+WfIyibzJJ6ypiUyq5BZLSSdrJ8PCLNkpSOSLQwJeTjaHyWyuaIfNJ9KJYt4aW3JT6VzW/leFdDGRTuZpflMJt5ROJuy8uU4imSsVkinPybpeIZkcApzDpPBFiexLMsRLSjhusi/FgDstHDfZl2bAnRGOm+zLMOD2hOMm+zwG3FnhuMm+LAPuBYXjJvsWZMC9kHDcZN9CDLgXFo6b7FuYAfciwnGTfYsw4B4jHDfZN4YB96LCcZN9izLgXkw47r/tY8C9uHDcZN/iDLiXEI6b7FuCAfeSwnGTfUsy4F5KOG6ybykG3EsLx032Lc2AexnhuMm+ZRhwLyscN9m3LAPu5YTjJvuWY8C9vHDcZN/yDLhXEI6b7FuBAfeKwnGTfSsy4F5JOG6ybyUG3Csrfam7MtNL3VUGMhq8CsNL3VWFv9Ql3KsOnDTBoHFZbKWXrwmGIFstppe6UV90Irm0+kDci9IwX5tSqVDK+JliKeG6hUwmn0kUUql8oWBfWOfzxj7yvaydAPvUydh/xc2kvYSXKBScvEn7pb9fmK4a8lLXOOlMKp3Nlew/YOfEdYxJFEsli9+O5ydzaSeVT7n5dMJPeyULyxTsDPipjFtKFrOucZPAOVxD+KJE9q3BEC9rCsdN9q3JgHst4bjJvrUYcK8tHDfZtzYD7nWE4yb71mHAva5w3GTfugy41xOOm+xbjwH3+sJxk33rM+DeQDhusm8DBtwbCsdN9m3IgHsj4bjJvo0YcG8sHDfZtzED7k2E4yb7NmHAvalw3GTfpgy4NxOOm+zbjAF3Tjhusi/HgDsvHDfZl2fAXRCOm+wrMOD2heMm+3wG3EXhuMm+IgPuknDcZF+JAffmwnGTfZsz4N5COG6ybwsG3FsKx032bcmAeyulLze3Ynq5ufVARoO3Zni5uY3wl5uEe5uBkyYYNC6LrfQScnWGINs2ppebUV/4Ibm03UDcC8NQX6dKTqmUz+SKhWKqmMiZdD6VdFPJnJcuJvOel/MdP2F/opgvudmi66Yyxv5DqVQi42UKhaK3RsDLyV4Q5zKJZDGfT7jpRNIUSzmTzTuJtPGzJuEU/GQm76bzmaTn2RezvpsuFgv2Ycm+s/UydkZMbg3gHG4vfFEi+7ZniJcdhOMm+3ZgwL2jcNxk344MuHcSjpvs24kB987CcZN9OzPg3kU4brJvFwbcuwrHTfbtyoB7N+G4yb7dGHDvLhw32bc7A+49hOMm+/ZgwL2ncNxk354MuPcSjpvs24sB997CcZN9ezPg3kc4brJvHwbc+wrHTfbty4B7P+G4yb79GHDvLxw32bc/A+4DhOMm+w5gwH2gcNxk34EMuA8SjpvsO4gB98HCcZN9BzPgPkQ4brLvEAbchwrHTfYdyoD7MKUv+Q5jesl3+EBGgw9neMl3hPCXfIT7iIGTJhg0Lout9DJuO4YgOzKml3xRX3whuXTUQNyLszBf2zeVyZyby6fsjyZLqUzCvtc09p9wSvZ1JhmT8FN+Lusk84l0MlvKu5l8wUnkHfr3SvlcZvuAl5PNYSFbyuULGS+Z8lOOhZlyi27OSWRMwU6IKZlkquj4ec8tehZONm0Kbqpkign7yjRPE7Q9cA6PFr4okX1HM8TLMcJxk33HMOA+Vjhusu9YBtzHCcdN9h3HgPt44bjJvuMZcJ8gHDfZdwID7hOF4yb7TmTAfZJw3GTfSQy4TxaOm+w7mQH3KcJxk32nMOA+VThusu9UBtynCcdN9p3GgPt04bjJvtMZcJ8hHDfZdwYD7jOF4yb7zmTAfZZw3GTfWQy4zxaOm+w7mwH3OcJxk33nMOA+Vzhusu9cBtznCcdN9p3HgPt84bjJvvMZcF8gHDfZdwED7guVvuy6kOll10UDGQ2+iOFl18XCX3YR7osHTppg0LgsttJLqaMYguySmF52RX0BhOTSpQNxL5DCfO0WU4mU45S8dKbg27dkSXpplk6mCqmUn8+4Cd/Yd2uu46XSft7PZIxXzCbzjmcnJlNK2Dd8Rwe8nOxll2ucUjGdSOXyyUIm6du3cPlCKePkC659e5jIptKeY612XNf3s1lTsq8T/WTKSefy9nkq6x8NnMPLhC9KZN9lDPEyVjhusm8sA+7LheMm+y5nwH2FcNxk3xUMuMcJx032jWPAfaVw3GTflQy4xwvHTfaNZ8B9lXDcZN9VDLivFo6b7LuaAfc1wnGTfdcw4L5WOG6y71oG3NcJx032XceA+3rhuMm+6xlw3yAcN9l3AwPuG4XjJvtuZMB9k3DcZN9NDLhvFo6b7LuZAfctwnGTfbcw4L5VOG6y71YG3LcJx0323caA+3bhuMm+2xlw36H0pc8dTC997hzIaPCdDC997hL+0odw3zVw0gSDxmWxlV7OXMoQZHfH9dIn4osQJJfuGYh7kRLma2tE3pTcgltKeAVrVTGXK2XSpVIplXP8dDKTKJhsIZtM2JdKOS/pp7L2HzaZhJ/0i+l83kteFvCyeg5Nzs+6pWTaDu752ZydyJxTKFrc+aLjuSZVLJicKTl2orPFYj5vX5Wlfb+YSudck7XzWLwMOIf3Cl+UyL57GeLlvoGycZN91NG47xeOm+y7nwH3A8Jxk30PMOB+UDhusu9BBtwPCcdN9j3EgPth4bjJvocZcD8iHDfZ9wgD7keF4yb7HmXA/Zhw3GTfYwy4HxeOm+x7nAH3E8Jxk31PMOB+Ujhusu9JBtxPCcdN9j3FgPtp4bjJvqcZcD8jHDfZ9wwD7meF4yb7nmXA/Zxw3GTfcwy4nxeOm+x7ngH3C8Jxk30vMOB+caDOlx8vAv1Vbu9LAxkNfmkgftyXgQ7kwv3ywEkTDBqXxVZ6SXEPQ5C9Ak4unW2yjfuILwSQXHp1IO6FQpivjZtJF5IlN5FwUoWEY3G6xYSTy5TyRS+V951CKVEsur6TK6VKJmENMCab8R2/lLCW5PzSvQEvJ5tDv+h7Wc/JFd2875tc0nWthY4dNOuVCl4h5ZVSTiqTKeRSuVShmMi7BS/jealSwXfyKTdxL3AOXxO+KJF9rzHEy+vCcZN9rzPgfkM4brLvDQbcbwrHTfa9yYD7LeG4yb63GHC/LRw32fc2A+53hOMm+95hwP2ucNxk37sMuN8Tjpvse48B9/vCcZN97zPg/kA4brLvAwbcHwrHTfZ9yID7I+G4yb6PGHB/LBw32fcxA+5PhOMm+z5hwP2pcNxk36cMuD8Tjpvs+4wB9+fCcZN9nzPg/kI4brLvCwbcXyp9CfAl00uArwYyGvwVw0uAr4W/BCDcXw+cNMGgcVlspc36VxmC7Ju4XgJE3BhHcunbgbiN9VBf51L2vYFv/IzrFkqFdJZ+u02uVMjQi49UKpvJWxPtv5L1C4VEvmR/Nmv/spjLFgp28Fz+tYCX1XPopo2b8nPGyTlF30kn3EzK8XL5nJP2jZ3MRK6QNmn72M8X/UQyW0olLBo/l00lEomMl8q8BpzDCcIXJbJvAkO8fCccN9n3HQPu74XjJvu+Z8D9g3DcZN8PDLh/FI6b7PuRAfdPwnGTfT8x4P5ZOG6y72cG3L8Ix032/cKA+1fhuMm+Xxlw/yYcN9n3GwPu34XjJvt+Z8D9h3DcZN8fDLj/FI6b7PuTAfdE4bjJvokMuP8Sjpvs+4sBd0OHbNxkH3U07qmE4yb7pmLA3Uc4brKvDwPuvh06N8P7Av1Vbm+/DkaD+3Xgx+0PdCAX7v4dkyYYNC6LrbRp/S3DYtIITi6drXojN+oGMZJLTR24DeZQXxedRDqTLNrN85Sf8jPpdMHPu3b3P1eyrwGSmVKmaLKOky6l066bTaWLmUIyWzBJr1hwsolkijZxCe9km+Fu2rGwk14ymbeb827KeG42kUpk014xmTUp+57BTXlJ4yVSmWQmYTfvjW9ntpQ2iVK6kPcnADfDBwhflMi+AQyLUrNw3GRfMwPuFuG4yb4WBtytwnGTfa0MuNuE4yb72hhwtwvHTfa1M+CeWjhusm9qBtwDheMm+wYy4O4Qjpvs62DAPUg4brJvEAPuwcJxk32DGXBPIxw32TcNA+5pheMm+6ZlwD1EOG6ybwgD7qHCcZN9QxlwDxOOm+wbxoB7OuG4yb7pGHBPr3RTeHqmTeEZOhgNnoFhU3hG4ZvChHvGjkkTDBqXxVbavG1iCLKZ4toUjrhRiuTSzB24jdYwX5u0l86aQiKXziVTdqBUIVksFPO5Qr6QKeWcUtotJFKlZDZt/yJr95rtHng+kSpaMxJuouS6AwJeVs+hyfq+NbKUyHl+Ml0wqYJjMulSPp/KZ1PFpF9IZRzPK5WsaUnf5H0vWUjnS7lUxi/4BeuAAcA5nEX4okT2zcIQL7MKx032zcqAe7hw3GTfcAbcI4TjJvtGMOCeTThusm82BtyzC8dN9s3OgHsO4bjJvjkYcM8pHDfZNycD7rmE4yb75mLAPbdw3GTf3Ay45xGOm+ybhwH3SOG4yb6RDLhHCcdN9o1iwD1aOG6ybzQD7nmF4yb75mXAPZ9w3GTffAy451e6OTo/0+boAh2MBi/AsDnqCN8cJdxOx6QJBo3LYittYs7MEGQmps3RqBuGSC65HbgNxzBfGzuQ63iZRDZlf9BN2/+ylPeKpWwu49rN35yF5JTy2ZKbsDhKXsIU7I9ayK7JOLmM8WcJeDnZHOZLnuvbScv4mWTWsTNmbSsU7EayU0wbu8mcMm6xkLNby6mUa5yim0kX7Xx4haJXSnnF1CzAOUwIX5TIvgRDvCSF4yb7kgy4U8Jxk30pBtxp4bjJvjQD7oxw3GRfhgG3Jxw32ecx4M4Kx032ZRlwLygcN9m3IAPuhYTjJvsWYsC9sHDcZN/CDLgXEY6b7FuEAfcY4bjJvjEMuBcVjpvsW5QB92LCcf9tHwPuxYXjJvsWZ8C9hNJNwiWYNgmX7GA0eEmGTcKlhG8SEu6lOiZNMGhcFltpM89lCLKl49okjLhxhuTSMh24jbcwX7ulTCprR/QyuVLeLSZTiXzKS5c8uxdayuRTRWPSec9z7aBesuSaRMbNlNLZkjEp+5OFZD4R8LLPZBwqFvNuIZ/KeqboJ1PpZDaXL+b9ouMZv2A3MtMFL+0Yv5hMJDPFjO+btOvlc66fyxWSiXwmAZzDZYUvSmTfsgzxspxw3GTfcgy4lxeOm+xbngH3CsJxk30rMOBeUThusm9FBtwrCcdN9q3EgHtl4bjJvpUZcK8iHDfZtwoD7lWF4yb7VmXAvZpw3GTfagy4VxeOm+xbnQH3GsJxk31rMOBeUzhusm9NBtxrCcdN9q3FgHttpZtlazNtlq3TwWjwOgybZesK3ywj3Ot2TJpg0LgsttKm1jIMQbZeTJtlUTeQkFxavwO3ARXq60TSy3lOwssUS4VE1sunfTojWDCZbMoteL6bdrL5osknvFzCtxuI2VzOzxay6ZzxsybhZJYNeDnZHPomn0unLZSktS1rHJOx/yvl0tliwc37juO6Ofs/P2lnLec42Rzd0/ZKfrLopouFUn5Z4BxuIHxRIvs2YIiXDYXjJvs2ZMC9kXDcZN9GDLg3Fo6b7NuYAfcmwnGTfZsw4N5UOG6yb1MG3JsJx032bcaAOyccN9mXY8CdF46b7Msz4C4Ix032FRhw+8Jxk30+A+6icNxkX5EBd0k4brKvxIB7c6WbRpszbRpt0cFo8BYMm0ZbCt80ItxbdkyaYNC4LLbS5s76DEG2VUybRlE3UpBc2roDtxET6mu34Jc815hEKpPP57xs1ibJRKmYSeSSdsssmbEgc9l0xrE7VYUUfZvIlBK+8YpeImsy/gYBLyffNMqmU+mUKfh+tpj0jCkliymT9xzfL+Ts7OaT1rpi0WSSrpPLFdM5u7NlyxA3bTKFdNFLbQCcw22EL0pk3zYM8bKtcNxk37YMuLcTjpvs244B9/bCcZN92zPg3kE4brJvBwbcOwrHTfbtyIB7J+G4yb6dGHDvLBw32bczA+5dhOMm+3ZhwL2rcNxk364MuHcTjpvs240B9+7CcZN9uzPg3kPp5skeTJsne3YwGrwnw+bJXsI3Twj3Xh2TJhg0LouttMmxNUOQ7R3X5knEDQUkl/bpwG1IhPnaLZWSuYSbdb1CpmQKmbyXcFO5YtHxCsWSKZpUymRKyXSqmLdfLIRSNuHbnZl0KpmkX4nrbhPwcrI5dNKlXD5p8aaz1hSXXlQUcwUv4+XddDqT9xMmX0oUXa+YsNs9mXQyl6Mf9rP5vG//rmLDI+oc7it8USL79mWIl/2E4yb79mPAvb9w3GTf/gy4DxCOm+w7gAH3gcJxk30HMuA+SDhusu8gBtwHC8dN9h3MgPsQ4bjJvkMYcB8qHDfZdygD7sOE4yb7DmPAfbhw3GTf4Qy4j1C6iXAE0ybCkR2MBh/JsIlwlPBNBMJ9VMekCQaNy2Irif19GILs6Jg2EaIKaySXjunACfMwX7uZhJvx/IKTsNsNJZPLpzNuJpV0vaSbtsgTeZN0M0XPOLl8yk/6npvJ5jzHNcVS3nfzBW/fgJeTbSJkE/QrCtN+0S35xilZU33fySRKdqayTi6bSZdMOluwX5yEtS9rCslMJpWxmJKun0zk9gXO4bHCFyWy71iGeDlOOG6y7zgG3McLx032Hc+A+wThuMm+ExhwnygcN9l3IgPuk4TjJvtOYsB9snDcZN/JDLhPEY6b7DuFAfepwnGTfacy4D5NOG6y7zQG3KcrFdOnM4npMzoYDT6DQUyfKVxME+4zOyZNMGhcFltJ9B7DEGRnxSWmIwpMJJfO7sAJ1DBfu1aOG69YTGbShWy+VHSS9Nup/KJfSOZLuWI+XcpYSFaJp9xkplRIZxJ+JlvI5jLZdMo37t9C9cwwMe1mcomUl8xmCxawm88n7ZOSn8mlEqmUnzF5r2DcgslkktlkySnkfMfJpbySxZDNucWieyxwDs8RviiRfecwxMu5wnGTfecy4D5POG6y7zwG3OcLx032nc+A+wLhuMm+CxhwXygcN9l3IQPui4TjJvsuYsB9sXDcZN/FDLgvEY6b7LuEAfelSkXlpUyi8rIORoMvYxCVY4WLSsI9VomoJPF3NkOQXR6XqIwotJBcuqIDJ9TCfO1mrfnJvMkYky0V6JeaZI2X9ex/W8oW05lssWhRFb2M7xTTWa+YTpiilyrl3UTCNzmrXs8JeDmZqExb3Zu1xjgmk0u6TjGfL+YL1mbHy2RMMZGgT67MFpyc59uXybm8MaVsNlU09meKqaxxzwHO4TjhixLZN44hXq4Ujpvsu5IB93jhuMm+8Qy4rxKOm+y7igH31cJxk31XM+C+Rjhusu8aBtzXCsdN9l3LgPs64bjJvusYcF+vVFxdzySubuhgNPgGBnF1o3BxRbhvVCKuSARdwRBkN8UlriIKDiSXbu7ACZYwX7smmU6bVKKYS+YyTsHPe1nHWJ2YSxTTKVPMJB0nkS866YyftLaZfD6Xs28BS27OKxVzXiI5LuDlZOKqZKwatS8x0xZ8KZUv2Yl0C07R97N5O1qq6CUcN5c0pULGs8amvGwilynlTNKCS2UKxXHAObxF+KJE9t3CEC+3CsdN9t3KgPs24bjJvtsYcN8uHDfZdzsD7juE4yb77mDAfadw3GTfnQy47xKOm+y7iwH33UpFxt1MIuOeDkaD72EQGfcKFxmE+14lIoPEwM0MQXZfXCIjYuGN5NL9HbjCPczXrpdPeFljEnnjm4KbLGQKOTeVzhfdpH37kysU0hZdqpQ0btrLFNNOJp8sZunNUT6Vo19Rf0vAy8lERibvFFJpK7pM0ks69o2Sl3adZC5bSqRLJWuuyWSTbippzXZKbsIpWGPTJmsy9p/N5DLpW4Bz+IDwRYnse4AhXh4Ujpvse5AB90PCcZN9DzHgflg4brLvYQbcjwjHTfY9woD7UeG4yb5HGXA/prTYfoyp2H68g9HgxxmK7SeEF9uE+wklxTYVxfczBNmTcRXbEQtQJJee6sAVsGG+NtmMb5xMKmEVRDZt/+DZwZImm826nq3SfSeX9rJuMVFwCxk3ad8kpP1Ezr7NSKTSbjFT+rtQfCKk2DZWECT8kp+jT9LIZo1fShWK9nWEffeRtRgd4xfyqVQ6mU+XaIKzWft6xIqCQj6X9e3UmAeAc/i08EWJ7HuaIV6eEY6b7HuGAfezwnGTfc8y4H5OOG6y7zkG3M8Lx032Pc+A+wWlRecLTEXnix2MBr/IUHS+JLzoJNwvKSk6qTh8iiHIXo6p6IxaiCG59EoHrpAL87UpJAsJW1Lb8jWbdVJ299hJpHNJJ5Gxj3PpXNF4vvHdZMr17cC+LbOThVLOK/rFjFPyC97TAS8nm8Ok/ReTST+VdzynVMhR7e7nM+lkNm/tt/alc+lC3k266WLCTeaLfj6btHVzyhiv5LiJ3NPAOXxV+KJE9r3KEC+vCcdN9r3GgPt14bjJvtcZcL8hHDfZ9wYD7jeVFl9vMhVfb3UwGvwWQ/H1tvDii3C/raT4oiLpFYYgeyeu4itiQYLk0rsduIImzNduOlsy+VzB7iWm7XZixjW+56Zy2QSdBU7Znc+CyZuEWyilXbubmaF9RrvFmHTyyWSu6CfcVwNeTvZ6PVtI2f8sbfHnswmfjkV7ruP4yUzBybu5bLZgJ5F+iU/CKxbtzmqiWPST9j9J5PMp4/oVBVPUOXxP+KJE9r3HEC/vC8dN9r3PgPsD4bjJvg8YcH+otAj5kKkI+aiD0eCPGIqQj4UXIYT7YyVFCBUL7zIE2SdxvXaMuDAjufRpB25hD/W13UWy+JxCLp0qOrZsydt/P51xigVbddnNLq9YSBUL6UzaTecyyZLd+SoUivmC/Q9K1uJS5r2Al5PNoXE8176tNbYsypeSRVNIF+002a0q3085XiGbTfsl+2/Zd6LFUj7r5Y1JWXy2fLITlnby7wHn8DPhixLZ9xlDvHwuHDfZ9zkD7i+ULsZfMC3GX3YwGvwlw2L8lfDFmHB/pWQxpkXzU4Yg+zqmxTjqAoXk0jcduAUu1NephOPbf9d4Gbt14NDIyVzGSxdzvkln3bSf8mk4a23OTae9dK6USia9pH0blXRzxnM/C3g52WKcTyQyvjXRVi7JkusWCxZg0S1l7QhF+3Yr5abdTCKdLnkm4+QcW8t4dlcjmbN1jp8qehULaNQ5/Fb4okT2fcsQLxOULkoTmBal7zoYDf6OYVH6XviiRLi/V7Io0eLxDUOQ/RDXohQxUSO59GMHLtF3x9f5RCHpZ7J+0uSyJpPyCvlktpBImUzBLmvJXMq1K2/JuIm045UK2ULh24CXfbrwtZP08umiscB8L2nsFBSKOTdZSpd8a3G+WHATxnWSGTtqxr4TSKS/Bc7hT0qT809MyfnnDkaDf2ZIzr8IT86E+xclyZmS6I8MyfnXuJJzVetpwkJy6bcOXMIL8zXCJ78x+Pr38nenXsK1qw79nOc7JukXXM91/XzSsdupBbeYTZpsKekmEwW/kLdj5kzJKeUK2ZL3z1hxJtTfmRLqHx2MBv/BkFD/FJ5QCfefDAmVyNbUMCmphLXOfysqsTnmpTOg0fNSTuaJZXyDZ44/cRFoyLa+gY2dRpODBzRUZhMtTign5V+d4w+y9nM4YSJDVpnIvPmDwt1VSdHDVoE7qo1TDZJdPhIxyUa0b/oMwmazzsRA4x4QjIuei7+Dk2Eu+jLNRV/GueAqNfsNkp1TuOJh0WH/r7gLXdjHxv3FhsnOf4SZOIleQ4D+Nsg5pIKquaF7FXNXY3XJqbLGsW6h5qS8uOw/aArVshOtmamYFoJyo3tos+ny3xlUOX7nuFETwxLgxNDZ+vXQZz0p4KJibhwkM8EgfVHOy8ayAqW3/ulqzpH+aSobyyQSNjb8jCn5pUQqk3XzJk3vYpKlTNpL+vYVUc7PFE0yl3CzdJ2BflFUJpWgX+Wb9QvpUnnSNn4ikfSz+YKxr3RyecfzEzmnlMwkXCfn21dAfsJLp3OJhJ/2Sl7W7krkSgnPSWUyWSftJrIul3+aQvzT04Wwq20TpH8GMOXPAYB56Gp7CTkPzUzz0BzMw5SKBMkLeYi5OB6XjdmisUhoYS4SWhiKhCVjKhK6Uk9xJrlW4FjIImFJpkWotRtFQlfzYAlqCsYpOVm7ojqZQjqTz/pu3rPraCmV8BNI/7QNwi3syCKByz9tEXaZuoqbzh3cvth47Mn7sC7HQu4Gtw/CLkidPmqP4KOuCpde+qjLmOzJO8uuxkL6aOpBwKKvzEdTlxVX1a+0Gnrpu67MQ+62lheDAwf987Uj7HWWE62ZWq91kO8qo44FfDUW+lE/TrRmehu0/19zGHWsQYNk+4MCZhBDgTyYSSwMZny11ME0F9MwzcU0U5iLqDZz8WJp4a+buDiwjPDXTf0C3OjXTUB/m2Xqr5uq29/5GzUn5YXftJw7SYOYEuK0jDtJZPO0DIlhWSWvmwYBdyqGDJKZYJZl2qkYEsPrJqR/hgJfNy0D3Eni8s/QbrxeaOihv7pzarezaVkUhmlcFIYxLwrDGBaF5YQsCjVJnCn93ZBJZzqhi8JyTElnOsCi0NU2H9I/0wtdFLj8M33ZohDXvaHybdGI10JMub0zDGI0eIYQ2RjV+BmAyWBGYBBwzeGMIYtI1DmcUfgJ/0EBbvRWMDLpIbkzE3gruLOhX0f0A2KeWfip+locdKI1ZDELzV+zgP2B3i4k7gFtNBRzMzMU6LOCxQq9d+3kIP15pO0Tg+/p35qInee//80+Zf/ele2T/r3xwffD7b87wvbZOouHsp9H+nw24FxSsTasbC457R4OjqXqhhnb5RvbTNodoK/Dg+9nt/Myh+1z2j6X7XPbPo/tI20fZfto2+e1fT7b57d9Adsd243tru0J25O2p2xP256x3bM9a/uCti9k+8K2L2L7GNsXJT/YvrjtSwwKjOms4smYAVXP5gh5NmfIs7lCns0d8myekGcjQ56NCnk2OuTZvCHP5gt5Nn/IswVCnjkhz0zIMzfkWSLkWTLkWSrkWTrkWSbkmRfyLBvybMGQZwuFPFs45NkiIc/GhDxbNOTZYiHPFg95tkTwrLyNCL4uFnx1orWKpBN1EZsdMFbx730gx8wBGoswzgkZ65/5miv6WG7ne7y5o46VnPROcJ5oYznl7xdHRhnLrXxXOar3YznV7z1H93Isu0k02TvUeXs3lhf2Pna+3ozlhb/bnb/nY2VqvSdeoKdjZWq/c3Z6NpY7pffXpidjZab8Ltzt/lhdntVIdHesTJe50CS7N5bTjbxqUt0Zy+lWjjbprsdKdTPfm0xXYyW7vXYYb4pj0SfYdn+s7JTGyvRoTTML1h7L6+H6aBaqMVa21OO11iwcPpbTi3XbLBI2ltOrGsCMmXws08t6wixaPZbf69rELFY5ViJCnWMWLxvLLUWqmcwSQNFHdeO8DZOE0xKBiFksEDVjApGzcCB6FgxEkBeIonQgkpKBaHIDEeUEomr+QGTNG4iuUYEImycQZXMFIo1qN6oFqcX5tmMJWP3pV7ztWHIQo8E0OGrHtdP4JXGkMksBBQLXHJKNqB25zjlcChiYFARDG+K5ZopLKD7rTk/5XCwdBNgy1bstSweOLX+2TIgqRm+34zKJY5YGBtAyYOeiyUdBszQwGP895Q0OxrhWpMVhPMr65fYuO4jR4GXhK1LWXxa4Ii0nfEWiOVwOviJl/eWUrkiLw+zOFkLMZVmRlg8CbIXqFWn5kBVphRhWpMWBK9LywABagcm56EMISMwrApNZQwN+tVwqSEDol+lIKbASMJmFzaETrRny8UoMlcxKSiuZxWD5J58ot3flQYwGrwyvZPKJlYHBv4rwSobmcBV4JZNPrMIc/IgEupLwBLoqeA47G3rhRXJ8NWDsxVkBLwazO++GmMtSAa8eJOY1qivg1UMq4DViqIBxK5BjVgeScg0m56IDEYl5TeYK2InWDCXH1Riqt7WEV63kl7UU4Obi+FpAjq8tnOO1ihRE8YMaax3wgh2X2lkUttZ4pXJ71x3EaPC6cLXjldYFOnA94WqH5nA9uNrxSusJVzuU6NYZJDsZrw9Oxp0NjRnJ8Q2Uqp1FYXZ7xRBzWdTOhkFi3qha7WwYonY2ikHt4FYgx2wIJOVGTM5FByIS88bCK0FKjhswVP2bCFc75JdNFODm4vgmQI5vKpzjtYoUJ1ozyCJlM6XvdsbA1hq34uN9coMYDc7B1Y7r5IBBkBeudmgO83C14zp54WqHEt1mg2Qn44IStYPkuK9U7YyB2W1KIeayqJ1ikJhL1WqnGKJ2SjGoHdwK5JgikJQlJueiAxGJeXPhlSAlR5+h6t9CuNohv2yhADcXx7cAcnxL4RyvVaQ40ZpBFilbKVU7i8DWGr9C7Ww9iNHgreFqx3e2BgbBNsLVDs3hNnC14zvbCFc7lOi2GiQ7GW+rRO0gOb6dUrWzCMzuQmxqZ/sgMe9QrXa2D1E7O8SgdnArkGO2B5JyBybnogMRiXlH4ZUgJcftGKr+nYSrHfLLTgpwc3F8JyDHdxbO8VpFihOtGWSRsotStbMwbK1JV3wmxq6DGA3eFa520mZXYBDsJlzt0BzuBlc76QrcTsQWhhuR6HYZJDsZ765E7SA5vodStbMwzO50bJ+lsmeQmPeqVjt7hqidvWJQO7gVyDF7Akm5F5Nz0YGIxLy38EqQkuMeDFX/PsLVDvllHwW4uTi+D5Dj+wrneK0ixYnWDLJI2U+p2lkI927HK7d3/0GMBu+Pf7fj7Q8MggOEqx2awwPw73a8A4SrHUp0+w2SnYwPVKJ2kBw/SKnaWQhmt58JMZdF7RwcJOZDqtXOwSFq55AY1A5uBXLMwUBSHsLkXHQgIjEfKrwSpOR4EEPVf5hwtUN+OUwBbi6OHwbk+OHCOV6rSHGiNYMsUo5QqnYWhK01yWy5vUcOYjT4SLjaSWaPBAbBUcLVDs3hUXC1k8weJVztUKI7YpDsZHy0ErWD5PgxStXOgjC7k16IuSxq59ggMR9XrXaODVE7x8WgdnArkGOOBZLyOCbnogMRifl44ZUgJcdjGKr+E4SrHfLLCQpwc3H8BCDHTxTO8VpFihOtGWSRcpJStZOFrTX5ipNsJw9iNPhkuNrJm5OBQXCKcLVDc3gKXO3kK3A7EVsYbkSiO2mQ7GR8qhK1g+T4aUrVThZmdz62k2ynB4n5jGq1c3qI2jkjBrWDW4EcczqQlGcwORcdiEjMZwqvBCk5nsZQ9Z8lXO2QX85SgJuL42cBOX62cI7XKlKcaM0gi5RzlKodD6d2CuX2njuI0eBz8WqncC4wCM4TrnZoDs/Dq53CecLVDiW6cwbJTsbnK1E7SI5foFTteLiCOB9iLovauTBIzBdVq50LQ9TORTGoHdwK5JgLgaS8iMm56EBEYr5YeCVIyfEChqr/EuFqh/xyiQLcXBy/BMjxS4VzvFaR4kRrBlmkXKZU7WRwJ9ny5faOHcRo8Fj8Sbb8WGAQXC5c7dAcXo4/yZa/XLjaoUR32SDZyfgKJWoHyfFxStVOBnfYKRdiLovauTJIzOOr1c6VIWpnfAxqB7cCOeZKICnHMzkXHYhIzFcJrwQpOY5jqPqvFq52yC9XK8DNxfGrgRy/RjjHaxUpTrRmkEXKtUrVThq21ngVn0B93SBGg6+Dqx3PuQ4YBNcLVzs0h9fD1Y7nXC9c7VCiu3aQ7GR8gxK1g+T4jUrVThpmdya2T6C+KUjM/8fedcC5UWP98bbsbrLZzaZ3QgIkoc3Y3gZ3EHrvvePdtUMgJJBKAgTTA4QQSAIJvZejc7QP7uCOA67Tez9673fAUe6TwLKf376Rx+snx4LV7/d2x5Lmr6enp6cnjUZzJ57t3EHMdu4swmyHbwRyvTsYlfJOQ43L3RE563xXiXuC0jjebsDrv7vEZzuyXe62oN6mdPxuRh3/vxLXcT8nxS0seJxOyj2WznaaDM127u1nkOF7Dcx27mXsBL8r8dmOlOHvDMx2flfisx1p6O7pV9rG+PeWzHY4dfw+S2c7TRbOdu5PGeY/4NnO/cRs5w9FmO3wjUCudz+jUv7BktkOZ53/WOKeoDSO9xnw+h8o8dmObJcHLKi3KR1/gFHH/1TiOu7npLiFBY/TSXnQ0tlOlG2siWWdyfZQP4MMP8Q+24m1PcTYCR4u8dmOlOHD7LOdWNvDJT7bkYbuwX6lbYz/bMlsh1PH/2LpbCfKxnesaGey/TVlmP+GZzt/JWY7fyvCbIdvBHK9vzIq5d8MNS53R+Ss899L3BOUxvEvBrz+f5T4bEe2yz8sqLcpHf8Ho47/s8R13M9JcQsLHqeT8oils50I32wnCvl9tJ9Bhh/ln+1EH2XsBI+V+GxHyvAx/tlO9LESn+1IQ/dIv9I2xo9bMtvh1PEnLJ3tRPgc4gjBrpHZzpMpw/wUnu08Scx2nirCbIdvBHK9JxmV8ilDjcvdETnr/HSJe4LSOD5hwOt/psRnO7JdnrGg3qZ0/BlGHX+2xHXcz0lxCwsep5PynKWznTDbWNOZ9Wzn+X4GGX6efbbT2fY8Yyd4ocRnO1KGL7DPdjrbXijx2Y40dM/1K21j/KIlsx1OHX/J0tlOmI3vzqI923k5ZZhfwbOdl4nZzitFmO3wjUCu9zKjUr5iqHG5OyJnnV8tcU9QGseXDHj9r5X4bEe2y2sW1NuUjr/GqOP/KnEd93NS3MKCx+mkvG7pbMdjG2s64pDfN/oZZPgN9tlOR/wNxk7wZonPdqQM32Sf7XTE3yzx2Y40dK/3K21j/JYlsx1OHX/b0tmOx8Z3RyfBrpHZzjspw/wunu28Q8x23i3CbIdvBHK9dxiV8l1DjcvdETnr/F6Je4LSOL5twOt/v8RnO7Jd3reg3qZ0/H1GHf+gxHXcz0lxCwsep5PyoaWzHZdtrPGynu181M8gwx+xz3a8to8YO8HHJT7bkTL8mH2247V9XOKzHWnoPuxX2sb4E0tmO5w6/qmlsx2XjW+vaM92PksZ5s/xbOczYrbzeRFmO3wjkOt9xqiUnxtqXO6OyFnnL0rcE5TG8VMDXv+XJT7bke3ypQX1NqXjXzLq+L9LXMf9nBS3sOBxOin/sXS2sz7bWNOeNdv5qp9Bhr9in+20t33F2Am+LvHZjpTh1+yznfa2r0t8tiMN3X/6lbYx/saS2Q6njv/X0tnO+mx8txdttvNtyjB/h2c73xKzne+KMNvhG4Fc71tGpfzOUONyd0TOOn9f4p6gNI7/NeD1/1Disx3ZLj9YUG9TOv4Do47/r8R13M9JcQsLHqeT4jTaOdtZj22saW2F/IYaDTIswXlnO4J5vgb0yhpLe7YjZSh5ZD6BurWs0eygwWHonMbSNsbljbzGWAXuOnPqeAVjnYs521mPbeBsbSHYNTLbqUwZ5qpGJ3tmU9nYdbYjM5me7azHONupZFTKqkYzjcvdETnr3IvZ+HB3OGkcKxr5B4ZqwwOXW1jwZLtUW1BvUzpezajjNSWu435OiltY8DidlFpLZzvrso010azZTu9Ggwz3Zp/tRFt7M3aCPiU+25Ey7MM+24m29inx2Y40dLWNpW2M6yyZ7XDqeF9LZzvrss12okWb7dSnDHMDnu3UE7OdhiLMdtZlnO3UMyplQ6OZxuXuiJx17lfinqA0jn0NeP2NJT7bke3SaEG9Tel4I6OO9y9xHfdzUtzCgsfppAywdLazDttY0+ZBfgc2GmR4IPtsp80byNgJBpX4bEfKcBD7bKctq95ugYGqN4ehG9BY2sZ4sCWzHU4dH2LpbGcdttlOm0uwa2S2MzRlmIfh2c5QYrYzrAiznXUYZztDGZVyWKOZxuXuiJx1Hl7inqA0jkMMeP0jSny2I9tlhAX1NqXjIxh1fGSJ67ifk+IWFjxOJ2WUpbOdtdnGmhYX8ju60SDDo9lnOy3uaMZOsFqJz3akDFdjn+20uKuV+GxHGrpRjaVtjMdYMtvh1PHVLZ3trM0222lOEOwame2MTRnmcXi2M5aY7YwrwmxnbcbZzlhGpRzXaKZxuTsiZ53XKHFPUBrH1Q14/WuW+GxHtsuaFtTblI6vyajja5W4jvs5KW5hweN0UsZbOtuZyHdKQdYJ1BMaDTI8gX220x6fwNgJJpb4bEfKcCL7bKc9PrHEZzvS0I1vLG1jvLYlsx1OHV/H0tnORL4X2Yt2AvW6KcO8Hp7trEvMdtYrwmxnIuNsZ11GpVyv0UzjcndEzjqvX+KeoDSO6xjw+t0Sn+3IdnEtqLcpHXcZddwrcR33c1LcwoLH6aSELZ3tTGAba8JZz3YijQYZjrDPdsJuhLETREt8tiNlGGWf7YTdaInPdqShCzeWtjFusmS2w6njzZbOdibwHVJctGc7LSnD3IpnOy3EbKe1CLOdCYyznRZGpWxtNNO43B2Rs85tJe4JSuPYbMDr36DEZzuyXTawoN6mdHwDRh3fsMR13M9JcQsLHqeT8itLZzvj+caaDsjvrxsNMvxr9tmO2/Frxk6wUYnPdqQMN2Kf7bgdG5X4bEcaul81lrYx3tiS2Q6njk+ydLYznu8w03aCXSOznU1ShnlTPNvZhJjtbFqE2Q7jCORtwqiUmzaaaVzujshZ581K3BP80Tga8Po3L/HZjmyXzS2otykd35xRx7cocR33c1LcwoLH6aRsaelsZy22saY5ayfbVo0GGd6KfbbTHN+KsRNsXeKzHSnDrdlnO83xrUt8tiMN3ZaNpW2Mt7FktsOp49taOttZi++9naLtZNsuZZi3x7Od7YjZzvZFmO2sxTjb2Y5RKbdvNNO43B2Rs847lLgnKI3jtga8/h1LfLYj22VHC+ptSsd3ZNTxnUpcx/2cFLew4HE6KTtbOttZk22s8bLOZNul0SDDu7DPdjxvF8ZOsGuJz3akDHdln+14WfV2CwxUvTkM3c6NpW2Md7NktsOp47tbOttZk28nW9HOZNsjZZj3xLOdPYjZzp5FmO2syTjb2YNRKfdsNNO43B2Rs857lbgnKI3j7ga8/r1LfLYj22VvC+ptSsf3ZtTxfUpcx/2cFLew4HE6KftaOttZg28zRtZ7O/s1GmR4v0Z+3P1LfIYi671/Y0bATLhGZhXSoOzbWNpG7wBLZhWcenmgYUPP0SYHGtDxYhrUcYYM6kGNBhk+yIBBPbjEDaqs98E9BpUNK2aJQeXUy/YSN6iyTdotN6hjGb+KCfntaDTIcIeBztrBqGydJW6cpQw7DUzvO0t8Pd4GQx+3xNBz6niixJdIZJskDPSXySW+DCjtxGRDTpwpvZzMqJeHlLhe+tkzt7DgcdqzKSWu47KNpxiYoHHqYTEdwjHAIfRaI+FwS0Ty1NrpetHOjnBrONzZHnU73FhHON4W9doS0XA00tHZ0S74j3kJNxHraEu0/oQF+T200SDDhxKdoFDmD2Xs/IeVuEMoZXgY0QkKleFhzOv2vZziPGgf08/MYOfwyjdrxjUVtB+7p8LYkB584A+ZzpPnjiDKN7Ubo2MuoU9l7MyHM3YQKFeJm+ymLnhCdh2em3Dbwm7Mbelobmlv6wy3t8YSkURTpDPSXbnmUnZOuU4zJNdpKblKY1TtFH9EdgsM0HhOT43IR8g+aMJgTDXgVk0t8SWG7nYON496F8rjkSXukkvFPNLAdHuGIaMwQ2Ns3cKCd4QhWcw0JIuZBQw8uXg2pRf7DV6lNqUjB3/GdGD/waVtB+TAd6QBW8rY3h6nDKVTUePQMxwnTxnk0imIacJ+c8kEOlizdDMct7DgHWnIIM7SzHBywHi5ypE8zzJgGA5gNgwqVOTZZvk4MoXWeXZjaRoYzraAejkbDNTdbZ9cMudsnzkAy4tERN/obPESnYlIU0tbuN1rjjQ3J6KJlubWaGeiKRrrbIl70Vgk3BZvcRNeazze0hTpaGlOtHV2NCeg0fY6I5FoZ1t7h9cUbo61u62dkZibiLZExOS3M9LS2RlpbW6ORSKdza2J1jYxYRXT4Fa3qaWlzW0OR9rCptpnDphpcg0KuVY2IKYtg8JcGweFuYYHhbkGBoUDS2RQ8FXilh9fyklwGp2jSnRQONCQ0TmKYVDItczH2T7zSnRQMNU+835Gy4/zU8uPR1PLj25hwXftn/M5SKFYjEuZRnYXKBmWWyLDQrGOKfH2kB3mGAMD+7GGnJxjDS6LHm1IFgsMyWKBwWVRU3pxcIkvi5rSgZgFy6LHGFgWZWxvL9azLIrDj/abSybQ8TvO5Az4GEMG8TiDM2DJ83EGDEO7JcuixzA6RcnG0jQw7YZmWMkiLItyts/xjDPgGOMM2FT7HE+0D/cGL872OcGQ/TyBQQ65Vmo45XCiITmcGGCZvJQHcoJdNj2GTsJJNjoJJxl2Ek4y4CR0FMlJKHB3LKuRO5kRi9NJ6DA0CJ0cwEkodJctZ/uc0sg3sHM6Caba5xSDqy2bpmbf3MfSbcp2LF2rx6k7p7LZ9tasNpK48hGGHLDXcboGJrmmbSj3mDeivPR5XMjtqJQZ6kxcFZZYC39BnfM0xs5puCN6v+SOeBpnR+yxmOZ4PJ3bYnI/POW1mK0/TgO4LfDpJW2BXVYLfEaPBbaiY5/RY4Fd76hepc/jop6Gcr01qkufxzN7Gsr1FlvQoxb3NJSYClvQUGf1NJTrTbDA9C3paSjXW9uChjq7p6Fcz7PAPT+np6Fcbz0LetTSnoYSz5YtaKhlPQ3lemELGmp5T0O5XtSChjq3p6Fcr9mChjqvp6Fcr9WChlrR01Cut4EFDbWyp6Fc7wkLlpDO72ko1/u1BT3qgp6Gcr2NLWioC3sayvU2saChLuppKNfbzIKGurinoVxvCwsa6pKehnK9rSxoqEt7Gsr1trGgoS7raSjX286Chrq8p6FcbwcLGuqKnoZyvZ0saKgrexrK9XaxoKGu6mko19vNgoa6uqehXG8PCxrqmp6Gcr29LGioa3sayvX2saChrutpKNfbz4KG+g1nQ8kjFuqdzLtlktkxqNHKmCtg6s1ft6DQasfrN4Z4PNMCHhdbwONZFvC4xAIez7aAx3Ms4HGpBTwus4DH5RbweK4FPJ5nAY8rLOBxpQU8nm8BjxdYwOOFFvB4kQU8XmwBj5dYwOOlFvB4mQU8Xm4Bj1dYwOOVFvB4lQU8Xm0Bj9dYwOO1FvB4nQU8/sYAjw4rj5Fmhwg82GHPHHbmq2GyzRpS19cLed8g6EZBNwm6WdAtgm4VdJug3wq6XdAdgu4UdJeguwX9n6B7Gn/CuLcxBarOJJWgq6G4G4i4G4m4m4i4m4m4W4i4W4m424i4e1NxMOT7cQJt8H46YE5hFbLg3eqynguetTBd6KFtv2PiSx6lDdvnd0T7sD6Q8LJ5L1QOv2c0WlAOvyfkwH0gIONDAO/3jDK9z5BM7yuCbt3HKIf7Dcnh/iLoFuPDG+9+Rpn+wZBM/2Bat4Qcri9RORjTI9GfGB+wZT0IK1R+fzSkR38sgo36I6McHjAkhweKYKMYHzp6DzDK9E+GZPqnIujWnxjl8KAhOTxYBN1ifFjsPcgo04cMyfShIox/N5SoHIzpkehPjA/0sx68Fyq/hw3p0cNFsFEPM8rhz4bk8Oci2CjGTQ7enxll+hdDMv1LEXTrL4xy+KshOfy1CLrFuDnF+yujTP9mSKZ/K8L4d2OJysGYHon+xLiBKGujT6Hy+7shPfp7EWzU3xnl8A9DcvhHEWwU46Yq7x+MMv2nIZn+swi69U9GOTxiSA6PFEG3GDfDeY8wyvRRQzJ9tAjj300lKgdjeiT6E+OGxayNhYXK7zFDevRYEWzUY4xyeNyQHB4vgo1i3MTpPc4o0ycMyfSJIujWE4xyeNKQHJ4sgm4xbr71nmSU6VOGZPpUEca/m0tUDsb0SPQnxg3SWRuZC5Xf04b06Oki2KinGeXwjCE5PFMEG8W4adx7hlGmzxqS6bNF0K1nGeXwnCE5PFcE3WLc7O89xyjT5w3J9PkijH+3lKgcjOmR6E+ML2RkvThRqPxeMKRHLxTBRr3AKIcXDcnhxSLYKMaXVLwXGWX6kiGZvlQE3XqJUQ4vG5LDy0XQLcaXi7yXGWX6iiGZvlKE8e/WEpWDMT0S/YnxBbCsF7UKld+rhvTo1SLYqFcZ5fCaITm8VgQbxfhSnPcao0z/ZUim/yqCbv2LUQ6vG5LD60XQLcaXGb3XGWX6hiGZvlGE8e+2EpUDrHOIuc6/Zahze+wnLJN83m6JPO+whM87LeHzLkv4vNsSPv/PEj7vYeRTvn8tX0qHh5I2ONmBm//rDciZm8cbLODxRgt4vMkCHm+2gMdbLODxVgt4vM2QjefgMdLcagTXFL89uD8vXD7scNggtqdsAvRV3hT9+i1Bbwt6R9C7gt4T9L6gDwR9KOgjQR8L+kTQp4I+E/S5oC8aneyDat5s7Hp4zVtE3NtE3DtE3LtE3HtE3PtE3AdE3OdE3BepOOnQDXIyCwAwcBvTDxtLXhk9+QfK4svGn/7/Gze6TMCeL/fK1IcMKwrydCKJ9SXjisy/LZn52MLnR5bw+bElfH5iCZ+fWsLnZ5bwyWEv29t+9KqzVmDx6nih9pNxRcN701DbcNeZcYXEe8uSOjOuuHhvW1JnxhUc7x1L6sy4IuS9a0mdGVeYvPcsqTPjipX3viV1ZlwB8z4oUp3d7gVPXXzOOFf6j6Gn+BCXWQ4qeF8wtv1/mOayiXiiDdY5xKzvXzPUmVqZ5ebzGwY+m2NuW7y5ucUkn/9l4LO9vbklFm9tMsnntxzt3tEcT0Rawib5/I6Bz1hTNJFoisRM8vk9A59NnhtvCrckTPL5AwOfbe1uU3Nra4dJPv/HwKeXaI10tsXaTfLp9Gdo9/a429HptUne+jtdT6uHp9TD0+nhqfTwNHp4Cj08fR6eOv81uB5R3v1ruNj+Bbj+Blz/F1x/C66/A9ffg+sfwPX/wLUUzo/X4n+ZoHJBFYIqBVUJ6iWouv9Pi/yDncz6tK793cKCF+rvGPHxHF4+o8awvZ/8NCVb9cWCGiGXWkG9BfVRSq2cOZlYjeJqibjeRFyfVBwMlbzCymrUQg1ETX8mRzDherVMWLKOvVmwfpJXH8ZOUMzOW9bTecnOWyfk0ldQvaAG3HnriE7Zl4irJ+IaitB5yxg7bx1j5+3L2HnrGTtvg6Wdt7yn85Kdt5+QS6Og/oIG4M7bj+iUjURcfyJuQBE6bzlj5+3H2HkbGTtvf8bOO8DSzlvR03nJzjtQyGWQoMGChuDOO5DolIOIuMFE3JAidN4Kxs47kLHzDmLsvIMZO+8QSztvZU/nJTvvUCGXYYKGCxqBO+9QolMOI+KGE3EjitB5Kxk771DGzjuMsfMOZ+y8IyztvFU9nZfsvCOFXEYJGi0XGXHnHUl0ylFE3GgibrUidN4qxs47krHzjmLsvKMZO+9qlnbeXj2dl+y8Y4RcVhc0VtA43HnHEJ1ydSJuLBE3rgidtxdj5x3D2HlXZ+y8Yxk77zhLO291T+clO+8aQi5rClpL0HjcedcgOuWaRNxaRNz4InTeasbOuwZj512TsfOuxdh5xzN2AqVMlzrMiipCdQ9eD14PXg9eD14PXg9eD14PXsnjSX/wxurMPOAGcH09uP4NuL4OXF8Lrq8B11eD66vA9ZXg+gpwfTm4vgxcXwquLwHXF4Pri8D1heD6AnB9PrheCa5XgOvzwPW54Ho5uF4GrpeC63PA9dngegm4PgtcLwbXX9Zkrr8A15+D68/A9afg+hNw/TG4/ghcfwiuPwDX74Pr98D1u+D6HXD9Nrh+C1y/Ca7fANevg+t/gevXwPWr4PoVcP0yuH4JXL8Irl8A18+D6+fA9bPg+hlw/TS43rB35noDcN0GrlvBdQu4bgbXTeA6Cq4j4DoMrj1w7YLr9cH1euB6XXC9DrheG1xPBNcTwPV4cL0WuF4TXK8BrseB67HgenVwPQZcrwauR4PrUeB6JLgeAa5P6JO5Ph5cJ8H1ceB6Abg+FlwfA66PBtfzwfU8cH0UuJ4LrueA69ngeha4ngmuZ4DrI8H1EeB6OrieBq4PB9dTwfVh4PpQcD0FXB8CrieD6wS4joPrTnDdAa5HgHUg+CgVPmqFj2JXA9fw6Q18ugOf/owD13DBGC4owwXn8eAarlHBNSy4xtUHXMPtz3B7NNw+3QCu4Y5LuCMT7tgcAK7hJi+4CQxuEhsCruG+ErjvRO1LucX5KUwQvycKWlvQOoLWFbSeoPUFuYI8QWFBEUFRQU2CmgW1CGoV1CZoA0EbCvqVoF8L2kjQxnLtSNAmgjYVtJmgzQVtIWhLQVsJ2lrQNoK2FbSdoO0F7SBoR0E7CdpZ0C6CdhW0m6DdBe0haE9BewnaW9A+gvYVtJ+g/QUdIOhAQQcJOlhQTFC7oA5BnYLighKCJgs6RNAUQYcKOkzQVEGHC5omaLqgIwQdKWiGoJmCZgmaLWiOoLmCjhI0T9B8QUcLOkbQsYIWCDpOUFLQ8YJOEHSioJMEnSzoFEGnCloo6DRBpws6Q9AiQWcKWizoLEFLBJ0t6BxBSwUtE7Rc0LmCzhO0QtBKQecLukDQhYIuEnSxoEsEXSroMkGXC7pC0JWCrhJ0taBrBF0r6DpBvxF0vaAbBN0o6CZBNwu6RdCtgm4T9FtBtwu6Q9Cdgu4SdLeg/xN0j6B7Bf1O0O8F3SfofkF/EPRHQQ8I+pOgBwU9JOhhQX8W9BdBfxX0N0F/F/QPQf8U9IigRwU9JuhxQU8IelLQU4KeFvSMoGcFPdf/J52WoczJhEmp/26BoZoVr93tsXur3u6pc7GeF79fEPSioJcEvSzoFUGvCnpN0L8EvS7oDUFvCnpL0NuC3hH0bv+fHoj0AzoXAv+HpK7fE/neF/SBoA8FfSToY0GfCPpU0GeCPhf0haAvBf1b0H8EfSXoa0HfCPqvoG8FfSfoe0E/CPpffymkVGHpU9hAZdOnsBFxHxBxHxJxHxFxHxNxnxBxnxJxnxFxnxNxXxBxXxJx/ybi/kPEfUXEfU3EfUPE/ZeI+5aI+46I+56I+4GI+x8RJxtXxkklSx3yllYu9X+0uhZ5ywSVC6oQVCmoSlAviSGoRlCtoN6C+giqE9RXUL2gBkH9BDUK6i9ogKCBggYJGixoiKChgoYJGi5ohKCRgkYJGo0VMDSga0XKiLhyIq6CiKsk4qqIuF5EXDURV0PE1RJxvYm4PkRcHRHXl4irJ+IaiLh+RFwjEdefiBtAxA0k4gYRcYOJuCFE3FAibhgRN5yIG0HEjSTiRhFxo/PoDKuJvGMErS5orKBxgtYQtKagtQSNFzRB0ERBawtaR9C6gtYTtL4gV5AnKCwoIigqqElQs6AWQa2C2gRtIGhDQb8S9GtBG+HOsBpRkTFE3OpE3FgibhwRtwYRtyYRtxYRN56Im0DETSTi1ibi1iHi1iXi1iPi1ifiXCLOI+LCRFyEiIsScU1EXDMR10LEtRJxbUTcBkTchkTcr4i4XxNxG+XRGTYWeScJ2kTQpoI2E7S5oC0EbSloK0FbC9pG0LaCthO0vaAdBO0oaCdBOwvaRdCugnYTtLugPQTtKWgvQXsL2kfQvoL2E7S/oANwZ9iYqMgkIm4TIm5TIm4zIm5zIm4LIm5LIm4rIm5rIm4bIm5bIm47Im57Im4HIm5HIm4nIm5nIm4XIm5XIm43Im53Im4PIm5PIm4vIm5vIm4fIm5fIm4/Im5/Iu6APDrDgSLvQYIOFhQT1C6oQ1CnoLighKDJgg4RNEXQoYIOEzRV0OGCpgmaLugIQUcKmiFopqBZgmYLmiNorqCjBM0TNF/Q0YKOwZ3hQKIiBxFxBxNxMSKunYjrIOI6ibg4EZcg4iYTcYcQcVOIuEOJuMOIuKlE3OFE3DQibjoRdwQRdyQRN4OIm0nEzSLiZhNxc4i4uUTcUUTcPCJuPhF3NBF3TB6d4ViRd4Gg4wQlBR0v6ARBJwo6SdDJgk4RdKqghYJOE3S6oDMELRJ0pqDFgs4StETQ2YLOEbRU0DJBywWdK+g8QSsErRR0vqALcGc4lqjIAiLuOCIuScQdT8SdQMSdSMSdRMSdTMSdQsSdSsQtJOJOI+JOJ+LOIOIWEXFnEnGLibiziLglRNzZRNw5RNxSIm4ZEbeciDuXiDuPiFtBxK0k4s4n4i7IozNcKPJeJOhiQZcIulTQZYIuF3SFoCsFXSXoakHXCLpW0HWCfiPoekE3CLpR0E2CbhZ0i6BbBd0m6LeCbhd0h6A7Bd0l6G5B/yfoHtwZLiQqchERdzERdwkRdykRdxkRdzkRdwURdyURdxURdzURdw0Rdy0Rdx0R9xsi7noi7gYi7kYi7iYi7mYi7hYi7lYi7jYi7rdE3O1E3B1E3J1E3F1E3N1E3P8Rcffk0RnuFXl/J+j3gu4TdL+gPwj6o6AHBP1J0IOCHhL0sKA/C/qLoL8K+pugvwv6h6B/CnpE0KOCHhP0uKAnBD0p6ClBTwt6RtCzgp4T9DzuDPcSFfkdEfd7Iu4+Iu5+Iu4PRNwfibgHiLg/EXEPEnEPEXEPE3F/JuL+QsT9lYj7GxH3dyLuH0TcP4m4R4i4R4m4x4i4x4m4J4i4J4m4p4i4p4m4Z4i4Z4m454i45/PoDC+IvC8KeknQy4JeEfSqoNcE/UvQ64LeEPSmoLcEvS3oHUHvCnpP0PuCPhD0oaCPBH0s6BNBnwr6TNDngr4Q9KWgfwv6j6CvBH2NO8MLREVeJOJeIuJeJuJeIeJeJeJeI+L+RcS9TsS9QcS9ScS9RcS9TcS9Q8S9S8S9R8S9T8R9QMR9SMR9RMR9TMR9QsR9SsR9RsR9TsR9QcR9ScT9m4j7DxH3FRH3dR6d4RuR97+CvhX0naDvBf0g6H9SWQeKvILKBJULqhBUKahKUC9B1YJqBNUK6i2oj6A6QX0F1QtqENRPUKOg/oIGCBooaJCgwQMR098QFfkvEfctEfcdEfc9EfcDEfc/Ik5WHMeFiLgyIq6ciKsg4iqJuCoirhcRV03E1RBxtURcbyKuDxFXR8T1JeLqibgGIq4fEddIxPUn4gYQcQOJuEFE3OCBmc4gH7DCHQUqqI4xKfXfLSx44/mwjH69ZAIjnyHA55CBKYEP6BF4Fp+cAneoUMbM8JnVjEeSDOTjC/ZwibtaDjkUfMYwo0zXccwoAXedQ4x1XteSOpcx1nk9S+pczljn9YtUZ7ew4LmM8qsut2Pw8Rw7+AxbwmfEEj6jlvDZ5NhhO5odPttxfi/eOuM2KZS/xirxZKcXf1u3OHboZKslfLZZwucGlvC5oSV8/soSPn9tCZ8bWcLnxpbwOckSPjexhM9NLeFzM0v43NwSPrewhM8tLeFzK0v43NoSPrexhM9tLeFzO0v43N4SPnewhM8dLeFzJ0v43NkSPnexhM9dLeFzN0v43N0SPvcwxGcpP7Pcs0h1dgsL3l6M8utjybOsvR07+NzHEj73tYTP/Szhc39L+DzAEj4PtITPgyzh82BL+IxZwme7JXx2WMJnpyV8xi3hM2EJn5Mt4fMQS/icYgmfh1rC52GW8DnVEj4Pt4TPaZbwOd0SPo+whM8jLeFzhiV8zrSEz1mW8DmbmU/u/aNl1Y5TW81f7zklXu9yQ/WeW+L1rjBU76McM/2Rey1+HqMs66vtqPN8hjr/9M3ETq+22g67e7RjB5/HWMLnsZbwucASPo+zhM+kJXwebwmfJ1jC54mW8HmSJXyebAmfp1jC56mW8LnQEj5Ps4TP0y3h8wxL+FxkCZ9nWsLnYkv4PMsSPpdYwufZlvB5jiV8LrWEz2WW8LncEj7PtYTP8yzhc4UlfK60hM/zLeHzAkv4vNASPi+yhM+LLeHzEkv4vNQSPi+zhM/LLeHzCkv4vNISPq+yhM+rLeHzGkv4vNYSPq+zhM/fWMLn9ZbweYMlfN5oCZ83WcLnzZbweYslfN5qCZ+3WcLnby3h83ZL+LzDEj7vtITPuyzh825L+Pw/S/i8xxI+77WEz99ZwufvLeHzPkv4vN8SPv9gCZ9/tITPByzh80+W8PmgJXw+ZIjPMmY+HwZYhb4fc5qhd0UqmOv8Z8Y6y+8xcGF9OYgP6+tBdvSTvzh28PlXS/j8myV8/t0SPv9hCZ//tITPRyzh81FL+HzMEj4ft4TPJyzh80lL+HzKEj6ftoTPZyzh81lL+HzOEj6ft4TPFyzh80VL+HzJEj5ftoTPVyzh81VL+HzNEj7/ZQmfr1vC5xuW8PmmJXy+xcwnXicudD1xF7EIO7iad910rIFzqd62QI5DmOU4zoAc32GWI/e5ZrLeaxqo97sW1HstA/V+z4J6jzdQ7/ctqPdEA/X+wIJ6r2Og3h9aUO91DdT7Iwvqvb6Ben9sQb09A/X+xIJ6RwzU+1ML6t1koN6fWVDvFgP1/tyCercZqPcXFtR7QwP1/tKCev/KQL3/bUG9NzJQ7/9YUO9JBur9lQX13tRAvb+2oN6bG6j3NxbUe0sD9f6vBfXe2kC9v7Wg3tsaqPd3FtR7ewP1/t6Ceu9ooN4/WFDvnQ3U+38W1HtXA/WWgKVe790N1DtkQb33NFDvMgvqvbeBepdbUO99DdS7woJ672+g3pUW1PtAA/WusqDeBxuody8L6t1uoN7VFtS700C9ayyod8JAvWstqPchBurd24J6H2qg3n0sqPdUA/Wus6De0wzUu68F9T7CQL3rLaj3DAP1brCg3rMM1LufBfWebaDejRbUe46Beve3oN5HGaj3AAvqPc9AvQcarrdbWPAkXkM5/37xECOPg0pchuMNyXA8I4+DmWWoQhmzLIcw8NnR0tIabfNaZJsU2hbh1taW9uZ4zGSdh4YY/ahyPv0z0Vckf6PK+WU4LMRX71HlpW1vpAzHGpDhcEYZji1xGdaV0zbbLSx4IxhlWGeBHq5uQIYjGWW4ermZcY9blqNCdvA52hI+V7OEzzGW8Lm6JXyOtYTPcZbwuYYlfK5pCZ9rWcLneEv4nGAJnxMt4XNtS/hcxxI+17WEz/Us4XN9S/h0LeHTs4TPsCV8RizhM2oJn02W8NlsCZ8tlvDZagmfbZbwuYElfG5oCZ+/soTPX1vC50aW8LmxJXxOsoTPTSzhc1NL+NzMEj43t4TPLSzhc0tL+NzKEj63toTPbSzhc1tL+NzOEj63t4TPHSzhc0dL+NzJEj53toTPXSzhc1dL+NzNEj53t4TPPSzhc09L+NzLEj73toTPfSzhc19L+NzPEj73t4TPAyzh80BL+DzIEj4PtoTPmCV8tlvCZ4clfHZawmfcEj4TlvA52RI+D7GEzymW8HmoJXweZgmfUy3h83BL+JxmCZ/TLeHzCEv4PNISPmdYwudMS/icZQmfsy3hc44lfM61hM+jLOFzniV8zreEz6Mt4fMYS/g81hI+F1jC53GW8Jm0hM/jLeHzBEv4PNESPk+yhM+TLeHzFEv4PNUSPhdawudplvB5uiV8nmEJn4ss4fNMS/hcbAmfZ1nC5xJL+DzbEj7PsYTPpZbwucwSPpdbwue5lvB5niE+y5j5XAH4LPQMxCED7ajzSsY631Jnps6rMdf5/Gx99NwCwkN1ecqvxVd+3oT+ebdFix/WxP7daNdWGmvt/t3SkVYKa53uYbU1J7pirdu/27rrYqz1+hfQD8LZWOv3L6hPuRDL7V9g/4xmsLz+Bff1sMIKF44Vif8E5kVYsBISzYsyYQk0r4kBS9nGZozV2W0s7/mufHndxXqBqqPbPawXaXm53cF6yUf2bYn8sV72b8fWfLFe0elES35Yr2r1K5rIB+u1XLoaDY71r9x63xQU6/UgfcgNhvVGsP7oBsF6M2jfbsmN9VZwO9GRC+vtfGxOix7rnfzsV1iH9W42VqQAW+g5IKyW+q+w3cKCd0GIj88WRpvdymiz2xht9gaMNntDRpv9K0ab/WtGm70Ro83emNFmT2K02Zsw2uxNGW32Zow2e3NGm70Fo83ektFmb5Wv/6qZm27NODfdhnFuui3j3HQ7xrnp9oxz0x0Y56Y7Ms5Ndyp0fgTmpjsXPtdKz013KRwrPTfdlXFuuhvj3HR3Biw1N92jvx3rdhcy+nZ7Mvp2ezH6dnsz+nb7MPp2+zL6dvsx+nb7M/p2BzD6dgcy+nYHMfp2BzP6djFG366d0bfrYPTtOhl9uzijb5dg9O0mM/p2hzD6dlMYfbtDGX27wxh9u6mMvt3hjL7dNEbfbjqjb3cEo293JKNvN4PRt5vJ6NvNssS3u4jRt5vN6NvNYfTt5jL6dkcx+nbzGH27+Yy+3dGMvt0xjL7dsYy+3QJG3+44Rt8uyejbHc/o253A6NudyOjbncTo253M6Nudwujbncro2y1k9O1OY/TtTmf07c5g9O0WMfp2ZzL6dosZfbuzGH27JYy+3dmMvt05jL7dUkt8u4sZfbtljL7dckbf7lxG3+48Rt9uBaNvt5LRtzuf0be7gNG3u5DRt7uI0be7mNG3u4TRt7uU0be7jNG3u5zRt7uC0be7ktG3u4rRt7ua0be7htG3u5bRt7uO0bf7DaNvdz2jb3cDo293I6NvdxOjb3czo293C6Nvdyujb3ebJb7dJYy+3W8ZfbvbGX27Oxh9uzsZfbu7GH27uxl9u/9j9O3uYfTt7mX07X7H6Nv9ntG3u4/Rt7uf0bf7A6Nv90dG3+4BRt/uT4y+3YOMvt1DjL7dw4y+3Z8Zfbu/MPp2f2X07f7G6Nv9ndG3+wejb/dPRt/uEUbf7lFG3+4xRt/ucUt8u0sZfbsnGH27Jxl9u6cYfbunGX27Zxh9u2cZfbvnGH279xh9u/cZfbsPGH27Dxl9u48YfbuPGX27Txh9u08ZfbvPGH27zxl9uy8YfbsvGX27fzP6dv9h9O2+YvTtvmb07b5h9O3+y+jbfcvo233H6Nt9z+jb/cDo2/2P0bdzBtjh213G6NuFBvD5dmUD+Hy78gF8vl3FAD7frnIAn29XNYDPt+s1gM+3qx7A59vVDODz7WoHOGy+Xe8BDptv1ycIVkDfri4YViDfrm9QrAC+XX1wrJy+XUM+WDl8u375YWl9u8Z8sTS+Xf/8sXx9uwHdwfLx7QYO4PPtBnUTi/LtBncfq4tvN6QQLOTbDS0MK8u3G1YoFvDthg/g8KF+whoxgMcfk1gjB/D5dqMYsJRvN9oS3+5yRt9uNUbfbgyjb7c6o283ltG3G8fo263B6NutyejbrcXo241n9O0mMPp2Exl9u7UZfbt1GH27dRl9u/UYfbv1GX07l9G38xh9uzCjbxdh9O2ijL5dE6Nv18zo27Uw+natjL5dG6NvtwGjb7cho2/3K0bf7teMvt1Glvh2VzD6dhsz+naTGH27TRh9u00ZfbvNGH27zRl9uy0YfbstGX27rRh9u60ZfbttGH27bRl9u+0YfbvtGX27HRh9ux0ZfbudGH27nRl9u10YfbtdGX273Rh9u90Zfbs9GH27PRl9u70Yfbu9GX27fRh9u30Zfbv9GH27/Rl9uwMs8e2uZPTtDmT07Q5i9O0OZvTtYoy+XTujb9fB6Nt1Mvp2cUbfLsHo201m9O0OYfTtpjD6docy+naHMfp2Uxl9u8MZfbtpjL7ddEbf7ghG3+5IRt9uBqNvN5PRt5vF6NvNZvTt5jD6dnMZfbujGH27eYy+3XxG3+5oRt/uGEt8u6sYfbtjGX27BYy+3XGMvl2S0bc7ntG3O4HRtzuR0bc7idG3O5nRtzuF0bc7ldG3W8jo253G6NudzujbncHo2y1i9O3OZPTtFjP6dmcx+nZLGH27sxl9u3MYfbuljL7dMkbfbjmjb3cuo293HqNvt4LRt1vJ6Nudz+jbXWCJb3c1o293IaNvdxGjb3cxo293CaNvdymjb3cZo293OaNvdwWjb3clo293FaNvdzWjb3cNo293LaNvdx2jb/cbRt/uekbf7gZG3+5GRt/uJkbf7mZG3+4WRt/uVkbf7jZG3+63jL7d7Yy+3R2Mvt2djL7dXYy+3d2Mvt3/Mfp291ji213D6Nvdy+jb/Y7Rt/s9o293H6Nvdz+jb/cHRt/uj4y+3QOMvt2fGH27Bxl9u4cYfbuHGX27PzP6dn9h9O3+yujb/Y3Rt/s7o2/3D0bf7p+Mvt0jjL7do4y+3WOMvt3jjL7dE4y+3ZOMvt1TjL7d04y+3TOMvt2zjL7dc4y+3fOW+HbXMvp2LzD6di8y+nYvMfp2LzP6dq8w+navMvp2rzH6dv9i9O1eZ/Tt3mD07d5k9O3eYvTt3mb07d5h9O3eZfTt3mP07d5n9O0+YPTtPmT07T5i9O0+ZvTtPmH07T5l9O0+Y/TtPmf07b5g9O2+ZPTt/s3o2/2H0bf7itG3+9oS3+46Rt/uG0bf7r+Mvt23jL7dd4y+3feMvt0PjL7d/xh9O2cgn28XGsjn25UNdNh8u/KBDptvVxEEK6BvVxkMK5BvVxUUK4Bv1ys4Vk7frjofrBy+XU1+WFrfrjZfLI1v1zt/LF/frk93sHx8u7qBfL5d325iUb5dffexuvh2DYVgId+uX2FYWb5dY6FYwLfrP5DDh/oJa8BAHn9MYg0cyOfbDWLAUr7d4IFmfLuy1H8uPv/s8PmJvwkVp85uYcG7PsQnvzOrzdQ5xFznG0J28HmjJXzeZAmfN1vC5y2W8HmrJXzeZgmfv7WEz9st4fMOS/i80xI+77KEz7st4fP/LOHzHkv4vNcSPn9nCZ+/t4TP+yzh835L+PyDJXz+0RI+H7CEzz9ZwueDlvD5kCV8PmwJn3+2hM+/WMLnXy3h82+W8Pl3S/j8hyV8/tMSPh+xhM9HLeHzMUv4fNwSPp+whM8nLeHzKUv4fNoSPp+xhM9nLeHzOUv4fN4SPl+whM8XLeHzJUv4fNkSPl+xhM9XLeHzNUv4/JclfL5uCZ9vWMLnm5bw+ZYlfL5tCZ/vWMLnu5bw+Z4lfL5vCZ8fWMLnh5bw+ZElfH5sCZ+fWMLnp5bw+ZklfH5uCZ9fWMLnl5bw+W9L+PyPJXx+ZQmfX1vC5zeW8PlfS/j81hI+v7OEz+8t4fMHS/j8nyV8OmV28BmyhM8yS/gst4TPCkv4rLSEzypL+OxlCZ/VlvBZYwmftZbw2dsSPvtYwmedJXz2tYTPekv4bLCEz36W8NloCZ/9LeFzgCV8DrSEz0GW8DnYEj6HWMLnUEv4HGYJn8Mt4XOEJXyOtITPUZbwOdoSPlezhM8xlvC5uiV8jrWEz3GW8LmGJXyuaQmfa1nC53hL+JxgCZ8TLeFzbUv4XMcSPte1hM/1LOFzfUv4dC3h07OEz7AlfEYs4TNqCZ9NlvDZbAmfLZbw2WoJn22W8LmBJXxuaAmfv7KEz19bwudGlvC5sSV8TrKEz00s4XNTS/jczBI+N7eEzy0s4XNLS/jcyhI+t7aEz20s4XNbS/jczhI+t7eEzx0s4XNHS/jcyRI+d7aEz10s4XNXS/jczRI+d7eEzz0s4XNPS/jcyxI+97aEz30s4XNfS/jczxI+97eEzwMs4fNAS/g8yBI+D7aEz5glfLZbwmeHJXx2WsJn3BI+E5bwOdkSPg+xhM8plvB5qCV8HmYJn1Mt4fNwS/icZgmf0y3h8whL+DzSEj5nWMLnTEv4nGUJn7Mt4XOOJXzOtYTPoyzhc54lfM63hM+jLeHzGEv4PNYSPhdYwudxlvCZtITP4y3h8wRL+DzREj5PsoTPky3h8xRL+DzVEj4XWsLnaZbwebolfJ5hCZ+LLOHzTEv4XGwJn2dZwucSS/g82xI+z7GEz6WW8LnMEj6XW8LnuZbweZ4lfK6whM+VlvB5viV8XmAJnxdawudFlvB5sSV8XmIJn5dawudllvB5uSV8XmEJn1dawudVlvB5tSV8XmMJn9dawud1lvD5G0v4vN4SPm+whM8bLeHzJkv4vNkSPm+xhM9bLeHzNkv4/K0lfN5uCZ93WMLnnZbweZclfN5tCZ//Zwmf91jC572W8Pk7S/j8vSV83mcJn/dbwucfLOHzj5bw+YAlfP7JEj4ftITPhyzh82FL+PyzJXz+xRI+/2oJn3+zhM+/W8LnPyzh85+W8PmIJXw+agmfj1nC5+OW8PmEJXw+aQmfT1nC59OW8PmMJXw+awmfz1nC5/OW8PmCIT7LEJ8RtzkajbeE417Ei7nhtvbWJjfa1N7c6rV6Ta1NneHWSCTeGm1taWtva3HbvGgk7iWa2iKJFPZajHV+sUh1dgsL3ktlfPIbOtCOdq5glN/Lluh2JWOdX7GkzlWMdX7Vkjr3Yqzza5bUuZqxzv+ypM41jHV+3ZI61zLW+Q1L6tybsc5vWlLnPox1fsuSOtcx1vltS+rcl7HO71hS53rGOr9rSZ0bGOv8niV17sdY5/ctqXMjY50/sKTO/Rnr/KEldR7AWOePLKnzQMY6f2xJnQcx1vkTS+o8mLHOn1pS5yGMdf7MkjoPZazz55bUeRhjnb+wpM7DGev8pSV1HsFY539bUueRjHX+jyV1HsVY568sqfNoxjp/bUmdV2Os8zeW1HkMY53/a0mdV2es87eW1HksY52/s6TO4xjr/L0ldV6Dsc4/WFLnNRnr/D/GOpc7P+3xeSpV4XUErStoPUHrS3xBnqCwlIGgqKAmQc2CWgS1CmoTtIGgDQX9StCvBW0kaONUnTcRtKmgzQRtLmgLQVsK2krQ1oK2EbStoO0EbS9oB0E7CtpJ0M6CdhG0q6DdBO0uaA9BewraS9DegvYRtK+g/QTtL+gAQQcKOkjQwYJigtoFdQjqFBQXlBA0WdAhgqYIOlTQYYKmCjpc0DRB0wUdIehIQTMEzRQ0S9BsQXMEzRV0lKB5guYLOlrQMYKOFbRA0HGCkoKOF3SCoBMFnSToZEGnCDpV0EJBpwk6XdAZghYJOlPQYkFnCVoi6GxB5whaKmiZoOWCzhV0nqAVglYKOl/QBYIuFHSRoIsFXSLoUkGXCbpc0BWCrhR0laCrBV0j6FpB1wn6jaDrBd0g6EZBNwm6WdAtgm4VdJug3wq6XdAdgu4UdJeguwX9n6B7BN0r6HeCfi/oPkH3C/qDoD8KekDQnwQ9KOghQQ8L+rOgvwj6q6C/Cfq7oH8I+qegRwQ9KugxQY8LekLQk4KeEvS0oGcEPSvoOUHPC3pB0IuCXhL0sqBXBL0q6DVB/xL0uqA3BL0p6C1Bbwt6R9C7gt4T9L6gDwR9KOgjQR8L+kTQp4I+E/S5oC8EfSno34L+I+grQV8L+kbQfwV9K+g7Qd8L+kHQ/wTJzhUSVCaoXFCFoEpBVYJ6CaoWVCOoVlBvQX0E1QnqK6heUIOgfoIaBfUXNEDQQEGDBA0WNETQUEHDBA0XNELQSEGjBI0WtJqgMYJWFzRW0DhBawhaU9BagsYLmiBooqC1Ba0jaF1B6wlaX5AryBMUFhQRFBXUJKhZUIugVkFtgjYQtKGgXwn6taCNBG0saJKgTQRtKmgzQZsL2kLQloK2ErS1oG0EbStoO0HbC9pB0I6CdhK0s6BdBO0qaDdBuwvaQ9CegvYStLegfQTtK2g/QfsLOkDQgYIOEnSwoJigdkEdgjoFxQUlBE0WdIigKYIOFXSYoKmCDhc0TdB0QUcIOlLQDEEzBc0SNFvQHEFzBR0laJ6g+YKOFnSMoGMFLRB0nKCkoOMFnSDoREEnCTpZ0CmCThW0UNBpgk4XdIagRYLOFLRY0FmClgg6W9A5gpYKWiZouaBzBZ0naIWglYLOF3SBoAsFXSToYkGXCLpU0GWCLhd0haArBV0l6GpB1wi6VtB1gn4j6HpBNwi6UdBNgm4WdIugWwXdJui3gm4XdIegOwXdJehuQf8n6B5B9wr6naDfC7pP0P2C/iDoj4IeEPQnQQ8KekjQw4L+LOgvgv4q6G+C/i7oH4L+KegRQY8KekzQ44KeEPSkoKcEPS3oGUHPCnpO0POCXhD0oqCXBL0s6BVBrwp6TdC/BL0u6A1Bbwp6S9Dbgt4R9K6g9wS9L+gDQR8K+kjQx4I+EfSpoM8EfS7oC0FfCvq3oP8I+krQ14K+EfRfQd8K+k7Q94J+EPQ/QdKRCAkqE1QuqEJQpaAqQb0EVQuqEVQrqLegPoLqBPUVVC+oQVA/QY2C+gsaIGigoEGCBgsaImiooGGChgsaIWikoFGCRgtaTdAYQasLGitonKA1BK0paC1B4wVNEDRR0NqC1hG0rqD1BK0vyBXkCQoLigiKCmoS1CyoRVCroDZBGwjaUNCvBP1a0EaCNpZ+iqBNBG0qaDNBmwvaQtCWgrYStLWgbQRtK2g7QdsL2kHQjoJ2ErSzoF0E7SpoN0G7C9pD0J6C9hK0t6B9BO0raD9B+wuS35qX33GX30g/WJD8trf8brb8JrX83rP8lrL8TrH8BrD8vq78dq38Lqz85qr8nqn8Vqj8Dqf8xqX8fqT8NqP87qH8pqD8Xp/8Fp78zpz8hpv8Ppr89pj8rpf8Zpb8HpX81pP8jpL8RlFSkPy2jvxujfwmjPzeivyWifxOiPwGh/y+hfx2hPwug/zmgfyegDyrX56DL8+Yl+e3y7PR5bnj8kxveV62PItanvMsz1CW5xPLs3/lubryzFp5Hqw8a1WeYyrPCL1UkDzbUp4bKc9klOcdyrME5Tl98gw8eb6cPLtNnosmzxyT53nJs7LkOVTyjCd5fpI8m0ie+yPP1JHn1cizYOQ5K/IME3k+iDx7Q55rIc+MkOcxyLMO5DkC8h39PwiS75bL97blO9HyfWP5Lq98T1a+gyrf75TvTsr3EuU7f/J9OvmumnwPTL5jJd9fku8Gyfdu5Dst0k+V72LI9xzkOwRyf77c+y73lct91nIPs9yHK/elyn2arwmS+/jkvja5z0vue5L7gOS+GLlPRO6bkPsI5HN1+ZxZPneVzyHlczn5nEo+t5HPMeS6vlznluu+ch1UrgvKdTK5biTXUeS6gpxny3mnnIfJeYn008t+cgEcuc9YhnWcTEiZB6c8lS735cp9qnLfptzHKPf1yX1uct+X3Acl9wXJfTJy34jcRyH3Fcjn7PK5s3wOK59Lyud08rmVfI4jn2vIdX657i3XgeW6qFwnlOtmqwkaI2h1QXLeLeehcl4m5yly7/t4QRMETRS0ttM1yHFKhQGp/wPf3GTokX+7ZguYb5AmbbwmTcnprkmXXT7hN2duDtPCmvsiqf9LEl+23d7vokUwrSX1/6LGOcm1pklNyYQFGsyTNWmLNGlLNWnna9Iu06Rdq0m7WZN2pybt95q0BzVpf9ekPaFJe16T9lLq/9MPL1r0yOe7XwrTXk79H1X+6CYL2u/ZEaa9nfp/1urV7nVXrPkMTHsn9b/Maei774OHPQTTvkr93/y7w7Z4esq5l8C0rzVp32jS/qtJ+1aT9p0m7XtN2g+atP9p0tTLPXfNff2bIbPWPiQrSZNWpkkr16RVaNIqNWl1qTSqbfum0qi2HRXyr/toTdpqmrQxmrTVNWljNWkTU2nPPvD6jL3aXzsHpq2jkcu6mrT1NGnra9JcTZqnSdtA00YbatpoO41cttek7aBJ21GTtpMmbWdN2n6aNjpQI5eDNGkHa9JimrR2TVqHJm2qpo0O17TRsRq5LNCkHadJS2rSjteknaBJO1PTRks0cjlbk3aOJm2pJm2ZJm25Ju1iTRtdommjmzVyuUWTdqsm7TZN2m81abdr0u7XtNEDGrn8SZP2oCbtIU3aw5q0P2vSHtO00eOaNvqXRi6va9Le0KS9qUl7S5P2tibtM00bfamRy781af/RpH2lSftak/aNzkdJefdUG5Wn0qg26p9Ko+QyQJM2UJM2SJM2WJM2RJM2NpVGtdGaqTRKLmtp0sZr0iZo0iZq0tbWpEU1bdSkaaMtNHLZUpO2lSZta03aNpq0bTVpe2jaaG+NXPbRpO2rSdtPk7a/Ju0ATVpC00aTNW00VyOXozRp8zRp8zVpR2vSjtGknappo9M1cjlDk7ZIk3amJm2xJu0sTdoKTRut1LTRdRq5/EaTdr0m7QZN2o2atJs0af+naaPfaeTye03afZq0+zVpf9Ck/VGT9jdNG/1d00YvauTykibtZU3aK5q0VzVpr2nSPtC00ccauXyiSftUk/aZJu1zTdoXmrTvNG30vaaN6sp/+k/Jpa8mrV6T1qBJ66dJa9SkjUylUW20WiqNkssYTdrqmrSxmrRxmrQ1NGnrpdKoNlo/lUa10cYauUzSpG2iSdtUk7aZJm1zTdpOmjbaVSOX3TRpu2vS9tCk7alJ20uTdrCmjWKaNjpSI5cZmrSZmrRZmrTZmrQ5mrTjNW10kkYuJ2vSTtGknapJW6hJO02Tdo6mjZZq2ugKjVyu1KRdpUm7WpN2jSbtWk3abzVtdKdGLndp0u7WpP2fJu0eTdq9mrQHNW30kKaNntbI5RlN2rOatOc0ac9r0l7QpL2haaM3NXJ5S5P2tibtHU3au5q09zRp76fS5iwddfpbzdtmPZP6IJX2xsBdLljQe/wPWeVV/vT/kutG3TH8zbJ9szA1aZ9r0r7UpH2lSftGkxaq8k8r16RVa9JqNWl9NWkNmrQhmrRhmrSRmrTRmrS1NGkTNGnradJcTZqXSnv58Ntfqv3koSth2uapNOp56qEazKmatFmatDmatLNTaZPnv9VnnysemgHTzk+lXTYkdunbP7zSG6ZdrqnDtam0F15/atcjps/fCab16/XT/1vuOfHCD17e+gOYNjCVRj3vH9nLv7wfDyPxqZ+nSWvWpLVq0iZp0jbVpG2pSdtak7azJm1XTdpemrR9NGkHaNIO0qRN1qRN0aQdpkk7XJM2Q5M2S5P2YD//tIc1aY9q0h7XpD2pSXtak/aCJu0lTdormrTXNGlvatLe1qR9rEn7VJP2b03aV5q0HzdRiXDK2M8bb7luxRow6R/9/e97RJP2hCbtKU3aS5q0VzRpb2jS3tKkvadJ+0CT9oUm7d+atK80ad9o0n7QpKkNaFRaWSqN3CumSWtKpf192aMPX7sw1gnTWjT3tWnu21Bz30aatEkazE01922uuW9LzX3baNK202DuoLlvJ819u2ju212TtqcGc2/Nfftq7ttfc99BmrSYBrNDc19cc99kzX2HatKmajCnae47QnPfDM19szVpczWY8zT3Ha2571jNfUlN2gkazJM0952iuW+h5r5bNPdNHETfNyT1f9aon/7XpH4r51U+8pbTykmp325hwasBuNz4rW4sUuNkB2b+f8RXmAbwwwq/wgy+m5qGOJcls/EdVG5d6jfYdp2+R6XBCc7lqbTqVLq6TkU7NQjPRLtDnrjl1p/gvwzUTYbNkpm0EF/ZUYW/uRn8dJ/cwgx+WOFvaQY/3ee3Sppoe89V+FsbwQ93KPxtUvhOFrYXaW2OhFubw+HOuBvrbG5JtEVa3Eh7U6Sto91zI03h1s6WWMR145F4R9TtbG5r6ozH2poiifZYW7PC3pbEjsTbBVRTrLm13UvEmhNue7SlNRJLtLR0xjrbovGWJrfT62j2OsJeorU11tQU62hq87xEvK0p0ZrG3s6IXDJ6s70R/EiTwt/BCH64U+HvCPAZz/9P6+VOSYdo27yC54e9sxne0zZnFzP4ad3Z1UjbZvjfLVmw7LsEhb27Ed7DCYW/hxnZpO3xnmbw0+PhXmbw0/LZ2wx+2i7sYwTfS+vmvil8B2B7rZFwuCUizwxp7XS9aGdHuFWMLO1Rt8ONdYTjbVGvLRENRyMdnR3trdHWmJdwE7GOtkTrT+gKez8jvEfSbbs/wOfzFSLpMesAQjY5bvZyoSvsA/PHzhXSY9VB/tjdblqFfTCBHY5FOty2hBtrao21xFubhJvhiov21niiORxrFw5HuNPzvHhU/AnHO6Nt7Z3NXntzvCXc1C6KS8skljShL17ad2pnxm+OuW3x5uYWhd/BjN/e3twSE/JU+J3M+JGO5ngi0pIeB+PM+LGmaCLRFIkp/AQzfpPnxpvCLWndnMyM39buNjW3tqb15xBmfOEvRzrbYu0Kfwq3fNrjbken16bm2oem8FUZMqiyD2MuOxXaQqg8x8leS3BQ+bWIV26fLITKg/xA+ah5u5Ld1GRXXhuINGhjcFo5EafKobA6GLE6GbHijFgJRqzJjFiHMGKpfm22r0XT4+hUI/iRVoV/uBF8N67wp5nA9zK+13SA7/Dxn8Y/AuCHDOAfaUb+afwZZuSTnnPMTOGbwJ5lRjZpH2y2Gfz0nGOOGfy0jzoX4DPqZto2HGWG/zT+PDP4bQp/vhn8tA98tBn8tA95jBn8tA98rBF8L83/gqQJ/QynbdtxRvgPp+1P0gj/kTT/x5vBT/N/ghH8aBr/RDP46TWhk8zgp+3/yWbw0/b/FDP4ad/qVCP4Tek5+EIj+M1p/TnNDH56DeR0M/jp9e4zzOCn9X+RGfy0/p9pBj+t/4vN4Kf9n7PM4Kf9kyVm8NP+ydlm8NPj7zlm8NP+w1Iz+OnnJcvM4Kft53Iz+Gn7ea4R/Ja0/3CeGfy0/VxhBj9tP1eawU/bz/PN4Kft5wVm8NP280Iz+Gn7dpEZ/LR9u9gMftq+XWIGP21/Lk3hO93HjuAI+VKS3CdXn3ongNpfyOjLuWrvXkWmKlnPC+R1JYhnnAd2BnleAMuvRbyaeF4Ay1P8YPnA5wUyrYrgtYFIw21YRZRTRZTTQKRh368QrPMYsc5kxFrOiMVZx6WMWEsYsZYxYi1mxFrAiMUpe84+tKJEsRYyYnHqBKfsOfXrDEYszr7NqROnM2Jx2ugLGLFKdXxUPrVZ38ptriPKVkGl9QJlQ58Kh3L0G/ItfdWBjRlcnE+FPk7mmfjMedM6dpw+Kz7T0dwgg9oAj+NLTXghlFYdoA6Ok1uwEwIIFjvwkLc6hAnvDRFY1GYdrMxQ5hU+PEAM1VbYEZ6U+u0WFLxIkHrA8os1iaCMBDWJUPLpZUY+4RDCh/z0IuSDdRi3XcjJdORKgAXz9wJ1hPnhtbofxr2a+t/gdO1HamN9iEgrJ+KUfCXvz6O6wbbBemqmHaJeUD1V5dc6JvtNRk8pvaAGsxqnaztzbmgK0q6Ubash0hSW2mAI9RTmrwZ1hPnhtbofxn2U+t/gdNVprKc1RH1gHNRT9aGQGp/6TEr9dgsKLS3UOIX7AZQT5wbtoP1AlV/rmNS7TD+g2omyJ0p2tQSvDUQaXvSpJcqpJcppINKwI1oI1nJGrNMZsRYxYq0oUawljFjLGLEWM2ItYMQ6hxGLU+9LUV66cTBfLBk4dXUlI9ZZjFicuspZx4WMWKXaty9mxEoyYqmHh9jPVPiOk/GV8Hg/KfXbLSj8NHeD5al6wDhYfi3ilZefjK9EyZXyaZV8epuRT5qf3gQ/vQn5qLbsQ6QpLLXWAucMMH9vUEeYH16r+2FcS6rBGhCmDHjO0IeoD4yDcwY1scR+qcKToRjtAMtTfMM4WH6tY7LfuFq9oPp/jdO1nRnl4wZpV8ivass6Ik1hpc6DzNJTmL8PqCPMD6/V/TBuC6SnUKexntYR9YFxUE83RnoK2wbrqZF28BKB9VSVX+uY7DcZPaX0ojchxxqnazszyscN0q6QX9WWfYk0hVWf+g31FOavA3WE+eG1uh/G7Yb0FOo0fimrL1EfGAf1VH3YscanPpNSv92CQlOUaks+/Bavjqgn7mdQ1nx6HQncz1T5tU5XvTDRz+oRP356oGTXQPDaQKRhHWkgymkgymkg0vC8phCsRYxYCxixTmfEOocRayEj1hJGrKWMWJw6cQYj1qmMWCuYsCj7XAhf5zHxJcNKRizOvn0xIxanLeTsj8sYsTjb8RJGLE6d4JQ9V992mOvIqRPLGbFK1U5w8vVL8Jl6xrRVJ3vO/ngmIxZnHS8sUb44/QnOOuLnA3BuGUr9r3G69j3GeXY8hMpT9YBxsPxaxCsvP5l5NiXXekKuSnb9CF4biDQ8z+5HlNOPKKeBSMNjRiFYixixFjBicdZxCSPWMkaslYxYnLK/mBGrpx3zw7qEEYtTJ85gxFrOiMVpv1YwYnHKnlNXOWVfqvaLU1c59WspIxZnO3LqF2cf4tSv8xixFjJicdaxVH05zjpy+hOl2o6l6stdyIhVqn4Op4/Z40/8PPoQp53g5ItLv+Q1XlcthK/zmfiSgVP2nD6AGmvxfjeFL4PZNbRw4D22eA3NyB6sHGto1N66GqerHjLKxwvSzpBf1ZaNRJrCSn1LN2tPGMzfD9QR5ofX6n4Yt1VKKA0IUwa8J6yRqA+MU/KVe8I2KcuuG2wbrKcm2wGWp/iGcbD8Wsdkv3G1ekGtodc4XduZUT5ukHaF/Kq27E+kKazU91Oz9BTmbwR1hPnhtbofxu2B9BTqNNbT/kR9YBzU052QnsK2wXpqph2C7wVX5dc6JvtNRk8pvaDGqRqnazszyscN0q6QX9WWA4g0hTUw9RvqKczfH9QR5ofX6n4Y14H0FOo01tMBRH1gHNTTA1I/6h3//pmvnab8MSxDeB/uD0ba24u7QfuDKr/WMdk/M/2hf0C5KvkMMCKfzkQQ/YH8qrYcSKQprNS3rbP6A8w/ANQR5ofX6n4YNwv1B9h3cH8YSNQHxsH+MA3Zbdg2WE+NtIPrJoLqqSq/1jFpJzN6SukFNf7VOF3bmZGfeJB2hfyqthxEpCmswanfUE9h/oGgjjA/vFb3w7gTkJ5Cncbv8Awi6gPjoJ4ek/pR41OfSanfbkEh7lFtyYcfc2sIWfPhh9tqiPbiw29vVfhDzOA3K/yhRvBb0+07zAh+U1o+w83gdyr8EWb0J83/SCP4kYjCH2UEP57mf7QR/GgafzUj+O3p/jvGCH5bWv9XNyOfdPuONYKfaFL448zIJ83/Gmb4T9v/tQA+51qEwp9gBN+NKHmMdzKhnKiTKl/5ImuC/CGf/woLp6myahGWKb+PqhvkH8/7xgN+oAz8sMbniVVDpJlo07U09Ybl12l4xfWQAZ+N0V2ZyHAGI9YpjFjnMWFRvm0hfB3PyNdAJr4o/7cQrMGMWOVMWDKclOTjawgTX/J6aIliDWPEGs6INYIRayQj1ihGrNFMWDLgj7cUwtdqjHydy8jXGCa+5PXqjFhcY4e8HsuINY4Raw0mLBnw2mmpYG2ewjK73hVtM7veFYmZXe+Kdppd72qKmF3viraYXe+KdihfXY2HqgyoW3B845tXRAO/I6bKr0W88vKTmd+NQPxg+ah+qWQ3kuC1gUjDfXQkUc5IopwGIg3v8SsE6wJGrIWMWOcwYi1hxDqDEWsBI9ZSRqxFjFgrShSLU1cXM2JxyZ4at0tFVzn740pGrFLtj+czYnH2oVKV/VmMWJx2gnOs5bTRnLLnlFep6henb8LZjpyy/yXYiYuZsOQ1nsMWwtdJST6+BjPxxYklwwlJPr6GMPJ1UpIP61RGLC6+5DVeSy8Eq5wJSwYunZDhFEasExmxTmLE4uSLS1dL2Rb2YeSLU1c525HTrpaqvDh1Fa+tlkrf5rRflzBicfpfZzJica4pcPrknHMFzrVH5d+rdexhIC2U+m/2GYDb7WcAw8zwo30GMIyQK7UflpGfziDtDPlVbTmKSFNY6lk+3NsP848EdYT54bW6H8YtTTVcA8KUAe/tH0XUB8Yp+cq9/WeWZ9cNtg3WUzPtEPzbkKr8Wsdov/F0ejGCkCOlF+reBiIN+/RB24tqe7z3rRCs5YxYpzNiLWLEWlGiWEsYsZYxYi1mxFrAiHUuIxZnH+JsxwsYsRYyYq1kxOLs25z6xdmHOO3qL0H2SxmxOG20soXUe1SM/odLvefEiJ9+52C0RhawfLwXR6VT/xUWTlNl1SIs5rp5urrp5m7QD8d7eyms0XliUe/GmWjTUZp6w/LNvgvYFDb7LmBTs9l3AaMJpfNjgDxDSHZjjbRla+CzVFT5tYhXU31qLOIHywfPh8YRvDYQaXjv3jiinHFEOQ1EGh63C8G6gBFrISPWOYxYSxixzmDEWsCIdS4j1nmMWJyyL1VdXcmItYgRi1O/OG3OckasX4LslzJicdZxRYlicfbtxYxYXLKX13hfbqnoaqn6AJxYPeN2z7hty9jRM273jNs94/bPU/alqqvnM2JxyovT5nDK/ixGLM4+xDlul6qNLlV/grOOnL4vZztyyv6XYCcuZsIKOV335xSCNYoRi2udXF6PZsKSAe89LoSvPox8nZTkwzqVEesUJix5vZrDh/Vzl728xu9OFII1mBFrCBOWDJzyWp2JL05dlYGzD5Wq3pdqHX/utpCTLxl6xg77xw4ZTmbCktecex5OSvLxNZSRrxMZ+eIaa2XgHB855XVSkg+L035dwojFOec7kxGL85kO5zoA5/oE5/4c/H7bWJAWSv2nzouX5UxK/XYLC50hVJ6qB4yD5dciXpn58XRyHUvIlTrvnpGfjhDCh/ysQchHteVaRJrCUudkwvfbYP41QB1hfnit7odxn1b89L8BYcqA32+jzkqHcUq+8v229yuy6wbbBuupmXYIB36/TZVf6xjtN55OL6j+T+mFupdqLzzuB20vCmsJI9YKRqzTGbGWM2JdwIi1iBHrvBLl6wxGrAWMWBczYiUZsS5hxOKU1zJGLM7+uJIRi1PvOW0hZzueyYjFaXM4dWIpIxan7BeWKF/nMmJx6gSnb8I5bnO2Y6naL0794uyPpWqjObE49WsxI5aSvZqvwPlNKPXf8DfgoiFUnqoHjIPl1yJeefnJzPUoua5ByDWf74spXtU1TIPlFPs7XjIsZ8Q6nRFrESPWihLFWsKItYwRazEj1gJGLK5vI8mwkBGLsz+uZMTi1C9OeZ3DiMWpX5x9iNOucuoEp10t1b7N2R85+9AFjFic/fGXoF9LGbE4fQA11tan0qC/Dc8jgWmwHJ3PD+9X+eqI+0Kp/2a/4dsW+LwOVX4tIRMTPv/4gHJVsptA8NpApOG9KxOIciYQ5TQQaXhsKgTrAkashYxY5zBiLWHEOoMRawEj1rmMWOcxYnHKvlR1dSUj1iJGLE794rQ5yxmxfgmyX8qIxVnHFSWKxdm3FzNiccleXuPzOkpFV0vVB+DEKtVxm1P2nD4Ap43m9CdKVVd7xu1VN6b1+OT5YfX45KtOv3r8wlWnX6XoF8rAKa9S1dXzGbE45cVpczhlfxYjFmcf4hw7StVGl+qYxllHTt+Xsx05Zf9LsBMXM2GFnK57nArh6wRGvkYx8SWv+zBicT4f4pTXUEa+Tk3yYZ3ChCWvV3P4sLh0QoaTknxYXLLn7Nvc/ZGrD8nr0UxYMnD2x1+CfuHzhgrBGsyINYQJSwZOea3OxBenLZSB00aXqt6Xah1/7mMtJ18y9Pgm9o8dMpzMhCWvOX3yk5J8fHH65Ccm+fjiGmtl4BwfOeV1UpIPi9N+XcKIxbmmcCYjFudzK851Js71L879hfi8oT4gLZT6X+N0tXWynEmp325BwQt83pAqv9bpOlbx8ZPZ5zvA6SrXPoRclewGErw2EGl4bjyQKGcgUU4DkYaf+RaCtZwR63RGrEWMWCtKFGsJI9YyRqzFjFgLGLHOZcTi7EOc7XgBI9ZCRqyVjFicfZtTvzj54mxHTr447QSnTnC241JGLE57j795jn2CSanfbkGhqUn5JtCXUT5VjUP7Jjxle60hVJ7j0H6dKr8W8crLT8avo9oNygf7dYMIXhuINNyGg4hyBhHlNBBpuG8WgnU2IxYnX8uZsOR1L4cHi7uOCxixljJirWDEWsyIxSmvlYxYFzFincuItYgRi1P2SxixzmDE4qzjxYxYSUYstc6HfQsZJqX+i+Ew0tocCbc2h8OdcTfW2dySaIu0uJH2pkhbR7vnRprCrZ0tsYjrxiPxjqjb2dzW1BmPtTVFEu2xthazvkNTW41Dj688+F5Y4Q82gx9R+EPM4EcV/lAz+E0Kf5QZ/GaFP9oMflo/VzOD36rwzZx94KX1f4IZ/JjCn2gGv1Phr20GP67w1zGDn1D46xrBD7sKfz0z+Gn7tr4Z/LR9c83gp+2bZwY/bd/CZvDT9i1iBj9t36Jm8NP2rckMftq+NZvBT9u3FjP47Qq/1Qx+2r61GcGPpO3PBmbwPYW/oRn8tH37lRn8tH37tRn8tH3YyAx+2j5sbAY/3X8nmcFP999NzOCn+++mZvA7FP5mZvDT/tXmZvDT9mcLM/hp/2pLI/jRtP3Zygx+2v5sbQY/bX+2MYOf9q+2NYOf9q+2M4Oftp/bm8FP288dzOCn/asdzeCn7fNOZvDT9nlnM/hp+7yLGfy0fd7VDH7aPu9mBj9tn3c3g5+2z3sYwW9K+597msFP2/+9zOCn7f/eZvDT9n8fM/hp+7+vGfy0/d/PDH7a/u9vBj9t/w8wg5+2/wc6mZDBjsTbxVJ8U6y5td1LxJoTbnu0pTUSS7S0dMY626Lxlia30+to9jrCXqK1NdbUFOtoavO8RLytKdGa5v0gEruQ4KX71cEm5OIl0nYhBvBDbPy3pvHbjbRrBr/DiHw603a5k7ttPdeV33Wck3qQrs4XjoN6VKI2SaR+q29WynBkMpMnDtJh/rtrf/ovy5ufKq8OyMoB5cig6lxhQqZirT2EynMcep+KKr8W8crLT2afSgXiB8sH71OpJHhtQGky4OeWlUQ5lUQ5FNYljFgLGLHOZcRaxIi1jBHrDEasJYxYnHVczIhVqvq1kBHrPEaslYxYnPrFKa9zGLE49YuzDy1nxOLUCU67qvaz1Thdx0JGvz2hxlroW6ug0g52susF02Ig/7bJTD4cytFvWKdqQW2NGVycD/MD/aaDAb6fzyCDkmMVSOf0cRR+jRn8iJJ9tZMtU1ynGh9ZqXTqv8LCaaqsWqer3E34h1TdIP+4v1QDfqAM/LCq88SqIdJMtGmVpt6w/DoNr1Q98PyGskeU/63y12j4gvnribLVvUqGtSCNUYZhnQxhX1Tl9wF8dsbbZ0/efvpkB4VyJAcltyEo367JjBywDlb7YDno9xAUVw7wYDA7Z1y144CqU77jAJTtwSitu3ZPBmwbsMxlkG39HFpbKCfqhHXIb22hHKTD/C/3ypT3Uuq6Nyizj6bMOsQ3zC/Drsns/H1B3cqJPH0Qjyr/6ym+ZPttk2o/SnaKnxp0/89Jl1Wd8tVl2I4HI94UptId3LZ+7fIxaJftGzM84/LqNPVQvw8kylO8N6C8Mqg27gfiGde4An9LS5Vfi3hlHofSPkw/xA+Wj7ItUoa9U9dTp8c6N4sdMXP21HgZEmU9uIbwDQhO5YF5YWgALDk++XCzy7BVsut9OChR1jtdu3UDKgvilxNx2PQ2ELwpNVeyGZAaa6XZ+hYtv2I1lqHG6SpbRlXoCKqaqvxax6Q5zKhmPeLHT/ZKPoa6SnvI6dotyokyFb+qLfsRaQorZd2yTCTMD/sLzA+v1f0wrialWw1O1+69WzKbB6rrwzgl3x+H1xRuPVGfvqhuVLvVE7gNxP1YhrAfT09mp1USdVNpVZq0ak1aDVEvlVYL7jsS3debwJQ8HFydwfOTDdQr5b5QtsnPtvphbYew4P39EFZjDqw9EBa8vxFh9c+BtSfCgvf3R1gDcmDNQljwfnw02MAcWLMRFrwff8ppUA6sOQgL3o+PzhycA+sohAXvx8d5DcmBNQ9hwfvx0ZlDc2DNR1jwfnyc17AcWEcjLHj/MIQ1PAfWMQgL3j8cYY3IgbU3woL3j0BYI3NgHY6w4P3q3joCC/sBZl4JC+4HqPJrEa+m/IBRTle5Qvngx7CjCV4biDRst0YT5YwmyqGw+jNiDWDEGsiINYgRazAj1hBGrKGMWMMYsYYzYmG7lWu83iv503/deK3ug7oL85WDPNQYDTH8/AE4Z4PxIwPUB8Zh2Yz0Kc+PPygbNd/U+R/16D6K54Yc5eh4Vvkon3lGMjsNLrFj/xYuB2M/HC6V90NpNUS9sM8M2xX7zFBu0GeuRPXpSMWbXY5zXah/frLC6xLUf8cJtlxLLbmbLqesSOXg+vRlLAdiqWXPVbfE58aD1AOWb3qJT8miv0YWZo56igZe7sRHivY3JAuli7nmbfiRIjU3o8YSuDw6OT5LPKTbdN7uscm9QFZoVjE7dShfP/S70YetSSgfPmVMuX+YD4gFA+ZDt/xKlU+ZEXVdScTLQE1r8TJsvqexwPsHacrpX2A5/YlyzJ5sktm5YebkkcxTfmopAdZJlY9PaVPp1H+FhdNUWbVO1zYyYQaouunaGU4xgiy5DMkTy+xpNZk2HaypNyy/TsMrVQ/4tBjauaqUbyjduiXV2diUrTC7eyzSHFQfVfnF2mkedKcL5aqrextQmgwnJzP5cFo5EVemwVrOiHU+I9YyRqwzGLEWMGJx1pGzHTnreDojFmcdlzJincuIdQ4j1iJGrJWMWEsYsTh1grM/cvYhTp3glNdiRqwVjFicsj+TEYtT9ucxYnHKi9MWLmTE4pRXqdpCTnlx2pxfgs/EqROc4zaX7OU1Pg28VPSeU/ZnMWJx6j1nHTntBKcPwCmvixmxgryNTc3rVX7qDRZqXeqX8gZLE8rH8QZLE4ord+g3WCT2c2h7Ln77RQaz67GRcAiVh+vooPJrEa/M7Z9es6K2h1Hrnkp2wwheG4i01cE1TIPlDCPKaSDS8LhdCNZSRqxzGbHOYcRaxIi1khFrCSMWp04sY8RawIjFqROc8lrMiMUprzMZsTjldT4jFqeunsGI9Utox/MYsTjlxTkOLWTE4pRXqY5DnPLitPec+sVpczj7I6dOcPpMXLKX13gNplT0nlP2ZzFiceo9Zx057USp+l8XM2KpNRjqVSL8CgM1hx2qKQfePzQAFjUfVvmpV490az3Uq0dq7cHQKzhhXXtQry91Z61Hyc1D+fBaD7Rtw32wHPTbQ3F+az1439K81EKW2a+g0VvN8X5FuGe0AdUv31dt4f31mnL6F1hOf6Ics7LM/xSNBpQWA2n4FYd2gAVPQcGhHP2G9ZX9Yqc8TtiA7XGwD2YlkTeE0lTeM2oyfOyX4sPsvsPitYl61Tlom6j6SlkcWGCbUF8pVnxTr0sHeY2beg2/gbi/n6acsQWWM5Yop464L+TzX5WD43A5FM+69fbulgOxVB82u3afv/5jOUP9x3tz20EaPkWvA6TB50A4UH1DyUL2jcsD9A2zz5uKJ0P8yhuUIezbOFAyVLIIKsN6p6sMcd+uJ+pB9XuI0Z1+T/FQauNEf5QG23gASoNtPBClwTbGz6s6QVoIpcVBWhVKS4A0fBLiZJBWi9IOAWmwrXHINZ49lsd4BvXmYJRGjWfUESoK1+wrZZFIELsPy69FvPLyk3kOSr0iTJ3cqWQ3kOC1AaXJcGIykw+nlRNxZRqsJYxYKxixTmfEWs6IdQEj1iJGrPNKlK8zGLEWMGJdzIiVZMS6hBGLU17LGLE4++NKRixOvee0hZzteCYjFmc7ctovTnmdy4i1kBGLU16cfYjTn+CU1zmMWD12ddXZVS7Zy2v8HLRU9J5T9mcxYnHqPWcdOe3EYkasUvVXj2fEUv6qug/O8eEzS8PnGKS/+jnMDH76nATds1xYPp7Tq3Tqv8LCaXjf9kAzddPu29bpAVwbD3JE6NA8sVbleSZQ1vg8E4pXqh4DGGUS5Aso1NpSvm2rO7LVcB9L7ykYoJETLL+Q90fCKJ96TljmdG27IT5YDvodRnF+ewrqna5tWuPDpyoXx2FdgfdXasqpLbCc2oDlNBRYTkPAcvoXWE7/gOX0tE92OauyfZQdhmcWHZn86b985tJeS5cJj9SHZzXhPRMq/0rwNdx4rX8dy1H9oZ1QRxGa/QJX/s/JsCxjRH1CBBb1jEnVKd8vxcB39A4G1xDT70sxVSAd5p9Rm+Gl1zAaMwQw4buK+CtCqs9WOZl6wzyYB5V/DuBBfUUIY1b41KvaB3MR0MV5tTSmQ2BS9apF9cI81CAeVP5jQb1qwcY/mEf9hnoyM5nNW2+iLMcnDtu03j5punJz3Suv4VeEcBrWFSwveL+fTLGuqPynaHSliuAB1he3K+YB56n14eF0ggd4bGXH9CPmpb7q46CAP05WiX7jpsRNUEXg+AUlBnnPoloaB+ZTAasfHIqriTJqfXiE90rxqObtjE+Nz4r7CKgMgVX6FFbm0MHs1z7NjBvU/gpoe3GgxhRVX3lf3bAMLs6nAnwnu8ev6p5fhbEof0mGw5KZdJj/KmBHRgyjMct8MNVnZHRjGrU3SeWn5ow6nxvqI56nU2VDWWK7OzBPXnOtN9QgXqm5aFBetysyr5V58lpLlA3HHmFcp8yJz9hx+qz0KdoOwYaDrvG4g/Pg8aLah9U+KF89+o2PVcbmvRH97k3wRwXMM8VLuZM7qC6qZHUH6KKjfbqo49BdVKk9nn7Be+H0S6nEdCKfKvMIVB+YH5ap8h8JyqFcnOmo3ir/7wkXp4HgSfFTg+7nHXZbwkqGM5yuQaXNdLLrDtNmgfzbJDP5cKCGVlUnKYsJeUzXYDti3hQmHDJg2/q1y19Bu+APe8LyjnD866F+lxPlYVmqdBlUG89CGJNSv92CQlMshMpzHIdc5lfl1zpdZWtimX8W4gfLhzLDmg97zgDXEH4fBKfywLww7ANYcnzyUc0+kLgPByXKSsTz+2BW/SQyW7Dr4+8RQx7KiTjsbVUQ/FPlVBVYTlXAcmyuD95pLQP+AGSCqCveaS3Dkei+Q0Aa/gDkFKdrvVTaoRrMwzSYUzVph2vSphFpkqfJfTI84uGF6ur4o5Kw7fz6tR8W/qgkvH8WwpqdAwt/VBLePxthzcmBhT8qCe+fg7Dm5sCahbDg/XMR1lE5sPBHJeH9RyGseTmw8Ecl4f3zENb8HFj4o5Lw/vkI6+gcWPijkvD+oxHWMTmw8Ecl4f3HIKxjc2Dhj0rC+49FWAtyYOGPSsL7FyCs43Jg4Y9KwvuPQ1jJHFj4o5Lw/iTCOj4HFv7QG7z/eIR1Qg6srRAWvP8EhHViDqx9EBa8/0SEdZIGS17jt6vh/ereOgIrlPqv3MmTQTyf++YFfstFlV+LeOXlJ+NOnux0lSuUD37L5RSC1wYiDY5FMA2WcwpRDoU1gxFrFiPWbEasOYxYcxmxjmLEmseINZ8R62hGrGMYsY5lxFrAiHUcI1aSEet4RqwTGLHwWKbz6+W1WprT+fXqPmjP8HJXOboH5ocYfvOGcoeeD5wUoD4wDsvmJJ/y/PiDssFvSHd3niKvhyKs7s5T5PUohNXdeYq8Ho2wujtPkderIazuzlPk9XiE1d15iryegLAKmaccm8zGKmSeEkNY3Z2nyOuJTjZWd+cp8npthNXdeYq8XgdhdXeeIq/XRViFzFOOS2ZjwfuxbT8hB1/rIb7g/fnMU+T1+ghLN085OQeWi7Dg/ScjrFNyYHkIC95/CsI6NQdWGGHB+09FWAtzYEUQFrx/IcI6LQdWFGHB+09DWKfnwGpCWPD+0xHWGTmwmhEWvP8MhLUoB1YLwoL3L0JYZ2qwZNg6mY0F7z8TYS3OgbUDwoL3L0ZYZzn6OrY62Vjw/rMQ1hINlgy7J7Ox4P1LENbZOfhqQ3zB+89GWOfkwNoAYcH7z0FYS3NgbYiw4P1LEdayHFi/Qljw/mUIa7kGS4b9ktlY8P7lCOvcHFjbIyx4/7kI6zxHX8dfO9lY8P7zENaKHFgbISx4/wqEtVKDJcPUZDYWvH8lwjo/B18bI77g/ecjrAtyYE1CWPD+CxDWhTmwNkFY8P4LEdZFObA2RVjw/osQ1sU5sDZDWPD+ixHWJTmwNkdY8P5LENalObC2QFjw/ksR1mUaLBnUbq564v7LENblOfjaEvEF778cYV2RA2srhAXvvwJhXZkDa2uEBe+/EmFdlQNrG4QF778KYV2dA2tbhAXvvxphXZMDazuEBe+/BmFdmwNre4QF778WYV2XA2sHhAXvvw5h/SYH1o4IC97/G4R1fQ6snRAWvP96hHVDDqydERa8/waEdWMOrF0QFrz/RoR1Uw6sXREWvP8mhHVzDqzdEBa8/2aEdUsOrN0RFrz/FoR1aw6sPRAWvP9WhHVbDqw9ERa8/zaE9dscWHshLHj/bxHW7Tmw9kZY8P7bEdYdObD2QVjwfnVvHYEVSv1Xz7nuBPF8z5WiXgiVp+oB42D5tYhXXn4yz7nudLrKFcoHP+e6i+C1gUjDa453EeXcRZRDYc1mxJrDiDWXEesoRqx5jFjzGbGOZsQ6hhHrWEasBYxYxzFiJRmxjmfEOoER60RGrJMZsU5hxDqVEWshI9ZpjFinM2KdwYi1iBHrTEasxYxYZzFiLWHEOpsR6xxGrKWMWMsYsZYzYp3LiHUeI9YKRqyVjFjnM2JdwIh1ISPWRYxYFzNiXcKIdSkj1mWMWJczYl3BiHUlI9ZVjFhXM2Jdw4h1LSPWdYxYv2HEup4R6wZGrBsZsW5ixLqZEesWRqxbGbFuY8T6LSMWXnPMtU9u39S1bp+cug+uO+FXM8vRPTA/xPDbh1fu0Pvr7ghQHxiHZXOHT3l+/EHZ7Je65tj3tz/CKmTf3wEIC96f776/gQiL2vdXT9yH94nO1JQjg26f6ExNOXcUWM4dRDnUe4ozktlpCadrXakvwuB3H+EXYWagtClEvfB7irCP4PcUoQ7i9xShTuH3FKGO4PcUYZtXOZn3FNX7uEpGh6bia1DdVN+dlPrtFhiorytiOcJ2C/n8d5yuzyZkwPoRB3lCRSqnrEjl4PrMYCwHYqljDqj+i4/vyLf/wvtn+mCpow1kUO/4wn5aifIfk9Jlib06OmqD2qOeAHG7auqq7lV9BI9vk1K/3cKCp/DnmsGP6MZHWCdsU6Ds8tEvWFYtwuKWna5ukH+sh3C8DuJHzMkTq4ZIM9GmszX1psYQileqHn59E5ajOwV5roYvmF/nPykZQh+GUYZhnQwpH6w7pyAruQ1H+fCXlSlfFGM56PdwFFfu6E9Bhm1a48OnKjeXHYf3Yz9sJuKL+q/KwXG4HIpnVQ48zwKeSns+OptB6R08Mgfeq95trkT5v++XwbwohUm95+XXV0KgPKgo+KglVZ7fUUt43FP5LwfjHj7RcjKqM6wnxbPChOeNQJ7VuR+Yh2uQH2lojCT9SFVWPeIXtw+uC9UmWO+OJOSgky30U6AfA/PfmKefAnUU+ymQJ3UvNefHpzFS5ejGyVqinEL9A6ocimc8d5MB9vO7UD9X+gD7Obx3q2QmHeb/APTzezT9HO8fwj4Ntn24n6vy/Po51huV/35NP6d85q2S/jwrTNjPIc+4n6v8D6J+bsivIfu5Kosax3A/z3cco+w4VU7vAsvpTZRjerzsjcqZzVgOxMLnMPn11ydQf1XtSvVXPG7D/HeC/vo06q9Q33XticeO2US5uM84TrA1St27ydhGyaAbO1T+lzVjh24OIINujqtbE4b5YB7dumm5pgyoTzBe+axwTJuM8s5BeWdr8vrN5+S1On3Z7Jy7pVX1Bbj2q4JKm0fwrNLgO9n7JjP5cChHv2GdpK6sEeBEZ2puOM8HE8tUhpnJ7LyqzmUE7lyEC20Altduyew0lff7VF+Q/f/zPjQe1hMZDkzhmZ1XtrTh9oUBty+WDw5U+yq+Zfvunkf7wjacj9KgzcZn/MExUmFI2fdKFVqqfak7/WX3AvsLJU/8LALKU2FAeVYijIl1mTw1ddk8qTx4vJBB9R/VZ5X8Koj7ZcC+n8pflypTyufSYXT5uv7mOLRdgHLAZ43Oc2heqDqrvGshfYR9jE8fo55qx6MRz7DsYwyVHcRfg+XXEfwovmuJtIoCeG3yWlrCzdHOpkR7c2tTUzyE8BWvOA6vHVJnddQT+ZWsFxiRdaRTdbXyZAb/WCBXGSpA2jEorRKkKR5lH7piWDb/xxriP4j8YfkNRP7tQB3yacsGohw8VysEa3Y3sRqd7D5AjYXQt8FjIfRflH2VdnlLH7scxNYp24btPqwntoObIVsHxz9GHYpS/ii2dUcbKjuorVPl1zn+bVtLpBVi6zqbol400dbU3pmIxDtbEiGn65hQTsRhW0fpbV8iv2Fb4VK2DtuzCpB2NEqDtk7xSNk6M+NixA0if1h+A5Ef27qgbdlAlINtXSFYs7uJpWwd9IOwnwptHfZT5xL1gbYOz8u2QTbJzCcd6DVCbFMhvzLAOfRcICcsX4wD46DfDO/BazYq/y7Ab9+xjuZP1WE3gj9q7xKs1251/vnmEvnkVFn5UZPjs3Y7JDYj3rlbvGNGfFa5Q7OHq4irj6dTDsonA/5y2VT0Gy/fJBCOGoKDfrlM/YdYVNNBbDz07gWmPDchEwaXqRinuU3UMq0K1JQTqxAM1DRX8S3rdGse01yoVngpHsoC5sPtGuSRW4LglfqUQMjnvyoHx+FyKJ7Vb53Z8Ovmc0A3n1yXyY/7TZDtR0EeK8M4mD+G0uDjppAGHy8dHA50vxbpCXQPVD3SH9oEaXz9IuxJPu4HfGD7BF0P3H+oR6nYBdNti5JBLc/rtslQugV1SekI1c7qnmI9xqbKqSuwnDqiHNN9tw6V4/fY6QSfPun32GldkA7zXwMeO50coD2pPqPyGe4zYarPQPsRpM9QjzOD9BkowwYi//7J7DTYpviRHdSdQ5PZPOSjo/h+lc/stpWWZsrNVoFys/GjYbjkrY5cpR4vwEeIOFC+gKqv1JOn8/AFYFthNxX2AcU39cgRb6fJ91E6pS8YC77CAm2/+kQN1vtKn7L9toxcDsZI/AFOqm9QeqnyU1slqTGGelSNt0oa2kIcVbweBfjE8sXlQx0tA/mP0uTH20ow/jwf2an8MsA2xo+n4asRWNbwXrzcdiNo723Q1/PmaepD1Rkv1em2nIYQ4UcoMsxNdi2fegQiaVLqt1tgwO1bAcqYT8gDP6q5G43JalmmnKgrJdejiXLhUpqSSSXKfzdox72GZ2Mq3no79JiG2wQvzeK+vFkyO13lvw/MF37nM4WXAfowD9bRZdc6tB5iXucSvMKxZUEyO13lfwDIa9/hNK+QH4pXqo/CjxDn20f3QLyq/H/R9FGdLlE2F28NoPoo5hvbsKB6ofI/BvTiEaQX1HxE5nsFyRpvf5BBZx+wPZ2U+u0WGHBbwn5K2Uvcls+heqn+W07UlWrT+US5cIkU24f5qFzKPqgyYJ9rB+X66XElwbMMuM+p/C9p+hw19lN6QL1ySvVX3CZVPvlxXVT+1wOuFUB/W4YKkMbnp3jkWgG0qZXJ7HrP1shJhjIfOcH81FJwg5PbJuNt5DIO+qrqOGq8jfwrYCc+RHaCmmsbXo5vC6HylGxgHCy/FvHKzE/6lTDqE6i6tp1J8K/mjFR+SncoP18uG+B1ggaApcqFr0bORnHU+i9eZ4FjDBwjfkC2gZo3U68aYLlUObRP7vda5rc+tgHbQSVjaj482elaD2rNBdvefD9/S62r16D68Opp/tvaEiiN8rOprUlq3SBElEOtDUB9PACMPzgf5pWap9U7XccSvKaZQPz49VNqTRPLBK/nU/9VOTgOv5II270B8ZzvmgXV36l1ue7y3KDhmfIh8dhgaN0g8NgAfSvIq6mxgVpz0T0joPypOZr8Oj8B5odjg+IJ6grc6usgbBVH2UPs3+VrD6lH4tRzOrxtnfrkt7TdY/vS/EDfB96rPo2Mn7UdDdbg1+ybXX/dOrLudb58ZUM9n6HK6VdgOf2IcqjnX4XaDIpnygbi+uRrA+H9xbKB/VA5fusrrUg/u/sq4f5APzfU6KdOb3SvLZlYO1+Vr9X93Orzc+4juzD1kW1BH9kd9RFqLq17ba27cg5azs+hPecwlgOxgr722YH0Bq75BdEblT8M9CYRQG8o2fgdeQLLLZa+6bAoXzFE8BzEd6V8XWqdgpqPKl0wu83cC/xaiyq/FvHKy09mnkB9GvcoQnZ9nMwcORaf6YVbN493zJh3xCzcGAqwwckW8jwEqPI76De+TzJVgfLMJMqQQSk4ViQ8ucUTEYwfhKdceXOlU53wKJ96Ok6wTgjv9+uEfu9l4/fRVP6jU4Yo6HvZUHnyeS/bz4CUE3WodWhDAh8EUQM45Imqs8p/gqbOc3LUeTtUZ79zj+BvnK+cqEO101UHIAYlY7iPvDv6BO8v1uDeiMrxG3QXo0E311kLHSAd5h8NBt2z0aAb9KwFfJ5CvnKmyjEtZ3ymzhxNffI9L446n03XTh0gD3ZElK2uIDBlwBvcVf5LU21p+Iw18l2N9HvFTlc9hBsJLmfS4X5Ah69COqzbaEXZke7qcNBy/PpKyOl+XylWfXRYusXSXGdfWefQenE3iA2C5Vvv0L4ayhZyUIcW36dzaHFebAyVIhXq0FI8+eXN16GFK1Z+OwIcR6/YlEOLdzSbedofdnGbwN1RsDPhFbdZoA6Uo+b3pkPIBx8bSviSHiU75RzhJwoPAGd2yIifrqm26u/Dn+MEayt4f7HekOiPyjHx1EAGOFEKohvrIr78nNhHkANAHeQJHQA4iYP5/9iQwXwcOQDUanR3V+yxLjpOsCc9un4QVK+xjCoITBn8DvL8CDmEZp7ANrm6VUmzT6ObAg/KeDcFteuzlkgr6PCUloTnNje3RBLhWGu8qRmPXYpXHBfkSfVwIr/ZFb0oeXgKdPxlqABpc1FaJUiDT7zxgQJmHKZoZxD5w/IbiPx4J1XQtuTEUocA+C2mQPsQ9OB9lf9TzUIQ5dTPJOqjO2i1HP3GtgzbKhkmpf7nauFEjuAgufUieMFvAKi8XwG5DB+RXRdqZ4WyHeWaMhwiLuT4yw6XQS0I7pTMTpsTgDdqwQ5i+O1CkRjUpHsYqku+iynDCH5MPvmCZebyX6rqM/fA/un35GvvZCYd5r8Z+C81KUxqZ53fpD7k0L4DtinwMDpqQRjbAZW/b4qnoAeR7w0wse+kMIMeRK7y90/xYHhHG7mgpcoq1qkIGKvCybzpAO3jjslsWan8L6VkJdt5aH1+mDv7YG4JMEfkibmLD2YLwByt0fsBTnZ5+e4ohffDUw2wzDkXZBT+FDP46Q+EHELIAtZJlV/oDlpYVq3TtY1MLGZRddO1M/yYF+5LFNYheWLVEGkm2nSypt6w/DoNr1Q9sF9BlTOAkInKf6iGL5hf9WGo++peJUP4kTRGGYZ17Q0/2qbK785HX1SGwSgf/ugLlP0UHywH/R6M4sod+qMv0mbunPIbqHGpjw/Piodc4xK8H+t/qZyQBHnEoRz9hnzL9h7YmMHF+SAG1mO/D2lSNtcPg1r7zNXvZYCL96qfzpw1fUZ85xlT5sRmxbeYE582i9Dfaie7fljv8IldU1BefOKJSsMPZw9Bvw9Hv6cR/OCAZQJDHZHPL+TqH2uA6+70D3i/bl1xZIHljCTK0WGtQWDp7PdIIv8vxX6PRfnU3K4Q+z0WxfnZb8wLnD/BgyrxmrfKfwiaD5nxSdoidU5Xm6bqoso+1FDZIVSe49B+qSq/juBH8V1LpBWynhtujXheq3gUHHejbqzT1fUxGIf75GFE/rWI/ErWhztGZE0eEHsYkKsMFSDtUJRWCdIUj9R6rhm70RZI/rD8BiI/Xi8J2pYU1nbdxFLrudD2qr5ttq/n73/htzODnnSV72lWqr5Sn3YK4LdRp1kpvs3Oy4snQ6irOFAyVPXNV4ZQ17AMzfTl4skQ9lEcKBmq+koZHpiHDKGu4TVsaJvw6S2lIt8QSoPPobZNZvLhkEuGbXnIkFoHL3e6yilBYOF5yIEEP6qe05xs/mH7yYCfa8H7pyGsI3Ng4c3S8P4gb7RBrD0Qlm7/wuwcWHsiLN2bMnNyYM1CWNTzJYU1NwfWbISlOyHoqBxYcxCW7nS2eTmwjkJYfqfBSZqfA2sewoL349Pejs6BNR9hwfuPRljH5MA6GmFRh+5Tax3Qx6kj4lRfN/sBAS/vD+tQ8wUTa9yU3Cm/UMnuWILXBiINjtswDZZzLFEOhTWZEWsWI9ZhjFjTGLGOZMSayYg1mxFrDiPWXEasoxix5jFizWfEOpoRawojllpHptZBD0Xl5LsOCu8Psg5K2dA+TuaZwY/r5pvFjpg5e2rcQQH6raoM+Ptwn/IbiPsdDRa8R1cX6osCKr+y834n++E9HSr/k2BPRy1aozHzXLclQr3UpYJKw+MDTIN+q5p36E5OCxHlUHMSVV8pi7oAp2VTzxagToxAdTgclY/jsK7D+1U+qpyRBZYzkihHhzWCwFL5qTmF7tkCtY/M8MfH088WqDkeNS/pzrMFJbfhKB9+tkDN9TCWg34PR3G5ni0oXvxeAMbPFlT+H9CzhWmozEmp325BoTWie2/B7D711sDPFvAJWNT+TupUs0KeLSRaw25HJBF3myLt7R1up66P5XuSxBgiv9k9da3kswW4DiZDBUibjdIqQRr8mC9+tmDGbrS6QeQPy28g8uNxO2hbcmKpZwvQ9qq+bbavl+6zBbgnIZ91cThe4kMIoAzHgmuYpvjBcbjdxxK81hH3hXz+q3JwHC6H4jnXqX/1DZl7oF75nfp3TDKTDvNfBPY/N2r2bOA5OtZVqBsy4H4Cv9gUZDxU+QeneKL2P1PvVhyT9OdZlRH0/S2Vf0SKB7PjIr3/WZVVrNMWS+2rPXgPLVxjwHsP4JrBYSgNrgHgdT08p4dpcE30cJRGra2pNPjhbPxO6nEgDeooDpTNhIeyPJaHzaS+JIPnhFC+1D6kceAapilecRzWN3j/FJ/7sB0xvOfJM9yn0/uKqXe2YJ2wr0ut0wcZX2BZxVpHp+qm26sB1xnwOjKFNStPrBoizUSbHqapN2UTKF6peuB1QaqfjSNkovLP1vAF81OHDRV7PYCSIdd6gJLb2igf3isOdXCWD5aDfq+N4vzWAyg7OtmHT1VuLjsa9B0T6C9u30CXGfR9f5X/JOAv7gSu8ZocxIojWcRB2ozUteH9VR613uEg2c0AZeM50EyiPkHHbLiHakI391BB3iAmbL8jQB6/tecDgD/daxiNGXLoOQT26ZVOBH2nUeWPaXx6lafCp16H+GDOBbrY6aPrDoFJ1etQVC/MwxTEg8p/CKiXWtd3nK72F+qQDDOT2bwdRpTl+MThMecwnzRdubnuldfTwTVOw7qC5SVJPZ/ykynWFZX/SI2uUO9y6PaUYh5wnkN9eJhN8CDHo96p9I7pR8zzeZyFP9COXwHETYmbYDKB4xeUGGT15jbQOOq3Tv2o7a/w3kN9eIT3wjOuOuNT47P8nveVIbCET2FlDh3MvhfV3EbtwVeB2keIxw3Yl+MobSpIg7YXB2pMge9TBX1uNqfXT9fF8kmC+BoyHJbMpMP8p4N+h78EOwXwQWGqPXkqP+Vn6g7CyzVfU+UrWVJ+v65sal+jys/5lXVYPuXvz8mT1+2KzOuUPHml9jFAWy2M0ZQ58Rk7Tp8Vh90Ds+Gg6xoUh/Pgba6H+rDaB+XDy8j4iBE8PuDX/KYS/FEB80zxUu7kDvi84vNBFx3t00UdR7+dgtpmDF3L7dHUgnqEolPHIMdyQNMEMfCxISr/5RrTNDdHvYMcKwWXQPESMPUxVeoxH1zSlaECpDFO5TupD0NCGVQmg9eXkg+1BZg6nrEB5Yeyoh614GVQOITBs3Lrkf7pPlSr+zioDFj/4Dng5QTG4clMOsx/u0b/qG3O1HmzKj+1lRkul+MlYShfdS+lf/CVChkqQBqj/sUp/YMywPqnqy8lH2qbMHxkoNq3AeWHsqKOOlJlUvYPfqhZHXVEPcYN+fxXvOI43aPt3ZLZ5Zg44kkG9ZgN20vKlZPX66aulasPZc/5+A33H7gEcTTBD/7A8aNo2eFYIB/Krq/rZOc/higXPmJKoHKPQeXCDyvjJWcZ4HLg44jX+QAbL7vr6vwRWHZ5CtlJys3ER2M+C3gfNcL/fjwGQl8NHwHgd9QalD+sJ9RNbG9V/pcBn2NSfFI2Dy6fy1AB0hh1NZHvmEuNCboxN9eYgMdV2D/w9IeaSkGZ+01/qI/UQzzsi75LLL9R09O5iPcj8+Q9qA87C9QDH7eraw+Kj6MBFpUf9l+Y/zNCJhgT9gXYxvN8ML8EmKvnidnhg/mVxp+hxl/qXHVsd2F+OCYrfqjXqY5FaZB3PO4eA8rHeTtR+dTrXw5RrqPhF4/ZufjFNlel9e3303+pS2Wp6xqn63hj4pEp1ZZrEvUJ2pazNPXHWHB8xfpK9aFjCHnV9KMxK/PE7JPCgeMe5SvNSGbK7ovKpmwItFfYNs0i+IK+ADW/wY8BFW8DAP8j0PJj0ecAXtylxkMoRzwecnx0GM5B8RwA5j8imZ2m+1YItTwWdLyBR4xeHuBbLKrMXOsV+ySz86t6QxsPdeZgkA7zjyN0RidfatuHTvfhvBQfGwrbCs67frw/mUmDxyzIUAHSTOurzn+j5DO3APlgfaXm+5S+4tcFufR1MdJXygZRbYn7T9B+iuVU5ZMf+0AqfyvQZT+/CvKge1Ug6PoCNcYd49Blw74JZbJVMrs+Kv9GpWTPXc+j+geUK+4fOhnKkK+PiNdtqNdJqf5xNEqj1mqD2l1d31H3wo/A6j7Ymm9/xTxS82XK1qv8O2lsPTX26mx9rj6NXwGAtkPdu+rm6rQuQxkEsfW6+U4hth7PhamtwLls9y4a/fNbf4G8TtbULdezEWwbgz4bWZVtX8xnI35+KZYVlAnEomwDtW6C/a1C/E01RmGZ+PmbeG1S5Z+Wp7+p00Or/c1u6GGp+ZuUDYLrhK0aG4R9Pkr/dP5ZLhukW38+yqccmE8G6jVQGSal/rsFBt0zHcPfKW0KofKUPGAcLL+WkCMjP56uXak1ALOfc3Kj0kxRz+OmJbvKxs/uYBuunqXJsCfAwa8iUZ+ak/3pDLTWRPmB8F5VBvYDzwZrZ4sRJvW6GrVXg3o+D18nHBtg7qhrc52/Mg+UQ+WHYxPMf65mfkjZSt3aU65nMfjzedTzeVw2td+AGktV/gtLan4Y9lb1M388ZunmjlAH8VFE1FgE+wXuA5TPBfur7tOLqsw5OcosC8Aj9bo4NfbiT89BXVE8GtaVcL5rw7r6UvIJOkehPi2LjwWjjprU+eDUMbuUr6Rwpa6ckGoMvKZ/N+jj+LketU+O8tkx5r15rgPo9DDoXIfyw+Zp7qP8MFjWpNT/3B+2C/bZO2UDejn+Yzu2v38CclSfvaP8kmx+CwvUWkUIyQnaM8Y+G/hzoqr8UvvGt9m9Sl4C+oxQf6HP6HfkKFwTw/YO+oD/RP4aZQOgnVsHpMP8TwIf8DEfTMcp7PnBE32ycbnX0HTrG3g/AbwPP7ug9hNgH8Vv78TBIB3mfxHYBt3eJMWX2WdbiVW+do/X53VHZ1L6B3XBb79ulaPfF4XnA28T84Egzw9m58k79Vlb3M9x3/kn8h1hmbMClNnd5wcyqGfLeN74aRH9hp7nB13zd/f5AdSXoM8P7krZbmrfZ5Dj06n5km7Mgvo9CKTD/GWp1zxL+f0OJSfD+hde1c8wVPsGeb9Dt3ZMHXsp9e/8lP6ZlGNLq5v2aVUbwmOrYKgA6TD/gJRO1oJ6qP8FHXnYEvMSkVgi1hTr7Ix2xPAxVDKoNpOv0Ul9qG/MyEzJiVtmMij8SjP46X2J8P3qcqJOqnylS/i1Zeq/49BzFlVWLcJirpunqxvkH7+rUYH4Udd+WBV5YtX4pE3iqXe6Tcs19cbl++Wn+oCKr9Lgw/zKrkMdrkKy6GVGFmFdu1WBMlX53TlmR/0egfLhY3ehvCt9sBz0ewSKK3foY3awXapzutZb3WPYpoSD2gFVfq1jtD+k7UAl4sev78LXpadOj3WmTm7AJg83HRQnhMPVxk2XHhZRHFYHfAKEcvWoIRTzGSIwKBEozHonmwd4L2VKyn3KdZyMumLzkQtLXZdrePHDCCGMOg1GT9fp6TpE6Ok6wboOtzcebm1tbgu3u9GWzo5EZzSSyxvnLr+jvbk9Gm/vaPaizZGo25nPbAB7G3DWXU7IrxLl3w3MuvETqDINpgz4pAaVf0/NTJ7yiqh6BjEDkJ96p6te4RlEsfSpJdba3tbRFo1Fm90Ot6W5O+1J1RvKXn2gTOVXnmWVo59NVaL8HaCt8K6JKnCPwto72RUT8wzbB3rs+LBnlX8y4GEcWE3HcsBDIvSmGYegjhAqz3HoIVGVX+sYHaI93B6KHywf/CTM0AynPYTwIT+9CPmotqwm0hSWWgmCtgbm7wXqCPPDa3U/jJud0q0GhCmDOn0hRKSVE3FKvpL36ch1g20T8vmvcHEcnsFD2WAbBu0nfHI438d+QHnCe5X9wH1xUWMG89jUNeVf4PbDNlnnJ8Dy/OwVHq9U/hOArcCHE+LxCtYT8wjLqyDKlQHbK5X/VLQSZ6jfk4fTq7Ko8S7k0PJwnGCrUNT4WEeUo+TV29GvtOjshG7FS/W5Kp/8Cq8S5T9bM5ZVg3vKCb6wL6PyL9P4MjVEvah+reJrifw1RL3qna72T91LPZVQsjd8AkYH9VQCyrAymVs+vQqQj9KBBpQfyoqyob1QObmmlvgpLrWKBm0u9N/qifJxPan+UEXUU9cfqPph3b02T98Ofsijlw8PQX07lf8GwMNaGt8OjmU3Nep5xfYGzn1g/jvAWHYrah9qFZSyg+UoDbalkhG0g1UELtWfsU5QfQXmx7620v0qn/zQn4L579XoRC24h/Ivsc+g8t+nsZG9na71gvMYLIc+RP7eTlc51DtdbUAfhy4b1gfKGX+gR+V/kKgPZXfhEwUZKkAao90lT/uDcsV2VydDGbDM64j8UJaqfg0oP5Q/1Xd6ozRYbjXiIdfcBttkyt+AtoNaXoUyUHzWEPXla7uOwB/iVuXXOl113sRcMqiOKPnUmZGPq9PBOkI+ip++Rvhx0x9pbCDKVrymNkpl2RWYvw7IEOaH1+p+GPcW0td6cJ/Cb0BpMuB5LEwrJ+LKVhFWA4EF5abaVPbjF5As8Mm51H+Fi+Mwj7A9lc7rbER3y4FYyr+h+pOkSanfbkEhElb16EvUQ5UN9Yqv7zS1BLV1qvxax2hf9nQ6DOWD57oNBK8NTlcdPiGZyZdLv2E5FNbKEsVaxIi1lBHrXEYsTnktYcRaxoi1mBFrASMWZx2XM2Jx8nU6IxZnf+RsxzMYsTj70ApGLM525NTVCxixOPXrPEasixixOPW+VG0OZx0vZsRKMmJdwojFKS9O34RTv0rVL+TU+1L15RYyYp3DiPVL8OVKVe85fZOeMS0/rFL15UrVFnL6cpy2kLMdOeVVqv7X8YxYpep/ncmIxdm3OfsQp7w4xyHOPlSqsue0X5zrcqW6NsSpX5y+b6n6mKU4dshr/MyKY+ygnvXCPYo1BB+cz3sVfqMhfCWrfhpZwfLxs1+VTv1XWDhNlVWLsJjr5unqpntGDJ+HQxn4YfXLE6uGSDPRpg2aesPy6zS8UvWoY5RJJSMW3ttG7dmgnquq/I1EfkpP6omy1b2qbfuDNMa2DevaFtoIVX533t5WctsT5VMf0C5zuvaNfj5YDvq9J4orB3gw1Dtdda3ah09VLo7DugLvr0N8qN9qzwvcA4u/gln8vQvNkaC29eeyd+GkZCZfoWP5hYxYnGvnnP5wqa4zcNaR8xluqT5PKdW1p7MZsX4JOrGMEeuX8KyhVJ8PcK7VcdaRc52hVJ+Vcq49cer9WYxYpboOz6kTPf7Xz8NGc461pzJi/RJsYak+yzqNEet8RqxSXe/mHNN6ng/kh/VLeK7P2YdKdU9Yz9jx8xg7evZBrDqd6FlTWHV15HxXoFTnQ5yy59znXKrrhZx+To+dWHX+RI+dWHWyL1U7EcT/guf44XNzqXMWFFa/HFjbISx4fz+E1ZgDaw+Epdv/ALEmpf67BYVIVD1D7g+wQ6jcASCe8Xl3PITKUzKCcbD8WsQrMz/p5+8DED9YPmVIPgPN8NMZQviQn4GEfFRbDiLSFNbg1G94jgnMPxDUEeaH1+p+GLciVVADgdmIeBhE1AfGKfnKvUfnpHDz6APhjoQXaYq3NLnNsWhTZ3Mk3BlucTujTQnPa/XCbdHWSCTREW3tbA1HEuGWcEed07XdcR8w1MbRoH1AlV/rGO2Tnk7nBhBtROmcuhfrggwzk5l8+egCp15RfKmz7OqcrnpWHF2ItHdXFwztY9XqQiMh13x14eRkJl+h7beQEWsJI9Y5jFiLGLHOYMRawIi1khFrOSMWZx1PZ8TirONSRqxzGbHOZ8Ti1C/O/sipX5y2kJOvZYxYnHr/S9CJsxixOPVrBSMWZx05ZX8mIxan3p/HiNVjJ34edoKzjhcxYnH6E6Uq+4sZsXr6UH5YpzJi9fShVSd7zrk75xxZPa/Aa0gyTEr9dwsL4RqiXCbsqMIezI+dfh97SOHYnThCYQ/l5zuhsIexY0ea1Foa/D4K/F7GGikFUro5PJUHruvD7ySUgXSY/+SBGczxqWv87TwHXNcgvJDDueYYTn+9HZZNrYGq8msRr7z8ZNZAyxA/WD54DbSc4LUBpclwYjKTD6eVE3E6rCWMWCsYsU5nxFrOiHUBI9YiRqzzSpSvMxixFjBiLSxRvlYyYnHqPSdfnLI/hxGLsx05ZX8mIxZnHS9mxEoyYl3CiMUpr2WMWKXatznHDuVPUN+wVN9mob7T1huVR31DUgbD3wf2FH61Gfz0+UK5vhOoytd9Kxn/V1g4TZVVrG8ZU3WjvmXcgPJjGfhh9coTy/A3k9NtqvvOGSy/TsMrVQ/8zch8v7NereEL5q8nylb3KhnCb3YyyjCskyH17cPunM2k5DYa5ds1mZED1sFePlgO+j0axZUDPBh036unvseryoXfoRwB0vG5TiNAWeVEHO4v8P4RPljUWoMMhyUz6TD/Gan1BeqbkSMJ/nS6O4rIPxLkUfxQslH31hFl52NDIV8NBA/lRSqnokjlVBepnJoilVNVpHKwfR/FWM4okAd/N340YzmjQZ4+qJzVGMtZDeTBvt8YkAbtjeJjdYIPNT6NBfGM41Pg/buq/FrEKzM/aV9rLOIHywePLeMIXhuINLj3FabBcsYR5VBY5YxYSjfqna66sjoqZwxRzhhNOasT5Si9WhPVZ1Lqt1tQCLeodlnL6RpU2ngQd2kywwcO5eg35Fva9IngG904Hy4TynU8SoN9bAJKg201EaWtAdLWTl3XO13lC8uGaaqOOA63I7x/TU05YwssZyxRTh1xX6G2kpINbieOcqDcxqJyxjKWA+U2DpUzjrEcqItroHKGg/vg87Zn0PM2dR/0geG96r2uSpT/q6EZzOdTmMqWjAd8MdqSNlW3CU7XoNImgrKxzq4N0rCerQPSsG6sC9KgzHGg7JOShbRP2+Vhn9YCaapOqg3U/e+BZ55voWeesA3xOyFw/MTn165BpEn8M4dk+IEykj670hv4fXqsNyp/eeqhvtIVPI5OSv12CwrNLTo7ZVZPmwN/SxiPO5AfxXctkVZRAK+JjlY34jY3d8abo+1N0UQI4StecRyet04g8lNn+ypZTzQj67DqC+XJDD4cs2WoAGnjUVolSFM8yr56xbBs/icY4j+I/GH5DUT+PUAd8mlLk1jQHnBg9eomVqPT1cdQNsesDQq3Uv6tCngsk9f1KA32mQaUBscyfFY/HMvgWh8O1HilZCH7QGce4xXlM5eSPyADHgehDOF4i0OucX3MyAwuzof50c0foI4q3szan3CMkhPmGcoJ6yjUNayj0G/COroeSMtXR5Us8tVRqIewThCzAsRBX33L5E//K1H+NVL+jKzD2EHZ5Y0BZaiyZb6LUL6JBN81BJ+rYr1HlV/rmBzHM+s9ayN+sHzwes86BK8NRNogcA3TYDnrEOVQWJWMWEov6p2uOjoRlZPv+DmRKEfpFex/jPYkodplfadrUGkuiMt3vUfxne96D5Sri9JgH/NQGmyrMEqD9i2Suq53usoXlg3TVB1xnM4PWk9TztoFlrM2UU4dcV/I578qB8fhcijZUL5SoeVQ9h63OUc5UG7roHLWYSwH6uK6qBzoA8H1nl0GZe6B98H1Hngvnrer/O+A9Z7d0Rwe9oNVZUsonfVAGtazMEjDuhEBaVDmOFD2Scki3/UeaKthnSDvQX0Tlb8dtZMhX8JtRPWiZEr161L1cczMV/Q+DjWO5+vjwDOOsO3J1y9ZkxFL6Xa94/j6JSGUBsuZqCmH8pd+qT4OZUOK5eNgXzVf3wPe/3PzcfA8fyJjOVBuv1QfZzGTj/Ms8HHORmOnofUXVh8H65kpHweuv2zHNAcbA9KotZIQKtvPF9oi+dN/vE5zOVinuXSQP19jQNnDBmfn61mn+eWu0yi9oPbl4LFvDFHOGE05E4lyfqk+DJRrsX0YWDZMU3XEcbr9JT83H2YMKmcMYzlQbr9UH+YRJh/mz8CHedzCdRqsZzat0yjeg/omKv+rJbROQ/Vrs8/Jg/s4qvxap6vdMOHjUPt4oXywj7M2wStle/A6DeVLrU2UQ2GtyYiF12mofck62ej2OMP78f4L2HcZ7VInHv9hoMbLfH0cxXe+Pg6UK7aFsD3XR2n5ru/UO13lC8uGaaqOOE6353QdTTmFrh+uSZRjeqwu1l7dYu2lXlXrTn4+Tu/BmXvgfUF9HJX/LuDj9E1hGl6nycuWUDq7PkjDegb9CKwb1PpOUPvU3XWaMSAN26egayVU3zH7rknw73DgvbWG/Jq0H0G9d0GNlX2czHtwk+Ozdp7dPnVKx3bxeTM3mda5c2zGrCmxqZt0ds6Iz5wJa4O1BtcWawvOo67riXjHod8sGedTPqyh7s0SyhoqLGpnMZSWepuZ4msCwpqYAwt/AQfej1d11s6Bhb+AQ1lIPPJRvRp7bTA/5GedHPzsmfTnZx2EtW4OrFkIi5rhKqz1cmDNRljw/vXQfev7lAPzQKu7PlE2hY/7h5uD5znJbJ4hX3gW6OXAOgphwfs9hBXOgTUPYcH7w+i+iE85MA+cbUdAOSEijuJnftKfnwjCiubAOhphwfujCKspB9YxCAve34Tua/YpB+ZpAvHNoJwQEUfxs3fSnx91b5CRFPLKOHJ1hlB5qh4wDpZfrJE0l1zxjLyF4LWBSMNjUAtRTgtRDoU1gRFrbUasiYxY6zBirceItT4jlsuIFWbE8hixIoxYyiZSTzz6o3LyfeIB7y/WE4/+qJwx4D44qz0MzWqVDsJZLbxXjUWVKP9VYFY7LYVJrcTpnixhvzxfOVPlqLEG6jCfbc+cEAzHcBVUGhznhoBrHKhZsOI731U6KFc8JkM704LSoN1oRWmw77alruudrvLFNpHyA2GcTo/DmnLWL7Cc9Yly6oj7Cu2XlGxM93+8+ro+YznU/IF66l5oOdTcIpc9W4LsmbrPz54pX7YS5V8O7NlStEoH+8GqtCVYZym/RKW1gjSsG20gDcocB8o+KVnku0oHbTW2T1SfqHG66t6qeIqnyq91uvY5E3MGak2AGgMp+63upfrTUHCN+205Eafrm+MYsdRcUuc7hFAaLEf3FI/yNQz7BxH8tB+GOlRnGfJ9itdd/wDKNYrSYB9rQmmwrXC/hXZR2SJq3Mb6ku+4De//ufkHxXqK90v1D/6ap3+An+Kp/CcD/+AfyD+A62Gl6h9gPTPlHyhZ5OsfwLl9M8DH+gXzwTakdN0h4kIEDu5zrk/5MhyQ/Ok/tbaOv/pOjeUwDuv3AIJfXX81O5b9dJIyLE/VA8bB8msJmZjwkcIB5UrpVhjJnNIDrCOwnAhRDoWF7aBuXdw1I6/APq4qv1jr4pS/SH3lvhj67dfO62v4MWPvM6du53o+pPiRp5RUOV11iHouhvmGz5FUnF/b6J5n654t5noeiJ9n+9XBr410z7MpGVSitMbU4pyU4deDs/Osm8pTC/L8F+0age2E+7ShZ12B+zR+1tVkhh/tsy4oH6izvRy97sC289sHsC5RV6zL6+TgCetyvnsOIBbWZd2eg/VzYGFdhvdjv0B3QhO14xzPQSH+jzvUhvjjr6/BdzX4YQ3+GJAP+6hw/h5BaXDuGQX4gzT4EzX462jw1yXwMaayG/UgbQxKU3mHpjCkj/zhSJpfhSGD2VMJg9sUVX6xdrRT+6GgfHRv7al7qZ2znKcFTGDEwqeomdlpHglTaxoqUOtXxdppDtsF93coZ7x+BfsFXr+CexLUOFGsHeBUOYXqywSinDrivpDPf1UOjgtyugZuJ45yqP2QuM05yqH2SmL94ShHt9Mc+qtwjWpTdFoxtdOc8nXxTvMZYI1qixSm2be0eHeaYz2DPiHWjUJ2mitZFPIMS9VJ7oJWb0hNjs/aLj5vz9jUKZ2xWVOmT9s1fuTs+MxZFQgWdx+s5hN92IU4joZdGcpQ2jiUrg7LLnPoEGTZwszwFNwdUeUXa9ki1xZm7I6sS/DaQKQNA9e4K5UTcWUarPGMWPijEBAbL5Xle9jjOILnnsMeew579Cun57DH7pVTCocIjAH3QbfnGOT2qHEx6KM5lb8duD3HIbfH0GHpVh72CA9L347pkBP44Y4Zyey01cF9Y9F98ONDCh9+uKMe3Sev1cfd6tFvea1eRKtEfF2J9AF+uI1xSt0ZxF9a01DZQfosLJ+abuPDCmBaIR/wCMfbO5pjsUSkI+F2xBJx3NcVrziuDJSPba/K30jkN/tibSSm+gv8gAf+SEcFSMOvOlaCNPjCK/6Ah5lDPSOxIPKH5TcQ+XcFdcinLakpP+zf+WCpD2VA+44/MAptE+6LZuxA8LmLKr8W8crMT3ruQn24dTghVyW7sQSvDUQaPgBtLFHOWKIcCmskI5Yae6ixYjgqh/oI7khNOcMJng1/mDCvj7PIUKwPE0K54iUa2MfwkhtsK79lMujjUK9PY33J1w7B+3UfJhxVYDmjiHJML6WOROWY+sgutrmmPrKL/cexjOVAXcSPIMeA++Dc5TE0d1H3BZ27qPy7grnLk8WZu+T9oSess3C5FesZnG9i3aA+WhjUPnHMXbB9ovpEqfoHI83wo/UPqDEwX/8AHx5WyJi+FiOW0ot6p2t743GFks0oTTmUffyl+gdQrrj/wb5pwj8wMW4X6wPJpv2DYo3bY1A5YxjLgXJbVf6B34eLa4Zm7vHzD3QfLlb5NwX+QZ/UtbIlZsYEXv8A61m+HzUOap+ULPL1D+BcboIPZiWRdwRKU3mHgvbaOHVdT9w/2slOGwHSVkNp1NyVGrcgBiwD6hzs54cls+ug8q+W4vvHj0WOoDHLfDCVHlPrZHCuLEMFSOPT3w5P8n3/sAwfUKY/1jeZXacxIK2cyI/XIim/A9oiJaMgPgy19jAaxKm1Nkqeq6XiVoU8IY9B5Anz5ytPJSPdOk/I6dpulB+rk6ficVXIE/IYRJ6Ubx5CMoH5oTxXS103OF1luAbCGk1gwf6O14JXS8VXEfmxTYL5fwVsTu2wbP6o9TaVNoLAhrY3hDBgPWqJetShNHivxF1jYDYu9VxC1zbUcYHjibKo16FL8UPF1PgfdA1gDEpbF6Rhf87v2BgcKN8Afvz4kwAfPw6hchQu1iOsM8MJHilfcHwO3Hx1Rsnx56IzeE0J6gzWJxt0ZgyIwzozhuCRWl/Mdcwo1hlq6zz02bHOUAcx2/QxqUL3UKg0+NoKlAkOlM7A57n56Ay1XhBUZ9S9cD8N3hY8C8xJTkC2aN0cZWO9ovZtwT6odLLe6dqv8RFd8D5GvYrXEbyqgHWO0oGgB1zj9SzqtTVK56BMcKD0SskpqF5R7ZzrOGCsY+MIfqmt6tRrmdQ+PpWfOkYVykbpHnUkq7q3hriPcY9EtI7gVQWVBl+nxHsv4aufeL2IOv5RpcEjGfA+K3gkAz4OFwZKf5Sc8rVL1NHAY0Cczi6pe6kjOHK9yot1hnodOqjOqHsN60xJHeWl0jYAabbpzBJ0pCS01/hYKDdgmSp/rtfSsf5R+gptvU7/8JGl6j64Jgf5x8fTqfw3gvnxCLB28CNPyUwZSk5m1zDcOLWGAeVamcyut06GMuTb55XMGpyu9thDadTxkrq9rdQxqdx+kvIdfi5+Eh7nYB/APlSp+EkhVI7Che0jA7ZZEwgeqQ/GUK/5Ux8d1dkxKH+sM1Av1L1mj02MuHUErypQbY/HMspu6tqempdhPYR9H8oEB0pnlJzy1RnKHgTVGXUv9SFFSmeo96h+qToTxF783HVmcQCd6bEzmTS8NvRL1JldkM6sReDC50ZB3r+AzzLxcwv4HAm/3wnvK9V9C2NQGvRFxqI03Uf5oJ5AmeBA6YySU746swbChe0jg+65hbpX6swzqWddtags+b+gd4I6O+Ne1Gtpa41Ho51tTfhDrzIo/ettoPxoU6ylI9bieW1RLx71cpYv5V/fmC3PCnAPbLs6Ik7hKv2vRPdO6mY9sFhDqDzHofeWqvJrEa/M/KT3llYifrB88N7SKoLXBiJNtUG9498mIZQGeaggeGgg7q8IgEXVp0+KZJg5a/qM+GaxI2bOnhp3UMC6gvt0mU/5IeJ+R4MF7zHRrzqamts7ROdy496P+ljsft3U2d7qtoRjbZ0dzZ2Rpo5ilx9vj7a1tLd1NLmdbpvXFsnHrtQ5XXUr5PNfhnINdgOBNTP5039lg2A/4rRBCr8X4o8J31NyqiTkpMquNlK3RCKofVXl1zpG7X3avlYjfrB88LuxNWbkE5dHOyrdgzaripAN5qMX4rHWEI/UmqniSaVVgDTFh8wzYVQ2j2WGeDTbRxOdlI8C9y5vMCxTLmwbuGYN9b4MpMP8Gw/LYP46dV3vZI9L0E71Bum9iHT1W7VXGZEXXuPfincsV5hf6WSVT12rUF1V/i1S9ZO8bdNIY0L5Qb7KfDC3BpgjUJvAvWu6Pq/y9ybywz6m+Kl3uvbN3ug+yHuNkx1gHNU+IZQXj8FqnIL3+f2uIXD8eKgmcPA4iTFxmZSvh+dS5UQ5sE/BMb+GKJ9xfGiixkoVKF87hNJg3Q9KZvLhQM1dVZ1kfddAz6tgPswP1dc4fSMVXwnicbnYH69CeeF4jmVWycBjA1FOFcLtpeE/hHAqiPvqHLo/Uv+D8hsi+NXNh7tbDsQ6OJldDmxnOKZNQ/YT2vFy4t5jk5l0mH8mGNOODDimYVsC6xBLZuKwzcZ+LO6T+Lk2HrtwHjiOw/xHEWMXtg8QS8bND+AjUH4f9hHOB/I8FsmT8gHqna6ywTpcg8qC/rEaX7AMTgZ8nDDMvywl1zpNHWXcqcPofJAHmA9jUGOnwqD6tbqvnuAL9z1sO6o0ZVDjGVVGJUortH2ocRv6GpQPQ6XD8RyWg+PKiPy5/I9aH2wKt4rAoex8NUoLEWnYhsH6QhuGfRNqTgZtI9Xv/NpO53tTvAfxq6o0vFPyg3aIey3HbXU9t6OlKZHwOptj7dFcazkqvlcyu14//gdxlaBeMlTD/CitBqRVJLPLr039rgDlQCzFRyXKfyNoaxmqwD3q/gai/CpUfhbfRBzUNYxVTsSp/LJNr07xaGKNLtzU1hpra3e9cCIcjrQ257NGp/x17KN0lxccKB8mLT9QdwfwwVN22AsRcij3kb3jZNa2zKyBZNa2qLX2MqKtzD5bCbtwbQvKaFqyq2woPmSg/ETs84WI+lK62eBzvwx1mnLUGosMsO/D9TAZlP2A9gXmh2sWMP+fgB/1EJr3VRLlyXxPafKFfP7/iEHEVSSz4yi7A+2xyq/Krk125VGl9QZplaicPqnfUF4QS/FRifI/juwxtKHq/gai/GpUfhbfRBy2x72J/L2J/LJ9/obGWFh37j7/Y5kIH8Zh3p4CYwX1PEX3nMDM+qoX2Jaq8ov1nIDyF3XPCXqZkY+r8wGp+Y5qy2oiTWFRa6zUmh/l58N5A54XvoneRYZ+vlpfCBFp5UQc1NtXNPPDfG0eHhOoeVkI/abWPWB/q0T5vwV2/X2fub/j0Guk6pwJLCe/NXa8TqHyfwzWKWqH0Zh+9fLD/ALU6zPUJpVEHWS+b3zqH3L0Mg1a/zIfXr/SrNNUEnWFvOI1VHiPzPe9Tz4Z4Dra96juitdyh95XsWeS5lNhUP8VHo7TrY9i22XmGfBP57dB+0DVG5cvqRbUQbc2odMpiF+L8qv7Kxx6rVC1IdapvqnNX7Jtq4fTPDiOfn1Bp9dB+mCfVLnU2Q9+eq34ptYs1D251oT7ofrmso2Yf5V/MJDhAMQXNd5T6zFwvRiPd45TeF/RjVtwTYdqZ9WHVd/qDcpj7Fsu7itQl3sT/FSi/Kuj9kw/63e69jmIo/L3IcqtA3XFdrkPKlfKeK/UNWXvoO6NQ7zWAmzKN/OrcwvQvbWQ7lHPj6jnu9j26MZSGbZKZvOi8q8D5KB7R03xZfYdNY88Zwf2g8pkdr2pZ+qU/6by53qmjvsg7Dd4PZTaI0nZWsrHg/tXsF2BYzy2dxT/NcS9uH9U+eRXeLh/bEjYd4wJdQ3KqcIHcxLQ+41Qn4PteEQyk2/74XTZsP7lRH2wPfHz2/ogXlX+zTX1703UH/J1XDIbU+XfiuhrmE9YL2psUPF9ifx1RL3qna5yUfdi2cN8UPYUBrY/qrxah7b/c5PZvEIsvG9M17f7ELzq2roPUQ5u6900vky1D59+/EGbgJ+HVBJYcFzhXjdvjjZ7ra2x1o7mjkRbtKO92HtrO9qaE22RSLsXaeuMt3nNpbK3FvatYs1xqOevIXRNrfVUacqB96t8ZteBMnOpasCnzu9W+Sl/tVqTH6/zYXy/Z5MVPrLDcymV/2IwJk1DY42ujjJgXxTv0cV5cNtDG0Dx7Oc/zgT2Cu9bpPbIQH8I+4Eq/xzN2ETZOd3YlMvH0u17wPsWdf4XhY3nObnGmxBRT7XeKIMatyCG6mN1CGdS6rdbYMBjaoXTdYyD/GA/6ySkx/VIpjqZSepLlKswoEwqUf6TiDkVrktvp6uuU22C9+xivdosmZ2u8p8O+vNC5GNSays/nlsynC4b+jJ9NLz2JniFfWZBMjtd5V8M5LWvD6+QH8grNUdTOrsq5mjQblUinij7QY1r+doPao6m2yeM7a9uL45ujPFbK8M6q/JfGHCtDLbzxcj3DvJ8ANo7ahzJNde8PI+1NRkOT2bXN71GMCKDeZUPpvIDZDgqmcmT3mfidO0HJtatlJyoNVjID7YzN6J6UWvL1H4ClZ9a+4XrXEomeL3mRsLGUvNa6M9Sz04dRlkGeW5rqB3bQqg8JQ8YB8sv1nNbah1e99zW0LOPVrgHBj7fg3tgYNtQz2tzrcnfjfoC7DOU3dgumUmH+f8Ixu57kf2j1t3rHbpvUbyEnK79xHH0c6pyVH+YhvcRwvy51uQpm47nplh/ZFD2FssDthv1vpcMfvbkzxq/n9qbq3tfiRrnqTkRtd8Y+1RU2bA++DkWNZeCbY/3L6v8j2jW+aj1fZ2NVvkf18iU8m10MqXWO6k5Ub3TVY59EFYumap+iXkNKlOV/7k81051MlX5X9TIlJKRTqbUWmsfol7Uuiee8+WSqfq2BuY1qExV/tc1MqXsrU6mKv9bq1CmsM516D6/51xw/grf16bqjNebqfcOMabuWRLG8GtLyqbhtvxE05ZUvWoD1qs3U71651kvlf/fhupV7lOv8jzrVZujXtjXV/m/DVAv6j1hGfB6m8r/Q8DnrnBdV4aKZDa/k1LxbkEh/+eulN3TPXfN5RvgeTvuozBNt2eH0omg79eoe6FPSz2Xx75arvcS/dZc61Lz5FJ+9q5b18n1PpCfjwrzU+/UB9n/ku+zd2odKOh6CPuZM9FIe8JLtLW0RxJupNUr+pk7MTccj3rt7U1ePNbWlij6mTue5yWao+2tzR1hN9FZ9DN/oomWWHOixW0Kd0bj4c5YscuPtcTbos2RcEck0RZrdVuLXX57Z3OH2xbxOmOxFrelubU7z2VhX1P3Ue9acT97xHyWE7JRccV63ynXmKOuqf28fmObDLslM/lwWjkRV1ZkLMqXxzafko1u/YUaj4Ocz2fqPI6gOoffsTPUB7Tv2FFypfaeVCCZw7EU6wk1zlLzQFuw1P0yUHtMpiez02AbY5kG1VXlu2Bbmo9vSb0DAPnFvuUuKd/S9HMUPHbAsgyfndlM+agqUM9RcbvDuQNuW2r+Se2Xw+c6wlCOfkNZyLJ/NSqDi/OpQOlICKVVEfWg9tjjsSZE8KU7C053vgQ1TsxIZvMMx0RqvqB8dt07t37+CPUuVjH2QsHyVL0ch+4PtU7X9irWsydqXkb1A9yeeH4Nr4O+O0dhBZkbBsWqQPWB7YF1wZAvGNhPUOXXOl1lakIXqD4XIuRK+aY6HxCe+YbT8vUnSx1LN+cJ0u5UOVj/YTl+75+cgL7rre7ze/8Ef58+PW6MzGCenMKkzmPGYwn1DFanZ2Wa+lPl1BD3TUr9d/MLURxh9hxVN0a9x6CCSutN1DlE5Kf8BsW3tHsTR2RwcT5cJvQbeqM0OA71QWlwzKxDadD2qr1/lI5gnyVfHdHto6b8k+6WQ/lPpvs8ft/R1P5zvNZZxVgOdb4Ttdey0HKo/SnUWA9t5bXIVlLPaeC9eK+1yv8/sJftejSnMrRnpw3PQWCg5iBYZ6GdwXoGn8li3YDPtvFZ4DBQ9knJQv7fLg/7RL0fHWSN0dCcMrBPr8ov1hpjrucdWAeo/aK438qA/aV830HR7WEqBEvJvFhrjIbniq3UM1UVqP5+aTLDBw5U/1N85+sfUHtPgvTNfP0K3XpEyOk6ZlDP0nE7UusQunNIu1uO7ixeU+NckLXv7pYD8+C5s6n37VaVv+PnH/wL+QfUM3x4L55LqfyfAP/gTeQfGBoT8rIllM5Seyso3wHrBvQdoMxxoOyTkkW+/gHUCVUnuOeWWjeixsWQ09XGUnuAVHnU2qq6t9T8P9y+eB8YTINtiNsX+n+4v/YFafg9Ahhy+Yb5fBON8h9gPryXJ0TwSPV1SgeoNSGVP9feJawz1F65Ul1/0PVtSi+wfYV6gfWwHqRBmeCQa70jH52h7EFQnYFnIV2L1sVgPqwf1BojdQ6AjkfdvqlcNkuVRfk+WE+peTB19heeBw9OtUGuvWpKTmb3qrlNq3q/In6GTtljar6B1y+oZ79wrRc+63LQPZUIXwb1nByv+f4LrPmuMTI7j8KbCPKsNTKbT9iHtkxmp1HrZzLulRQG5Q9JmpT67RYUWmLUmgAffrhT5+ub9QWiHSFUnuPQ6xFwfzW2ASbWI3R7OR1H/zwdv78L++YpyUw+v35bQ5RDYS1nxFrJiLWIEWsBI9ZZjFgLGbFWMGJxyouzjlx8UXa2VHT1PEYszr7NqRPLGLF67FeP/TJZR07Zn86Ixan35zNicfbtUu2PnDa6VMdaznY8gxHrlzAO/RLqyMkXp10txXFbXuN5e6noF6e8LmTEWsKIxemblOqY1tMfV10dS3Xc/iXM0zh14jRGrFLV+3MZsUp1reMCRiyTNlrlpd7Nk0G9W4SfgbyInjmY2ScY7aSeOYWc7LJrDJUdQuU5Dv1MQJWvW4OvJdIKerfcS0Tibnt7NNze2dTc3Jyvbqj81PM36vmCkrWZ75tE26lnnHAvnAwVIK0GpVWCNMWjlP0Vw7L5rzXEfxD5w/Kpvun37RkKSwbVNo1Otq7B/kg9V1TffaD2qqvnmvC5IrWHMYTwqXM/5P/3RmZ4hfdBHmH9dOevlvvEw+sQioflwvK2SGbfh/fJYV5wfcsJPnXvdkFZUHsi8P4h2E/h94+4z6hoCXc0xSJNbW5HvKkl1tySzxkVuu+pB9kfCs9mdZyutge/c63y/weNPWbsP/3OdQ2qQ67z8PF+xvSehdQ7yTLvNyOzZUbpHSXPMpRGnbFFfdMItwN1/mK1pg7pMSNVh9I4W8uNUntV4PgGxwg4TjhOpt4wPx4rc50RiZ+3++3j9LN9UOZ4LxO0qbq9SXjfbG/QRvhMbKjXeFyCdcf7bCjbR+1FrgE8j0/xUePQNmNS6rdbWGih9pCogH1Jyq7DfoL3VuS7nzdE8EDtwVOyyPesAg47Afem/shfsitfq6LfQj8H91vdnjHH6dpvc/Vz5Xc1OF3bEus3NRbk02dk0J2ZBvdGqj7TG5RVlczkZWyDsKqXknU54LkimeFdla/0BX6TW+VTvNaY4dVVvKpveKtxC5YJ61KG8uPrShS34agM37COsB1hvWG7y0B9Pxx+V13xSH1rvncyP6xqhNWrACzFVwORv1c3+aKwqhBWDYEF46APvS7oE9T5JH7v9G8M2hTatqDv9Kv8ewK/bdPUtYmzY3LZamzz0rJ06LFqUuq3W1gIfP6GKp9a9zCxTzLot0/MrmNkvttF+YrUGCW/G9DX6dpmkD/4fSIVdGfc4zlKvu+HwvvxmUSwjXVnGeGxEeqI7tsxSt97O/r5ZQhhUf2Y8pEoWVDvEOD52n6g389A/Z46+4rqv7jf4z4B0/zOvvLTLd0e+zoiPzU3CXIOO4XVS1N2ru9n4rIhX/BeXLZfH6H8WCUbw34s+a4E9D2xH6ubT8oQRJZUOzag/FB2VD/WvUfRG6XB/of7OPUeM+wv1LsYcF6rxui2VFwNIQfOsQP2P278VjfaAu29Af4jNYTcTeAbOgPCVXq3eTKDT73LXI7y4XtkOrXOrfKoepjQI9HOTYbl5Cl8Q++aRIKMjbD8Qt9hh2XVOkZ12NPVTXc+me45RCHnbcAz5ldVm/qds/BjnmQmrQylVYC0KpQGxzZ49uZqIB/ug3g+A9dItkxmMNYGeOukrpX8TNpuUzZDhv4E/3gdAc7lqTm2kjm1FlOO0uB8uiKZXY5a91DPMDCW4gOvk0xM/abWMfD8H5aP5/9ZfBNxWC75rBeMTV33djJrBhGA59dHypyueNQ8H66RGuzPYcUr9Q40dT6Y9AsHpq5nzpo+I77NtC2OinfMnjVl+rTNYh2HxB0UYOeDilnm+A/MsKIURjm4nwpwYbMimX3fpFS8W0Boac0sFqoOUYn4dFD5lSh/a+o394PXREvMS0RiiVhTrLMz2pHz4wgHpK4td4o7iuUUG3rA1GS4o6ed4i2SGXyqgysdVgMlvFY8qTxbgzxb++TZBuTZBuSRgXKuFX94YId8UAP7VigNGrStURq0M4onacCVYZPXQwCPMmybzPAeQmnww3t4QRA6qYz6HjM8SQv3J/ivAHWTYbOkmbIV/uZm8D01YG8M2hEP2CEnux1NOtSwPMehJzalegi5dAj6p647YlOn7jxjypzYrPiWs6d1SJ8AVgHClhFVxMO5ykPtoYK/y9Bv7C7g+WQlget3P45TZVPnyuA1YdykOE43n9OZyJDPf1WOk6McimfK3Ha3HJOmT4Yg50Ca+p4MNYQ4SIa6dqT2T4QILEoHVZ2k6doC4OJ8mB/YDlUAH9aDai9qXk/tL6KGCBVveA3LyDdEgrYHXI/Ipz1051HCvob3Avnt3Sz1qc7mqd+reqoDh3zdt8d1Z+mrfHAModb9lGtETRsch2+4xmdAbZ/6L+u6F+KZWo8oJ2QVxAWA9aXWL3oFKBvKa/MkXXaVQ9shuM8C5t8t9V/Wf9/UNTXulaO0MgKb6pOqjib2THc0Nbd3RJtibtyTP8NF/65iU6ylI9bieW1RLx71mnKVv17q2vKlg+ZiLR2YlI9Jf4t6nkb5XrpnZbI/qmmCvB4A7od4jqP3lQ1Pq5sM+49evs9DylFaJUiD/uBIJB/TzyQN6ZrX3/HXLzWGjwcywboTQnIwxGc4hMpzHHraruJK7Vumcto+KHU9dXqsc8sZ0w/PXsiHtQj51A6mw0BJJ+QTLwM10sKRRsWX+pOrtVK/S/nJ1WqpaxtmDuumfq/qmYPqKZZ7Ok09no4+cHk6avdctQPsjUPPQiYxtq1B2Wt3FqiRWdk2OLpMmz5rSmLeZjPiYlW4c8fZU6dOSUyJz3BQCDpS2GC11GOkVW21rk8xbbfVircXy2rVGcEPtyv8vmb4T1utnZMZfFgXVa7S4V2SGVnuAu6BeXYFefA7oyrPbiDPbj55dgd5dvfJswfIs4dPnr1Anr1AHsjz3iDP3j44+4A8+/jk2Rfk2dcnz34gz34+eQ4AeQ4AeSDPB4I8B/rgHATyHOST52CQ52CfPDGQJ+aTpwPk6QB5ykGeTpCnE+RxQJ44yBP3KSsB8iR88kwGeSb75DkE5DnEJ88UkGcKyAN5PhTkOdQH5zCQ5zCfPFNBnqk+eQ4HeQ73yTMN5JkG8kCe4Zk6031wjgB5jvDJcyTIc6RPnhkgzwyfPDNBHvhtOqg/s0CeWT55ZoM8s33yzAd55iN+KA9N2UezayRNnll774Xxd10cUE9Vdr2ZsgNvV1Dl1zomx9bMukc94gfLB6+xBV1/q0dplSBNtS981kI9q6tDadCXVDbW5Lpjq9scNeyDJFahTro/R53E5ydUJLvWI1+dhLqFdRI+18ffTYfP7mahNPiMcDZKg+8OzkFp0Kefi9LgO7dHoTT4Hts8lAbfe1PjgeSh3clcH5G6Vm1UGs8dWtrNPndocU09d9gLycfMmJqRj5mVnxZX99xB6UOprz7HUr9LefVZPZOH6zhwG6mkSal4t7DgUdtIGfHT21S3MIMfUfhbAnzOcVPhb2UEPyOfrc3gp9sXbjFnwk7LZlszvKfbdjsz+FGFvz3ANyGfHQB+yAD+jmbkk8bfyYx80lvMr04ZP+Wj4LMHqP+O03XskUHZ0QYCS7WDKqeeKEeNoQ2OEZlGg/rhqvxax+S8IOOHNyB+sHygHyTT+hG8NqA0GbDu9yPK6UeUUyysOqdr/QvVOag7cB6SS+egTFeFzqnyi6VzVPvpdK6R4LUBpcmA9aSRKKeRKKdYWLgPKXzqvyoHx/npdr46B2W6KnROlV8snaPaT6dz/QleG1CaDFhP+hPl9CfKKRYW7kMKn/qvysFxfrqdr85Bma4KnVPlF0vnqPbT6dwAgtcGlCYDfFUUp5UTcWVFxsJ9SOFT/1U5OM5Pt/PVOSjTVaFzqvxi6RzVfjqdG0jw2oDSZMC2aSBRzkCinGJh4T6k8Kn/qhwc56fbUIZm1+vd5hqna7sw4jdRzyLUPFKuQd0HypWk1qnhuzz42YBKh/m3L8tg/jEVRz3jwf3VzLfGg/dX/O0QM2uq+m+NQ/ng/lpD8Ep91wL3sRqiHOpszGJhUc9BCu2v1Fn8QXQOnwk5KfXbLSwE1jlVfrF0jmo/nc7VErw2oDQZsJ5Q58NSZ/0XC4t6vlaozmHdgeXodM7QWcGBdQ6fFWxa56j20+lcb4JXfFa8DFhPqHPnqfM9i4VFPbctVOd030TQ6ZzJ85cdJ7fOqfKLpXNU++l0ro7gtQGlyYD1pI4oh9rLUCwsaj9AoTqHdQeWUwbug77kt+AeeB/0JeHzUvw9lfTzUuBL/pCKo95R74vS4H6BBpQG38fuh9KgHjSiNLhHqD9Kg3OCASgNrg1XozTot9SgNDi+1KI06uxy6jxpfJZ1vnatImA5lQWWUxmwnLoCy6kLWE7fAsvpG7Cc+gLLqQ9YTkOB5TQELKe6wHKqA5ZTU2A5NQHLqS2wnJ5+2tNPe/qpnf3UqO8cjqXPmKWeiVJnZav81POsSk1+6llEnSY/tY7cV5N/EJG/XpN/MJG/QZN/CJFf9/2NoUT+Gk3+YUR+an1B+bzDQVoo9V/pyggQz6grgd8vUOXXIl5Z+QHzrBFOV9kNJ2Qn9yCrNpscn7Xj9FnxmZBviHV5WSYepsOg8uDnPyH0uxyl9QO8wvhGn/j+PvEDfOIH+cQP9okf4hM/1Cd+GIpXafiIzl7odx/0G9pSHEKIcDzmiSvdMYjNne4Q+al7VTx1P9Vf1J7Qeh8ceF+FprxygifqLPOQpi4hzX2Q562S2TxTZdYRWNh2mjkLscULofIch7ad6X3jTlf5mrCd1JmR1LhPnZXHKB835HS1IeVEmUX6lkYL9bwLz1uobyjD/FVAhjA/vFb3w7gjUwqBn1FBfOwDywD3E+M0nc9CYW3Tg5UX1g4G+dI974R9QOrbgUh38PnM1H+Fi+N082543LhBO9WSa413bihTLuxz1BqvDOp9DfyNz+NCGcz5qWtq/MPfrsN+PLyG5VK8YPnC+1Va74B1g/fjup0A6lZVlp0f2igKcyDCx+eOyqDGXmyroV5X+eTvhXhW+U9N8Sx/3+DDM5QDHAd6O7QcTgeYN5fRfDqOfg6h65PQTit+gnyrkyobyhm+owPvr3Lo+sM9MzD/2RqZ1oB7qPr09sFcppEp9cxVJ1Pq24i1RL2oZxN9NPfhZ+RU/XTfF8d5oV+aq+2grsNygradyn+xpu2os4AhX9sG4IHSXczD5RoeKF+oN4GJeaa+HymD8mXwGcJXAx5u85FDUB1W+a9bhToM5dLH0ZctA7QF1T5lV/nkh20E89+iadc+4B6qPr19MH+rkSn1jFkn01zfk8XPJanvyepkCvsolqkqx2/8wjJV+e/RyJTa06iTqcr/+1UoUygXP5lWOF1tpwzKXytzutpV2B6Gz2bpUL4kXC9UQaWNBGXXoLRRIA2fGQ9DOfoN6yTleEdZBhfnw/xAvRiJ0mB7Kd4ofwPPW+GZc5TPh8+3gOcSwG/fyVAB0jjXS6SczinPri/U2cpkdp2o8zx0zwt07x1CGTUQ+XdCZVNrFlD/4SeufswD7lc8rgp5Qh6DyFP3/CKXPPE35eEzQj/fAGJBGevkqXhcFfKEPGJ59s1RJyxPnT5DGVHPdrEfQc1VqPlFqfV3yCOWZ58cdQoy3kE54f4OZY19gkL6u+JxVcgTzgmwPHXzWRmC+LnU2meD01XW5QirkP6ueCy1/l6To075yhP3dyhPvO8g6HqCTf09lw3D8gw6n6f2XtShNOrbObq1NFgmXO/Dn7qEPFcBXLWmifeh9k7dIHm/tjy7bJXHb91TrQFgzL4AE88pVJ6ga4PUmKXbQ6LbswHLp/bFDgpQNvTD8Rra4Dx5pfZ/DAZ56hGvkL8hefKK14yG5MkrtfdkiIZXWI+hefKK15aG5skrte9lqIZXWI9hefK6XZF5LSd4xesE48De8m3Ksu+H+q7sFWWz0+eWpf5XgDTGZzFRymZDmWObTclXtycrl3zx8xLY/oNQGvTZcLtAucI5/o/lJjNppSrXfPe6Ue0A7ROWK5T5YJQGx1CdXNV4+nOWKzWG6OQK7ewQlAb9D51c1dpgj1xpuZajNGr/NLS1IXQfLDOo71YOcNU7R3jtdkeN76Z7x10G7Lup/LtofDeVp8yh13fxXvLaHPXHbUTtbQ76rK53gLLhHAb7boPy5DWXPuG1bsjf4Dx5xb7b4Dx5zeVnYl51fmYuXrHvNiRPXnP5mZhXnZ+Zi9cgvpuO11y+BeZV52fqeJXXeF5kmtdqglf8nP4w4GdegfxM2Dfxe4qwT/cNwFMIpGN+8H0yYNum8h9J2LZVt95Lj3mwnfCYB5+9lRP5cZvr9rBDmTWg/NBeUWvrqkyqrdU+9FKTKxxbsFypvkG9UxOkHSi5QpnjOQU86w6/BwTlqvbx2yRXakzVyZVqBzgWYblCmeM5BTzPTSdX9R7Ez1muuXwVLFc4puI1TXhmGZYrHDPUeySrbn2dlqvu+STlf+qeT+ragZIr5VdR53Lp9vJR/gI+Tx3u5cP5IR4ezy8D46PaX6J7dgXHfYpXat6B5zx1PrjqzC6TOsLx7b/rU/Vf1d/+W9Xfhucuv6Opub1DMOHGPfkzXOzyYy3xtmhzJNwRSbTFWt3WXOXDs79VPnz2B/TP1X58laZwT00pn+wD/1eWnUfh3Qf87nuBHwtxZNgimZ0G9+8oXmTcSakya1CawpuU+u0WFKJx6n0oPvzmBPX+Dh9+S5Q6z4+R/ybq7DY+/LBLndPFyH8r9V45I376O2t9zLQv+V1QRvwYtReRET9MnePJKP90/20wg5+Wfz8z8kn3r0Yz/KftQ38j+OFOhT/AjHxaqXNaGeXTpvAHmcFP6/9gM/JJ288hZvCb1TgN17LUeK7KhnNevrlStCOEynOc7GfNDiq/FvHKy0/mXWLduqUMylfBZ1jAe6l1mCBrOtRedwqrkhGrFyNWNSNWDSNWLSNWb0asPoxYnPLirCMnX3WMWJy62pcRi7Nvc8q+vkTr2GO/fh72i7OOnLJvYMTi1Pt+jFicfbtU+yOnjS7VsZazHRsZsX4J49AvoY6cfHHa1VIdt/uXKF+c8hrAiDWQEYvTNynVMa2nP666OpbquP1LmKdx6sQgRqxS1fvBjFilutYxhBHLpI1WeeE7WuqcIBnUuQz4Gf7x6Jm5mTM+o53Ue6whJ7vsakNlh1B5jkM/E4DvkWF+FN+1RFoh+zPavUQk7ra3R8PtnU3Nzc0hhK94xXF43Z96B5h6vkA9O2eUdbtu/6FKqwBp+N29SpCmeJR59kL81xjiP4j8YfnUGZU7gjrk05aNTrauwf5I7YvB3xSC71irfTlwXwz+DhXEw+f/Qjz5/6zyDK/wPsgjrJ/ujJ1yn3h4HULxsFxY3ubJ7PvwmZ6YF1zfcoJPShZlhCzqCN7LEQbspwpP+njp962STjrAPiNDr9TvCoAL8yvsSpT/XLD3agXg9ce8RHky3zWafCGf/z9iEHEVyey4mmTX/OXJrvlV2bXJrjyqtN4gDdoKGfqkfkN5QSzFRyXKf2Uqs2qTanCPur+BKL8alZ/FNxEHdQFjlRNxUOcuSmVIn6kGyuZ+Xv1jmQgfxmHelO6Y2L8Yb4+2tbS3dTS5nW6b1xbJtX+xKZVQg9K45VRD1JMLv9ULt8Px3AD/EWqPJB9+Zo9JuRn+XTVGwvOgcV0c8F/lw/fAPDuCPHgMV3l2Bnl29sHZA+TZwwdnL5BnLx+c/UGe/X1wDgR5DvTB6QB5Onxw4iBP3AfnUJDnUB+cqSDPVB+cI0GeI31wZoI8M31wjgJ5jvLBmQ/yzPfBOQ7kOc4H53iQ53gfnFNAnlN8cBaCPAt9cM4Eec70wTkL5DnLB2cZyLPMB+dckOdcH5wLQJ4LfHAuAnku8sG5HOS53AfnSpDnSh+c60Ce63xwrgd5rvfBuQXkucUH5zaQ5zYfnLtAnrsQTo1D+4iTUr//v72ri5HsuMp1p6dnd+dnd2bHJgmKYgNKgqJgunt+dgaBtJZnd/3veL2yYlvBmZ+ezYTN2tldAxZYauABEAEEAgkRpLyAxZ8UXuAFJESEAoiXSDzwgPgHISJ4QDwAigRMzdbp/vrrr6pv73b19Ky7pNa9fe+5p06dqjp1qs6pOrX7SBu11c28cvZCjfVYLH/e8+3LxwWx/GddzjGt48un4q0gf9CX7wim1aGnoHfTrd5yqLmwldvPG68AHLetKYC7CvevuG4a1JxN6VQ5Y5ts1HY21V6H4dXZek3VAc7zfJqGdzP0DuvgFPDzCsF94Ec6cFMleF1xI+Z1vb6dl9f1kfH6Y8BrjrWRY/0S22mmGD+NZUE/n6Ns83vn9Dza+Gd8wnksz6NxTj7d6s7H5qw4j0ZcRkeV4F8M/9Xahn2/KPLHuSbnpfLnebRaXzgj4D0/nw73fq5ocyzcdzrM/mD4t7LgrzUM/6U8+Ntz3MutDi+HhLvNmyt5aF8x/E/mwb9qeyWXQyNUelgxRH7xmqTlgXnnsd2sT+KzpfkzbvHZ1vmMAG4bhcsXn+2tcFU2tJTNxGRMId6lbCbvRVxKzgyTLmVLVOct+zayF+5TsSULeod4KwkaWX74tCC+KyJX53rllMpH0ZySt4Pmk1c+12qKX2zL4vizSFem+UDpcYNt63nkdGfc6HemOtdbHr+Eeq1M30V6lVxn/6d+ch3PPhxErv90uKqzTmMxVJygwfL2yfP8x8O9ivnEdltVb+qc80XxPfNQ+aHcq/xQNKf63b3mk9Il8rTR2oW8/ha1tbz+KLV1dZaDGx7+urLzW934+voVeI7vYmfR21yUz0r5VcD5pXCfikGtYnBO0ztscxyTUfmBzIlyTIlycHv0Pzw7KbXeaM/7xeDiWKOpuGYqb5w7XGp1w58bkNZFAY/+eQtEK9K3OCCtW63+eadoXRLwiwlasRxLA9J6pdU/7xSt5wX8UoJWLMf5AWnlc3TPD0jrsoA/n6AVy7E8AK0si2N5p2h9SMAvJ2jFcjw0IK2zI6a1Kmjl+ItfCVcv1xaL7u9VLB511vh0pFyxc6pZrhv8n4Srl5cfKDTOKadlYOoceStH3rMJ149i1Xyw6NDBdVZtdZfpYXhXEfBc/+psQtzPYzxSZxPyOKDiCGF7tHFA8dNoPA5+pmL7qf6Uiu33cIIHyKNF18tr9jlX4yTyOMXP0cT20/xEGsvwE+EHlU/GI3U+Jo/9SudBHqf4eZz9PRXfIKUb+VRmHEU+GY/UOa6sn6j+jjxO8dNoHLf+vtinTIPqe9zfkYesQz2I/X2xT5kG5Sf3d+Qnr5Mo+wXqDJeIVuPhjEvPiaoE/41w9bxpFN304RyQ24JaT1R6Fs8dUYfiNZy2rd9pfrOeZPBTRacMH4D69Un5G+RtZ3XZzrDuuJ2l5rNH5XPd8P1inHJd4dhcxv9E9dtUO8M6jbWzBagjbme4RrZAtKt1LdTNU+WYEuUouyYz7mcyvz8geODOZD4kYH3/Qm2tsbfabOz1zT/nXplHAwLfLr6V5EpV5Ofh6gm4InI9wiGeTbe6n437XpnHAoJx3ivzUeo3WPZh25OO8iT8+Ixps4/G4axz2x96ovfK1FYvjGqvTCUP/kZeP+rOXpmtVjd+R/mqPab2jfIDt/HWj/emA/j7c4DPJ/Yv8Cnn/qPDNrGeuc7qyxH6fWr7hrlO6pINxAvEo3y6Ee/Y6yzh/3HrLI+E+4lsS6bM+wBr9VHtA9xqdfCrPpmSbSy/FuEbn3h+hO8ui3xzlvmwTaxlHi/avuhqjGCfaVc+33q/jE1uml5SEXRgP1M2dIR34lnh4rKX86gIfFbuhQRtqX05Cy49boy7fP9Q+H/c8v1bwv1EvifTRHd1E92VUindFc+hQj5XXVy2VQnWbLFe312O4CujC1ci3+H8lXG4IfIrJeuRjpOuuz8a/h+3bL8e7k+2bF9bn+ju6WSyHX2vyuru9g3qi/7+EfjGJzzrg3X3p0W+9g5jalfo3bPwjvdsPwfveO8rninCe19fgHen6B2eM8Lnpb0I7/ictavwjn2FXoJ3c/TuGrybp3d4nkl7L2n4j/apIY6Hmyoe2BDb4d6yoJ/t/3n2iHb2cG7lwV/PvEd0hfeIDhn/auZ9onum72wHfEpXZL0vkzxssv7iXK/NCPMf1XkXFaKH+WP3XlbY/PB6884n3tq5cbD7TPPt24/f3PvE9q07B9s3Ht/bu9W8fRtLoyQsv8fEMAzH8GVLsdW6e0151dvzfieAPEG4lAZruMpatZVnfpW+m4nkgzDqhAF8r/Bzfcz0ofky0azyzLsrt7ZmtJ5O0Ir5qx1Ip0dDa/vU1zMD0qp211boP8MhzIz4Ht+fFnkXo+HJBePJ7IA8wXLPjobWDaN1bkBacaY1NxpaN43W+QFpxR1U8/TdvChHqq2pvOdE3iNqa9vGE7WbIcUTLDdrw5lobZ9QfHZAWnHcPDsaWneN1nMD0qo08Qr9ZziEmRHf4/uzIm8e41I0+2Qa6blEnqnV/tTqFu8+xzF0gf7jmMW7W1Eeqt3Dc/QO++ACvcP2E9vlimOGOgFilt6h/Jund2pH30lYRdsP/ycW8PvHfzj7355YSNJpFBYS82L39+cBn0/KQmLvcNbOK2x8MhO+w1W70Zzw1rG6ZBoLV1MnvLHl28s+i65yOJM+nEO/vH3jYG/7zsEbN682P/9W8/YdPpikQv/5PR+Mb1kjHKeC/scM5fZ/SsBhShlI1HDIQx6KsNRQiWydGNTLDRcTZ9BSaSWzOF/JKeZ8UsNFbEnJJxPveG803euQwn0dcaMRHp2xlJF32O1GqerDwO/TsqAf+x86jM7D/c037hzsv/38WzduHOwfNPeef+NO01Fi0R8Ty1gs/o6TwU18TsuLUPN3OOEidG1UIrTIg7+WuysrEaq6te/S83CPM+rY95l9i1bHwbfIRLrnjc3sD7Xcq9s399743OWD5o09lmDI3VQ6CdLKTlQ4bmnVCPcnXFqNLFJOLjtH5tNgpbRSJ+NZGzavGLy/X4Uvs0f8emYervA6p3O9EjvTCXyrSvZV6BnmP6pTNJVdVZ2iqXbp83rPdKu3HLy7Fuv3aPc9wHHb4vVpXOSwtSVeR/fJ2rvH/1HI69vDfeZJyM5xTkLs2alWhx/tmQI8qwL/jviD8PQOdzNPt7rzudcoAx8J/8c5yoCtvc+5jtbzccDHfcX6D+oR6FVj6693J4NP3Gpu39FTQRX+Ev9PRYgou3qI+F0iL8aJcCdlWlkP/49bUauEFydbUbuwc7JX5hojW5lDo0lqZc7g+BsUJE8CzJMRmKcA5qkITEwpRJhnAOaZCMyzAPNsBOY5gHkuAlMmVOMLAPNCBCYWzhFhXgSYFyMwVwHmagTmJYB5KQJzDWCuRWDKhJd8GWBejsDEQlAizCcB5pMRmFcA5pUIzKsA82oE5jWAeS0CUyYk5qcA5lMRmFjYTIR5HWBej8B8GmA+HYHZBpjtCMwOwOxEYHYBJhbGcw9g9iIwTYBpRmD2AWY/AnMdYK5HYD4DMJ8BmArAHADMAcGMatU/j0xv1NUEpK1Qum4dbMh5NwrKzzk9cbT8RxW2J+V07FNq4ljQu+lWbznUxNHq1yviWwDHbYutyriYYe1XWa+s3Xr8L0Be11w37fhNhfJ3rvcIgRx1sVFb387b7nUowNSkPxX6MlZ3PmFIX+ZdnsWmDu/y9JN6PXX8grWVcZ+kPx/+j/Mk/Uq4fwBCAebe5rWad5vXavvoj7+yOnM55VMnnN4kLNIkLBLinSJ4vLfv8dleuA47LNL3Utlyhyti3azf0TpVgv8hoP2zhFPVI+pB7EB6BnAxPOKrEvzNcPXv/95pnLFyxXDeBlo+H+6V7LAy+GdvO13+wqV5Wrb8UxFaf8B1yv9PEVqRHqQ15UXpr+8k4KoCriBaK07r+jZepeTxvbZzLDPLLuynwzbWoXxQ5eb8/W8OylBxvTKI4VWbQvxzBN9ea3dalvKRzgb/M+HqefkTERqc623XPm21NA0zbrA++IVwxX6t6hjbtdGtNkqmNqD6dDFca/eX6nnbWqONn0PsDIn+thvVXB78G8qrG2XJL1K+5kpVVoYb/BcB5y+Fe7XJm/UJ5W0+5/Rx7/crq3BzFesNZ+Eb1c9Mhlp9YTiCYerMRo/N6VCWLAp6qgT/LpXrPPCnQmVFPAa/JPJF2xmPi0uUr28f/xLu1SYzbHu/TrSeA9wV+jZV5t8HnL8V7tXmUQ6hgBsUF4iW9hqJ0+0hFkLhd1yHD193HT74NPpQMndDKPw70MF9qtrqLrfakInwbNvuF5aP+6AKM8OyB3GpsS4V7kDJFcOr5F0q1Au3H2zvMxF4w8f94w/DVenNS/AN93WUi4zzj4GWr7ju8mMdzALc1yJ5Y/krojwsT2J68xLRavB/6uLlXxTlx5AuZwinwf854Px6hE4slxob7Hm/0IJGjwqDaN8q3hsc8l7hYPlj+c063SbmiFYVHqdw3WVXfXtJ0Jqq6yWRD9f1X4ar0iUXInTG6EOZsNW6e1XjSnsN1HXGlXH3ffm78P+BCz0yYIiEYeff2NhY32zsHFoe93b391ZXRp3/+up6fWNje2N3fXd/c3V3Z9T5766t7+weVkKteXQadOM4Q7/8h8Ee/v4z3LP9CfPzcBaGSsEVkesRDvFsutX9TNkuxin0y/+F/+Mc+uW/DV+4YtmHvWZ+lCfhx2dMm7Ud364Nwcn26VvfO9k+ffXGqHz60B8u5dMX86GrAEzMhw5hYj50CBPzoUOYmA8dwsR86BAm5kOHMDEfOoSJ+dAhTMyHDmFiPnQIE/OhQ5iYDx3CxHzoECbmQ4cwMR86hIn50CFMzIfOvx/VBoecfifYxxyUJa+/VXm77nvN36oBcNy2Uv5W1n6Vv5W1W4//eyCvy66bdsSXmmvn9Rla28s8jkl/K67X6VZ33vgO624a+Nkg/uTQU5A/Ofjv+ZPalszzCOe0/m08Oi6fqu8O/8fZp2ot3Md8qvzvYnheu7+0mtenquOzdSkL/s7R33l8qjq6/5U8+NtHfz+ZB3+7fp/Kg79p+J/Ogb/eCWc1A2sGMd2kjO7gE9ss+DBpzKc6xHxQX7N36uDLgu6V7jGTyEfpSZk3d7d9Nk4Dncq+zD5lOHdXPhWnIrwoIvjPjKa8Pf51aE9VBwMoPwbnhiunPM5MfgwbVSrvT4WrL+urlCfaLriOfOI9dPNURwzDfWMB8lb9wb5l2+3r4Xp0pEzRjVP57OFB1FuE0+B3AOe5QtPpXFpvtuep8PZIj5IZZ+m7lI1T4eawIwoP27C4nFPwbFbgVr4VQ2yj0reiEHkaPexn8CbRhb4VhUvzzP+WRL64Nj9L+S5RvkcHg1IbMtrmnJYvXCczlAe3K/ZrMPjvD1f//064V4cPnwK4dyJ5o03znKD1jNP8uxj+1+4rNXraAfJC1R+3A/PD9eV+uIjzIubb6ZOa/4/CF+T9RC/KxSrRpOST0isGlU+Lrrd+T9M75SNbCBrUGM/yDH0WFTz3CYP/yXD1/x8ruulTB8z6q417SgazzxmuS6fGqX4+fD8bwRvzXTJdv0rw/wU4fz7cZ1673+A6RT2P80R65vLQk9Tb5gQ93Ga+6Lrrot3fnZbPFYKfF/kqv8WY/yWOERWRB7YvtcfEDZGXZfb/ZKrHzYLyM37gM8x/VPt/VPCS1P6f+Tz0bHjdYtF1tw+fcJ6ugpFge1FyCcf/d+E59xklly61Ou8R/suA8zfC/TmR9zS9476laClcbz9xLj1nxnVdfod+FZxXzLfY5LwKjsRrD7wfwCdcu+Ex2eqw6rQ8YHli8L8brmreovw0U3qB0iPUnE4FwWH9VeWN9YbrfPh9zF8R/d0R/g9cp/yPFRpnNVKeagQn+oAyT5XulOJpv4ArRo8KTMN+d/14av2SaS3LU4P/quuU/7FI+cvy1OD/DHAyTxWPUjzt58vMPFV+v2V5iuvFmE9Znhr816D8zFMlb1M8Nfi/AJyj5imWeZG+iwXAwvk3jufqu9kEzoUITiW/YmNjrC6VTOO6/OtwVXWpyrVQslxnh1SuswOWy+D/MVO5KpFyVQYs10KfcrGub/D/WqJc2Pdw7N5qdeM0+H8DnNb31JoBrhv7NN3qpvdieF67r6TXDFCHrba6y50KOufToLoBrwtwH8V3qb2Zqk2gDmZ6g9Jp7VvUaVXQTdbVUvu8fdpqdd4j/DfCtV8bsLzHbd1I7VlNjRFqToRzUtbFsW7Z/lMVuFQ9p9aZyq63jPv+grmA4EHbX3Dc/v2D+tc/cPsLNtf3N1dWduorm3vNzfr6ce4v+GBA4Pvlh0hWVkV+Hu47EnBF5HqEQzybbnU/G/f9BR8LCMZ5f8G3kdzCsg97Te4oT8KPz5g2azvjsG/qN8P9yd7fsDay/Q1FHvwjC4VzqdXBj2WxfDFw5JFt0nXDox5UITzOjcpP927oI9a9hqivbuTy071F/Mnjp9vhTw7+e/6k/HSVP2kOWbKVAz/4A76TqKtieOWpKb/5gvLO1M5L27gs/1mXs111bFzTRA/zh+VMpn0qG6k5oZq389yW6w7nmzinVzb+Kdc7P8Xz5ar07MPhmjpXq6B3zqXn1/7ZI1S2XH6xbBOrDCEfbh8+XQzX2n2lRo1tn5hPGbt1Hr/RxuTcyjR/TtS5ld8VrurcSu7Tg5xbuUplQ73ufvu08ovKu6evoz9nOgt2g9ukc8PVZ7huh9neld/2MOlXPgzoz7YFz/Ed9hUll3hN+ynAaWdCq/Ph8Aw45UPH48pcJD+U52xjeQ5oeS3clw+TyScZxlJmD549dZqXJXt3tiTdvKqMdPte82OAl+E4T1ydt/xVTbKFZtBdLPj9DL2bEvmoER89Q19L0MqeRZj3FL1TFkpl2WQ444PyhMDv+DQsg98JV1+mnwP4wmmrfcoq189qv0BlVp4QahaOI4pP0/BumDMjz4NfADq4vNVWd3lTlnDFn9QpeQbjXKfNIe/Yq121e+xXNhNPWTlj/1OW1Ir4bpDRwCdbhXdOr3Ybn49rN+8Ph//jvJv3rXB/EqL1/Wj4f9wWRbXCw9rtxXukhVNKy867wlN+NsgrPLksAQXlZ/Qwf0azwtOooRcz8mir1csbRYdPSgtleV+I8qq2uRj53qd+3sIP8ilwdiK0l3e/7Dr8OIJt9eaHnt7vRSvtu+H/OFtpv2T4whXLftxWWms7D46VdH11YiVNp4mVdJBU359YSdP8mVhJHwQraaN2rzr0e8RKul8QfqRnYiUdXNecWEknVlKjJ9bmJlbSiZV00JTZSro/sZLG6Z9YSe+miZXUUTknVtIO3MRKepKspI3axEra28YmVtKJldTom1hJy6eJlbSdJlZSN7GSOjexkuK7iZX0bsKyj5OVdCUgONlW0tWR7SXNZB1o5B0rO1ZSPo/fUb4sh/EbNdZbHC2vc5ju7u+/CfD5hLG0WD/IZCnczVxn9XGyFLrh4c4dm2Mlc2yOVRWbIwd/MsXmqKnYHEOkv25zhGbA5+fBZgk7XN176uZe8webe9e2r18/uHn9pebureadx2+/1Dx8fIvVfDaYoYGPk7GJcRT0fyqBwzm9sIpGsAXxjEVOpsX61TIqF+Y/63JOAdJhypA/U8S7U4JWFX49ZgDGfE6JfBSuqSHi4vrG+rgYrrXB0go/yGvMq22ycQ6TvZsVZS4EvFrCNrr99fsAL8NxnlhPs/ROLb8px4F5eod1x8unakpYuOFNPVOGlnvNJxU6iOWdulo+rk8+ije5DZ+sKuZymuBj2WaGmA+2RTaGY1+xId7DPwHf4HfqiGWfTH1iZ5arroPzcrjPuxRUu8D9DJO9O03lw3fKOK9kELcNZYYqK58wzOUXAC/DcTmUCUstL7Wn8K63jq6Fq6d5B75BnEY30upTGeeF04IOdQw4h60at7FG1TO3DzSzcPtAsxD3dzQFIU849Rvbfg3wMpwlVc9K/8C8bGqn2h0eh29yY9zNF58N/8fBfGFTkzLmhUzT+9K6fHvp0PWOlTl0+QrRw/zh/qccEXm89Wmr1YHjdxXxbGrEuNRR4SxrFW8qiXzU0s3xOS3X1sq2uXF1Wua5N37LIZR82mp14Phdamw9Kbjse59SJi41t0q1Rw4RhfVjy14sSwc5ulqZBRE3O5Rx2Khc4TV57MC8MuvQ62oeYknNY7ne1dHWSr/melf6dSFo6KdD/y3gZThLqo0U9E453yvdlceaQtCVcqxVrjin6B22e1wuRZzOaZc5099S6wyxPqScLgcJ4zMtyuQT9y+D/+1wzetQq/vXGSrDKSiD4uulVncZDP6r4ephv+y6eTZDeeA7tUZ4zvX2Ka4HpJvrQTm1n06UweB/L1w97PsCocfnyldb9XR8M9CBtB7R3+outzpyH+FZn0qFdUCeLRK8kiFqDEWeP0G0omudmjezA7PB/1G4elibFCkZNEu0Y9lZzlREvmrN6gzQ/DfhPrPNYWRrOzwuYTsYdFwyXgw6Lg1DTkxTfuPSb3Hthfst9tGKgOd+26+fm/6o3MW5fauxYJA+41PKTRfdzK3PxNYBqqIM/rt/AHxYjyjf8VuW7wb/P0DLP4f7HDpRv3bJ9Wv5qQ0vxzH/tPxnncupj9RT7T+1wS5TeNHV1Lio+qN3wTzreutMhaVCXdZcI1T7Yn1s0K0h+D3r2ljHKR2d5UAZHR3be78NTAXhUv1YjQf97Nwc5tzw/2+4+u8ttLfqv9zv1ZxO6Z/c72NzuljbQj2JZb3anqH0sDJhNhWuU4m8+4X+5rxVeDqmxbl4H1FjtvEm85i9psbsYYZEU7xU9ajCqC/QO+zH3B8x39T2L+7j2E6t/WJ/UWt/qMPbGP0gu3JbKCJf3keBL0ewIj8P950JuCJyPcIhnk23up+Nuyv3x0HW+jSOrtwfDh+Noyu3tZ1xCEv0vnB/wl3J1yeu5Olk48lWqxu/c3oeg+3FvlF23Uvh3WkHWyJdZ5xjX74c9c7j4zD5tizo53XmpfDfj/sfCfcHN3dvNT/XvHnn8Tff7HLKPXLUNc9cR4kt5gX97+dlexI2XNomg+P2WEAvHZ/waLkcku+hPPhragXxYbh/iMqJbefikGgwfNYOqq43sfZlsDwTKIZPX91RUlqYpeVwfQiePRyhNdOKTsPwZ1oRkW0GV2vm6J3V3bT4roj8V7IqBlsk8C6Id4bT6grptXKYVMbDJQzvMHmJ1oMM+NvyI5N1fkW1BT7WzTndZ3hUZ5k6ZFq32zM9oKFCeTKNCKPaL4+l0/S8UgJWtV/0oGH6+Dv2NuVn6GXJievFZFQ1ggtX5xD+FMHmqsNlQZPR/v8f10Y72ewdAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "cancel_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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kJRYdloqOm2Zi8Z2/LQuf9qLL05K/inI5ctpUnbaUnZaKDvtWO7boelxmnsW4O8FcsUaF0kVLnK8iuLPLvL2ud7tEvP5l3DnX8L/9BL306TstKXstFB09wllt8hQdosMZbfIF88Ls6fNZae5stN82WlSdtpSdtqL9/+X/ca6rs8/+Twqzdw67W/rrM799RIvHv+oXmI+/xLu/Ev48y8h519iOf8S4fxLrOdfIp5/ifO/3en8b3c6/9udzv92p/O/3en8b3c6/9udzv92p/O/3en8b3f68bf712nzNJWdNped5spO82WnSdlpS9lpoey0tey0WHZaWZbMZVkyl2XJXJYlc1mWzGVZMpdlyVyWJXNZlsxlWTKXZYkryxJXliWuLEtcWZa4sixxZVniyrLElWWJK8sSV5YlvixLfFmW+LIs8WVZ4suyxJdliS/LEl+WJb4sS3xZlkhZlkhZlkhZlkhZlkhZlkhZlkhZlkhZlkhZlkhZlixlWbKUZclSliVLWZYsZVmylGXJUpYlS1mWLGVZspRlSSjLklCWJaEsS0JZloSyLAllWRLKsiSUZUkoy5JQliVrWZasZVmylmXJWpYla1mWrGVZspZlyVqWJWtZlqxlWRLLsiSWZUksy5JYliWxLEtiWZbEsiyJZVkSy7IklmVJKsuSVJYlqSxLUlmWpLIsSWVZksqyJJVlSSrLkrLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9urLeqyvrvbqy3qsr6726st6rK+u9uhe917S/vHdroM0Hp73IknXdT0vu02lHK84q7WdxC2dpK5zQVjhrW+HEtsJJTYXzqhd/VThzW+G4tsLxbYXT1l05tXVXTm3dlVNbd+XU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XaA1h2XUKjeDZdQqN4Nl1Co3g4Uq9whL9YXlf7bM15q2o29/PqLflvlaqi8A/8NVyuatQ3P7Mx2EL22H7/wevncH4S+2ww+2w19thx9th59Mh199YW7V5R2X6gtoK4ff9qybDb/xWTcXfuOzbi78xmfdXPiNz7q58BufdTPhHy9CO0/7W6zzFNMXl3C8Tmz2rEOlb08it6J4nlf39ay16KxYdFYqOet4+ch5jmE765NQ21mHN81Z3LydJe7gWlJ01lJ0Vig6ay06KxadlUrOOl706CbyrvKyzl/PmovOckVn+aKzpOispeisUHTWcW4saStO5zD7r2fForNSyVlpKjprLjrLFZ3li86SorOOVfZ+P8svX79faS06KxadlQrOCsc/s82eNRed5YrO8kVnSdFZS9FZoeisteisF7kR4n5WnL+elUrOmqeis+ais1zRWb7oLCk6q6RyCHMoOmstOqukcgjHjeJbzmxd9yBfzzkcVQpb6qY1fD1nLTgnFpyTfn7Occ8nU8WH41ZL9ixXdJYvOkuKzlqKzgpFZ61FZ8Wis1LJWaEoN0JRboSi3AhFuVHkd8Oxc31/tzj2rclt7j3JwTkF3/zjNfrfX+d4+frMOb7gHCk4ZylgUHBnXgvuzMcuNcUtDz49qt3OST8/59ihZs6ZM+M5Osf9nMGxN82cIwXnFORBLMiDWJAHseB7Ggtm6GM3mjlnLjjnh3lw+8f868D5Red8jnvzMzyajnOIt1Nv//x//unf//FP//Vf/vl/3U769V//97/+t//4x7/968c//+P//Z/bf/mv//6Pf/mXf/yP//I///3f/ts///f//e///F/+5d/+26//9rfp43/+8+rC+vf11mT9v37H9J/XcCv81uDT7d/+939f/O2/B//rv/86QWJc/i4xTb/+j99n+En+fvuf8BjWr+Pm8Hc338K9hfz/Aw==",
      "brillig_names": [
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "transfer_to_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4718290446670665014": {
            "error_kind": "string",
            "string": "NFT not found when transferring to public"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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nzk+9HzmAvPTmeNDz2eODz2fOT70fOb40POZ40NPZx7xoeczx4eezxwfej5zfOj5zAXmpzPHh57PHB96PnN86PnM8aHnM8eHns484UPPZ44PPZ85PvR85vjQ85kLzE9njg89nzk+9Hzm+NDzmeNDz2eODz2ZuZsmfOj5zPGh5zPHh57PHB96PnOB+enM8aHnM8eHns8cH3o+c3zo+czxoaczN/jQ85njQ89njg89nzk+9HzmAvPTmeNDz2eODz2fOT70fOb40POZ40NPZ27xoeczx4eezxwfej5zfOj5zAXmpzPHh57PHB96PnN86PnM8aHnM8eHns7c4UPPZ44PPZ85PvR85vjQ85kLzE9njg89nzk+9Hzm+NDzmeNDz2eODz2dueBDz2eODz2fOT70fOb40POZC8xPZ44PPZ85PvR85vjQ85njQ89njg89nfmMDz2fOT70fOb40POZ40PPZy4wP505PvR85vjQ85njQ89njg89nzk+9HTmHh96PnN86PnM8aHnM8eHns9cYH46c3zo+czxoeczx4eezxwfej5zfOjpzAM+9Hzm+NDzmeNDz2eODz2fucD8dOb40POZ40PPZ44PPZ85PvR85vjQ05lHfOj5zPGh5zPHh57PHB96PnOB+enM8aHnM8eHns8cH3o+c3zo+czxoaczT/jQ85njQ89njg89nzk+9HzmAvPTmeNDz2eODz2fOT70fOb40POZ40PPZm4mfOj5zPGh5zPHh57PHB96PnOB+enM8aHnM8eHns8cH3o+c3zo+czxoaczN/jQ85njQ89njg89nzk+9HzmAvPTmeNDz2eODz2fOT70fOb40POZ40NPZ27xoeczx4eezxwfej5zfOj5zAXmpzPHh57PHB96PnN86PnM8aHnM8eHns7c4UPPZ44PPZ85PvR85vjQ85kLzE9njg89nzk+9Hzm+NDzmeNDz2eODz2dueBDz2eODz2fOT70fOb40POZC8xPZ44PPZ85PvR85vjQ85njQ89njg89nfmMDz2fOT70fOb40POZ40PPZy4wP505PvR85vjQ85njQ89njg89nzk+9HTmHh96PnN86PnM8aHnM8eHns9cYH46c3zo+czxoeczx4eezxwfej5zfOjpzAM+9Hzm+NDzmeNDz2eODz2fucD8dOb40POZ40PPZ44PPZ85PvR85sP60JAezMN7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OIDWZ+LW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYktb32JLW99iS1vfYmlvfY2tufY+tufU9tubW99iap8Zn4rn1Pbbm1vfYmlvfY2tufY+tufU9tubW99iaW99ja259j6259T225ur32Hp8tA/JfBvAVuul2z76R9uUvgZb+6ytOtjaZ3jVwdaeDagOtvbMQXWwtWcZmoOtfa+xOc3xq3WIJhUG6+K0dMTFp8lnTlvdFrt0xEh4YjPZrY82cVo+2qRHaxu3uu0mZ9bWc1hbOysbraPxS0+inR6DtClutJYwua/WEox9fHaYvjStPElD0x2aVp63oukOTStP5dF0h6aCpt1pWrmJQ9MdmlbuVdF0h6aVW3I03aFp5ZUHNN2haeUFFjT9vaa175SLpjs0pY7Un6bUkfrTlDpSf5oKmnanKXWkH2oqJi0fLdEWNJ0ns3RknuShqfl64aT27dN7xU415hLsFEwuwU5N4wrstR8L0Ct2KgOXYMe8X4Idf30JdgH7FdhxqZdgx6Vegr0ql3rvUlUO7t6lqtzNZ5fqOobk3qWqsuJ7l6rKGO9dqiqbundJ6utSVbPwvUtVzVD3LtV3967rWIx7l+q7e9d1dMW9S/Xdves6XuLepfru3nUdAXHvUn1377qOabh3qb67d11HKdy7VN/du67jDu5dqu/uXdeRBPcu1Xf3ruvYgHuX6rt717W1/71L9d2969p+/96l+u7edW2Rf+9SfXfvuraxv3epvrt3XVvN37tU3927ru3g712q7+5d15bt9y7Vd/eu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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "owner_of",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "5V3bbuM4DP2XPOdBlESRml9ZLAa9pIMARVv0ssCi6L+vncaKG+tSczMey34p6oKnPEcXkrJl+X1zu7t++/Vz/3D3+LL58df75v7x5up1//jQXL1/bDfXz/v7+/2vn/0/b1T7A7Q5AF6erh7a65fXq+fXzQ8wGtV2s3u4bX83jM0/udvf75orsB/bob3SujNXVvesIWJtnYOjtXWkgjX5iDGjwqMxo4a+8d/bhj9fhr/3nTmAn5C/uVD7I4f251L7AxJ11s6YPH+PvhPrnbHn/C1cmj/or/wPXvwUXtBGveim2zqYRmsKXqgZTEdzauwLratdN3G8ZjxvXfTfYfRVd4tzVogT+iOS4VjHcWQw4AhdwKGKdqszp8nb6x4yn05oAid+CiXe/X4nWqkpnNgpnPgJnMAUSoAncKIvMoSBQ4zV/RnfOBlaI/ougDvWthcfKBZZQ9ol4pNtk+9a+kbVTZ+rpm9d1fQRvkGfoETfBmvo1YWtkwghZNsxcqpQJ5Dhbu6S7ZUuUeNmcpMLRKzyZ2WFRvoDaumkVhdqZqSuKEI+kTf4Gaecrpp91W1P32p702ffwljJYBiHsTqFCTb6/6U9r6ZwMokS//udGGWmcEITOAE9hZMplGiYwslFhvCfyvDGmKrpW6ibvq+afurO0Bf6lpZRHlobnyrYgbQ6eTAGY3x8kEren2KJ9hyxNtR1lO3dYNSxNtQaun+sde/WZdQYbXebEy33TQ8iaQUiUa9B5Bp60q2hJ90aepJgDSLX0JO8hjnJvAKRfg0VT+L2QH0iGcIdKn0mEtVSejIrcilzMicSFhJdXbB1X01bkWYhwzUvciHFQFakXcNwXcqiOStyKYvmvMg19KRbyFIrL3INPUlrmJO0kLIuK5LXUPHwQpZaWZHerkFklXOyYe5UlSHzwLzKjNYyhyoLjgNzrJW5VtUyrzKAHphXGxXrvOFyYF5tVLTVRsXEruYKmGO1URGrjYpYZdXfMnfVZn9XbZtTteOcZxxbDHQb4bTRbsB8xuO8wHzG4zzPfM7P1gvMZ1xxZZmTmnHFVWBe6wwlVesMJZhxJiowr7bNda1Rkea89s8zNzO+I1pgPuN1aJ65rbVWJFttVLTVztA5b70oMK+2VpzzmwUF5jOOik3g61gQyo1bmTTjEDpGJrjwRhuQ0gOZM45aF5TJCxm0BZl+xivQS8qc8XJ1lEzy4Ug4hvNIy2opIagg065D5lIibV7mnF8guKTMpSSUvMw5b/O4pMx1JBSzjt4060goZikJxZtwBI63A5lz3g1yQZmJU0ZV8ACqdzLYJ8gnKsQCKD49AEPJDXRecvtEWs+DEtmjAEIJKP5IAjgcuaLVoCESu3Xs6fjc/qkuHchKQCwAJW4RFUBOACKJJpbQS5wKjDZ0LvZO4TuCUs+ycyBQqdVTAYUSVGoHcgHlJCgt8pWqcHyISQ7MAJXat1lAsQSVivN5VOII0RJK1BqpnWZ5lBO1YeLVK3PKIQb1EEUSFIMIhSKUl6ASEaCEkrQGKC1CiXwBiFAoQklaPvmlCheOYDMMQ5SXoBLPWwuo1LcQCiiSoBJPygoop0QoQVJuUCxBkRahJL4Sh9CT60pWcnaAiWcvH47O9OSGGD8eE893BQyNxyTGbLZuh9Rp3wUUKhEKJSgn8uVEvkjki0S+WOSLRf3lRb68SFficKI8KnUYcQlFEhSACOVGxxgTX6w2y9FuHtsIZnxcMvFZnPeDAm7xhWoBw+Mx8WVqvg3c+JhpSOCH4m3N3Tj4cjfoiIlXwwWMwE98nvf0xDDjx5uN70ouYHg8BowAMz5H2/j7mwWMwI+gFrCCWsBaQf/YkePgo7n65+p5f3V9vzt+ne7u7eGm97G613+fdmffrXt6frzZ3b4979ov2J0+XtcOW820NYpbLu2lwy2pQ0nYXIBz26YMbXw2fv8D",
      "brillig_names": [
        "owner_of"
      ]
    },
    {
      "name": "public_get_symbol",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString",
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACSHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAAC7HgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAAzS8MAAIAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAuioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF0E3qz6yL/WM8AQECJg==",
      "debug_symbols": "vZXbisIwEIbfJde9yMxkcvBVlkWqRimUVmpdWMR330Satrphu4h4Uzrlm/6TOWQuYuc358O6avbtSaw+LqJut2VftU2wLtdCbLqqrqvDev5ZyPgwfONPx7KJ5qkvu16sgJBlIXyzi+9kOfxjX9U+WKCuxW9eIiZcKpzRkKGV1jDQShs50sZlYMuSB9gywhz+LISVrwnfuYQDuDeG/6Lssx2zb5eyD2xMojXR3+E7dumsTpN6CN/Rq8MHvA8/itg3iIDU71AByKpg6IzkhqxoQcWEfh1wE/iFCqJOo+nQ8kMFAfR/Iro/d/RDeNLvST1ST/q5nJ/C0U2hmkaYZSaDpDGNMGlrJwmbHS80412CbrpLMDuMhq1KpdRyoZSGLCVYzborCwOQ0WMvKunuKn8N1lfZVeWm9sOO2J+b7Wxl9N9H/7A9jl279btz5+MemVYIxDsYTUF4a6hgEBXEQSPo/AA=",
      "brillig_names": [
        "public_get_symbol"
      ]
    },
    {
      "name": "private_get_symbol",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18192277837884173995": {
            "error_kind": "string",
            "string": "Function private_get_symbol can only be called statically"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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SCFEyIQUQoJMS73IfGGZkEKIkAkphAiZkEKIkIkgkwSZkEKIkAkphAiZkEKIkAkphAiZkEJIkCkghRAhE1IIETIhhRAhE1IIETIRZJIgE1IIETIhhRAhE1IIETIhhRAhE1IICTJFpBAiZEIKIUImpBAiZEIKIUImgkwSZEIKIUImpBAiZEIKIUImpBAiZEIKIUGmhBRChExIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTIlJFCiJAJKYQImZBCiJAJKYQImQgySZAJKYQImZBCiJAJKYQImZBCiJAJKYQAmWhDCiFCJqQQImRCCiFCJqQQImQiyCRBJqQQImRCCiFCJqQQImRCCiFCJqQQEmQySCFEyIQUQoRMSCFEyIQUQoRMBJkkyIQUQoRMSCFEyIQUQoRMSCFEyIQUQoJMFimECJmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQkiQySGFECETUggRMiGFECETUggRMhFkkiATUggRMiGFuEgmS/5AmGoyUT5k8tuWn2VCCiFCJqQQImRCCiFBJkIKIUImpBAiZEIKIUImpBAiZCLIJEEmpBAiZEIKIUImpBAiZEIKIUImpBASZPJIIUTIhBRChExIIUTIhBRChEwEmSTIhBRChExIIUTIhBRChExIIUTIhBRCgkwBKYQImZBCiJAJKYQImZBCiJCJIJMEmZBCiJAJKYQImZBCiJAJKYQImZBCSJApIoUQIRNSCBEyIYUQIRNSCBEyEWSSIBNSCBEyIYUQIRNSCBEyIYUQIRNSCAkyJaQQImRCCiFCJqQQImRCCiFCJoJMEmRCCiFCJqQQImRCCiFCJqQQImRCCiFBpowUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEEyHT73yCTBJmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQkiQySCFECETUggRMiGFECETUggRMhFkkiATUggRMiGFECETUggRMiGFECETUggJMlmkECJkQgohQiakECJkQgohQiaCTBJkQgohQiakECJkQgohQiakECJkQgohQSaHFEKETEghRMiEFEKETEghRMhEkEmCTEghRMiEFEKETEghRMiEFEKETEghJMhESCFEyIQU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rv/rTtf/dafr/7ozx9/F25/P5cxRUW+fNMovnhrx5ngGyzv69hX302LbaanttNxwmt9ePN1AxxNjt9N8BZ+5JaEH7fz77t5jx377EtPjS2yPL3E9voR6fInv8SWhx5fEDl9itouvZLev4OhT3v2W7vYV9vqvcNd/BV3/Ff76rwjXf0W8/is4+pR3PxS7fUW+/Cvsdv1XmIv7lNtX2Ou/wl3/FXT9V/jrvyJc/xXx+q9I139FvvwrXty93eJx2q9/578u+S9uyW4xHy31lkx4Os23nRbaTottp5WF3ZJz52kPu67vp+Wm017czKqeZtpOe6FbPvef33IwT6e9IHmLqPbTzLY9kaTUdlpuOs2bprmV79bVT3vxh5OzexikfzqN2k7zbaeFttPKct8Ozedp9lGAvzXIlXp8Se7wJeVdFD/7krf39W5fYa7/Cnv9V7hPv+J+GrWd5ttOC01Xn9B2iQxtl8jQdol8cb+wepppO822nebaTqO203zbaS+e//fHhTXGx598llozG7fjaZ1o7V+/4sXtH9avMNd/hb3+K9z1X0HXf4W//ivC9V8Rr/+KdP1XXP/Xna//687X/3Xn6/+68/V/3fn6v+58/V93vv6vO1//152v/+vOH/91/zrNbFvbaabtNNt2mms7jdpO822nhbbTYttpqe20tioxbVVi2qrEtFWJaasS01Ylpq1KTFuVmLYqMW1VYtqqxLZViW2rEttWJbatSmxbldi2KrFtVWLbqsS2VYltqxLXViWurUpcW5W4tipxbVXi2qrEtVWJa6sS11Ylrq1KqK1KqK1KqK1KqK1KqK1KqK1KqK1KqK1KqK1KqK1KfFuV+LYq8W1V4tuqxLdViW+rEt9WJb6tSnxblfi2KgltVRLaqiS0VUloq5LQViWhrUpCW5WEtioJbVUS2qoktlVJbKuS2FYlsa1KYluVxLYqiW1VEtuqJLZVSWyrktRWJamtSlJblaS2KkltVZLaqiS1VUlqq5LUViWprUpyW5XktirJbVWS26okt1VJbquS3FYlua1KcluVtGWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_get_name",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString",
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQADLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF+0Le07wSjQI8AQECJg==",
      "debug_symbols": "7VXbioNADP2XefZhkswt/ZVlKba1RRAt1i4spf++M8VR6w7rUkqf+iJGTjxnkpzJReyKzfmwLut9cxKrj4uomm3elU3to8s1E5u2rKrysJ5+FjI8rL7hT8e8DuGpy9tOrIBQy0wU9S68k9P+H/uyKnwE6pr9xkvECJcKJ2hIoJUx0KOVsXJAW06AnZa6BzuNMAV/ZsLJ58hnjnAAfqH8J1Vfu6H6bqn6oK2NaEP0t3zWHM/KhtRMPtOz5QPeyw8k7gUkIM0rWACSLOgnI6ahVrTAYv289nDr8QsdRBOtyej0rIMA5j+K7s8d8hAezHuQj9SDeZzKI3YULSzlaGEtExUkg9HCZJwbKVzSXmiHuwR5vEswaUarnYqtNHKhlZYG1VZNpisJBiBrhllUkuedV+pdmURlrj76ytsy31RFvz3353o7Wabd97GY7dVj22yL3bktwoYdlyuE7YSckbpZzQekM7Kew/P8AA==",
      "brillig_names": [
        "public_get_name"
      ]
    },
    {
      "name": "_store_nft_set_partial_note",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11988194033336150524": {
            "error_kind": "string",
            "string": "Function _store_nft_set_partial_note can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAACXHgIAAgAeAgADADM4AAIAAwAEJwICAQEkAgAEAAAAbyUAAADAHgIAAgEeAgADAAo4AgMEJAIABAAAAIslAAAA0icCAgABMAwAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAAC/KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQWmXp71B3Vp/DwBAQIm",
      "debug_symbols": "1VXRjoIwEPyXPvPQ7W7brb9yuRjUakgIGMRLLsZ/v2IsVzlOL4Yj8YWwZJaZDjvsSWz86rhbFtW2PojF20mU9Tpvi7oK1emciVVTlGWxW6aPhewuVl/wh31edeWhzZtWLACVlpnw1aa7R9bhHdui9KECOmc/8VKpCJekEjSMoMkYuKLJWNmjrRsBs5b6CmatIAW/Z4LlNPKdi3AAN6P8idzX3LvPj9wHbW1EG8T78p128azOIA3kO5xaPqhb+R0Jz0AC0szBAjDKAs71bUqCecBCjBQHkJO0/TKAVvUDyHbwBQHGz62SQKvbRNP/RgLUXzwiulF06TPP9SE92efG+hgA4+EgCYyWY05INBEcJue+bZYx/qQsuwceB5Gs+0nUygxdJnpZ9edQfeRNka9Kf91v22O1TtZd+7n3g823b+q13xwb3+3A7/UH3f5QnCFewhCKEC00gSPwfAE=",
      "brillig_names": [
        "_store_nft_set_partial_note"
      ]
    },
    {
      "name": "mint",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14466155340988305413": {
            "error_kind": "string",
            "string": "caller is not a minter"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "mint"
      ]
    },
    {
      "name": "prepare_private_balance_increase",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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+Xso+lL0o+ig6KToTzGAYiDFIIopKKakmIpiaoppKKalmI5ieooZKGakmIliZopZKGalmI1iMMUQitkp5qheDK0eIm2etnZPWx9PW19PWz9PW4enrdPT1t/TNsDTNtDTNsjTNoWnbUpP21Setqk9bdN42qb1tE3naZve0zaDp21GT9tMnraZPW2zeNpm9bTN5mkb7Gkb4mmb3dM2xyQshjnpa+eimJtiHop5KeajmJ9iAYoFKRaiWJhiEYqAwlGEFAmKJEWKIk2RoYgoshSLUixGsTjFEhRLUixFsTTFMhTLVi+GOT1E5vK0ze1pm8fTNq+nbT5P2/yetgU8bQt62hbytC3saVvE0xZ42pynLfS0JTxtSU9bytOW9rRlPG2Rpy3raVvU07aYp21xT9sSnrYlPW1LedqW9rQt42lbdhIWw3L0tctTrECxIsVKFCtTrEKxKsVqFKtTrEGxJsVaFGtTrEOxLsV6FOtTbECxIcVGFBtTbEKxKcVmFJtTbEGxJcVWFFtT5KoXw3IeIst72lbwtK3oaVvJ07ayp20VT9uqnrbVPG2re9rW8LSt6Wlby9O2tqdtHU/bup629Txt63vaNvC0behp28jTtrGnbRNP26aets08bZt72rbwtG3padvK07a1py03CYshT19boChSlCjKFNtQbEuxHcX2FDtQ7EixE8XOFLtQ7EqxG8XuFHtQ7EmxF8XeFPtQ7EuxH8X+FAdQHEhxEMXBFIdQDK1eDHkPkYKnrehpK3nayp62bTxt23ratvO0be9p28HTtqOnbSdP286etl08bbt62nbztO3uadvD07anp20vT9venrZ9PG37etr287Tt72k7wNN2oKftIE/bwZ62QzxtQydhMRxKX3sYxeEUR1AcSXEUxdEUx1AcS3EcxfEUJ1CcSHESxckUp1CcSnEaxekUZ1CcSXEWxdkU51CcS3EexfkUF1BcSHERxcXVi+FQD5HDPG2He9qO8LQd6Wk7ytN2tKftGE/bsZ624zxtx3vaTvC0nehpO8nTdrKn7RRP26mettM8bad72s7wtJ3paTvL03a2p+0cT9u5nrbzPG3ne9ou8LRd6Gm7yNN28SQshkvoay+luIzicoorKK6kuIriaoprKK6luI7ieoobKG6kuIniZophFLdQ3EpxG8XtFHdQ3EkxnOIuirspRlCMpLiH4l6KUdWL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",
      "debug_symbols": "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taCON7Wgjjet38OkCW9qQR1vakEdb2pBHW9qQV2gbkAdb2pBHW9qQR1vakEdb1rfm6YJb2pAPeBNLajjTS2o400tqONNDXqYIFA3oI43taCON7Wgjje1oI43taCONzWgHvGmFtTxphbU8aYG3jTiTS2oC9QNqONNLajjTS2o400tehi8qQV1vKkB9YQ3taCON7Wgjje1oI43taAuUDegjje1oI43NfCmCW9qQR1vakEdb2pAXfCmFtTxpgY9jOBNLajjTS2oC9QNqONNLajjTS2o400tqONNLajjTQ2oz3hTA286400tqONNLajjTS2oC9QNqONNLXoYvKkFdbypBXW8qQV1vKkB9QVvakEdb2pBHW9qQR1vakFdoF7fmy54UwvqeFML6nhTC+p4UwvqeFODHmbFm1pQx5taUMebWlDHm1pQF6gbUMebWlDHm1pQx5taUMebGnjTFW9qQH3Dm1pQx5taUMebWlDHmxr0MJtA3YA63tSCOt7Ugjre1II63tSCOt7UgHrGm1pQx5taUMebGnjTjDe1oC5QN6CON7Wgjje1oI43tehh8KYW1PGm9anLhDe1oI43taCON7Wgjje1oC5QN6CON7Wgjjet701lwptaUMebWlDHmxpQD3hTC+p4U4MeJuBNLajjTS2oC9QNqONNLajjTS2o400tqONNLajjTQ2oR7ypgTeNeFML6nhTC+p4UwvqAnUD6nhTix4Gb2pBHW9qQR1vakEdb2pAPeFNLajjTS2o400tqONNLagL1Ot704Q3taCON7Wgjje1oI43taCONzXoYQRvakEdb2pBHW9qQR1vakFdoG5AHW9qQR1vakEdb2pBHW9q4E0Fb2pAfcabWlDHm1pQx5taUMebGvQws0DdgDre1II63tSCOt7Ugjre1II63tSA+oI3taCON7Wgjjc18KYL3tSCukDdgDre1II63tSCOt7UoofBm1rUOt7UgPqKN7Wgjje1oI43taCONzXoYVaBukGt400tqONNLajjTS2o400tqONNDXqYDW9qQR1vakEdb2pBHW/6FuoS90lKXH9QF6i/gfqSp/B19ZLDN+o/L96iyNfFW1ziD4kwss1LhOttXiIscvMS4aeblwjz3bpEGafevETY+uYlIgNoXiICg+YlEiRqXSLSheYlIl1oXiLSheYlIl1oXiLShcYlmifSheYlIl1oXiLSheYlIl1oXiJBotYlIl1oXiLSheYlIl1oXiLSheYlIl1oXaJAutC8RKQLzUtEutC8RKQLzUskSNS6RKQLzUtEutC8RKQLzUtEuvAOic5PGpgDgYEB9UgGYEEdW/8e6md/8z5HnLoFdcy3BXWBugF1LLIFdVyvRQ+DkbWgjje1oI43NfheT3hTC+p4UwvqeFML6nhTC+oCdQPqeFML6nhTg3494U0tqONNLajjTQ2oC97Ugjre1KCHEbypBXW8qQV1gboBdbypBXW8qQV1vKkFdbypBXW8qQH1GW9q4E1nvKkFdbypBXW8qQV1gboBdbypRQ+DN7Wgjje1oI43taCONzWgvuBNLajjTS2o400tqONNLagL1Ot70wVvakEdb2pBHW9qQR1vakEdb2rQw6x4UwvqeFML6nhTC+p4UwvqAnUD6nhTC+p4UwvqeFML6nhTA2+64k0NqG94UwvqeFML6nhTC+p4U4MeZhOoG1DHm1pQx5taUMebWlDHm1pQx5saUM94UwvqeFML6nhTA2+a8aYW1AXqBtTxphbU8aYW1PGmFj0M3tSCOt60PvVlwptaUMebWlDHm1pQx5taUBeoG1DHm1pQx5vW96bLhDe1oI43taCONzWgHvCmFtTxpgY9TMCbWlDHm1pQF6gbUMebWlDHm1pQx5taUMebWlDHmxpQj3hTA28a8aYW1PGmFtTxphbUBeoG1PGmFj0M3tSCOt7Ugjre1II63tSAesKbWlDHm1pQx5taUMebWlAXqNf3pglvakEdb2pBHW9qQR1vakEdb2rQwwje1II63tSCOt7Ugjre1IK6QN2AOt7Ugjre1II63tSCOt7UwJsK3tSA+ow3taCON7Wgjje1oI43NehhZoG6AXW8qQV1vKkFdbypBXW8qQV1vKkB9QVvakEdb2pBHW9q4E0XvKkFdYG6AXW8qQV1vKkFdbypRQ+DN7Wgjjc1oL7iTS2o400tqONNLajjTS2oC9QNqONNLajjTQ286Yo3taCON7Wgjjc1oL7hTS2o400NepgNb2pBHW9qQV2gbkAdb2pBHW9qQR1vakEdb2pBHW9qQD3jTQ28acabWlDHm1pQx5taUBeoG1DHm1r0MHhTC+p4UwvqeFML6njT+tTXCW9qQR1vakEdb2pBHW9qQV2gXt2brhPe1II63tSCOt7Ugjre1II63tSghwl4UwvqeFML6nhTC+p4UwvqAnUD6nhTC+p4UwvqeFML6nhTA28a8KYG1CPe1II63tSCOt7Ugjre1KCHiQJ1A+p4UwvqeFML6nhTC+p4UwvqeFMD6glvakEdb2pBHW9q4E0T3tSCukDdgDre1II63tSCOt7UoofBm1pQx5saUBe8qQV1vKkFdbypBXW8qQV1gboBdbypBXW8qYE3FbypBXW8qQV1vKkB9RlvakEdb2rQw8x4UwvqeFML6gJ1A+p4UwvqeFML6nhTC+p4UwvqeFMD6gve1MCbLnhTC+p4UwvqeFML6gJ1A+p4U4seBm9qQR1vakEdb2pBHW9qQH3Fm1pQx5taUMebWlDHm1pQF6jX96Yr3tSCOt7Ugjre1II63tSCOt7UoIfZ8KYW1PGmFtTxphbU8aYW1AXqBtTxphbU8aYW1PGmFtTxpgbedMObGlDPeFML6nhTC+p4UwvqeFODHiYL1A2o400tqONNLajjTS2o400tqONN61PfJrypBXW8qQV1vGl9b7pNeFML6gJ1A+p4UwvqeFML6nhTix4Gb2pBHW9qQD3gTS2o400tqONNLajjTS2oC9QNqONNLajjTQ28acCbWlDHm1pQx5saUI94UwvqeFODHibiTS2o400tqAvUDajjTS2o400tqONNLajjTS2o400NqCe8qYE3TXhTC+p4UwvqeFML6gJ1A+p4U4seBm9qQR1vakEdb2pBHW9qQF3wphbU8aYW1PGmFtTxphbUBer1vangTS2o400tqONNLajjTS2o400NepgZb2pBHW9qQR1vakEdb2pBXaBuQB1vakEdb2pBHW9qQR1vauBNZ7ypAfUFb2pBHW9qQR1vakEdb2rQwywCdQPqeFML6nhTC+p4UwvqeFML6nhTA+or3tSCOt7Ugjre1MCbrnhTC+oCdQPqeFML6nhTC+p4U4seBm9qQR1vakB9w5taUMebWlDHm1pQx5taUBeoG1DHm1pQx5saeNMNb2pBHW9qQR1vakA9400tqONNDXqYjDe1oI43taAuUDegjje1oI43taCON7Wgjje1oI43rU89T3jT+t40T3hTC+p4UwvqeFML6gJ1A+p4U4seBm9qQR1vakEdb2pBHW9qQD3gTS2o400tqONNLajjTS2oC9Tre9OAN7Wgjje1oI43taCON7Wgjjc16GEi3tSg1iPe1II63tSC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iW75fv78lJfw42VPSObtdg59CNP0g+SaL71sm669LF6a2/HduvLLniycnNPDIOcfL5uvvWy59rL12suO5f64NN9fFh8F+C8X5MoVPuT4YEntDwl//iHn9/XW4wMDdT8ivf8j5Lcf8fmy+drLlmsvWy99++RrX5H50lfkNk3XXhauvSxee1m69jK59rL52suWSy97cvvnw2fcXrWuj3/yedSaxY+bq19XxzXGHx8R3v8R8f0fkd7/EfL+j5jf/xHL+z9iff9HbO//iPz2j4jvX93x/as7vn91x/ev7vj+1R3fv7rj+1d3fP/qju9f3fH9qzv9enV/vixce1m89rJ07WVy7WXztZct1162XnvZdu1l+dLL5FqVyLUqkWtVIteqRK5ViVyrErlWJXKtSuRalci1KpmvVcl8rUrma1UyX6uS+VqVzNeqZL5WJfO1KpmvVcl8rUqWa1WyXKuS5VqVLNeqZLlWJcu1KlmuVclyrUqWa1WyXKuS9VqVrNeqZL1WJeu1KlmvVcl6rUrWa1WyXquS9VqVrNeqZLtWJdu1KtmuVcl2rUq2a1WyXauS7VqVbNeqZLtWJdu1KsnXqiRfq5J8rUrytSrJ16okX6uSfK1K8rUqydeqJF+qkjxN114Wrr0sXntZuvYyufay+drLlmsvW6+9bLv2smtVEq5VSbhWJeFalYRrVRKuVUm4ViXhWpWEa1USrlVJuFYl8VqVxGtVEq9VSbxWJfFalcRrVRKvVUm8ViXxWpXEa1VyLXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zZey13m6lL1+vCxce1m89rJ07WVy7WXztZct1162XnvZdu1l16okXKuScK1KwrUqCdeq5En2mvcf74UPR3/wsidVsq77y3L89rKjE2eVnmfxMZylreGs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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "is_minter",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "minter",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8359297168692325491": {
            "error_kind": "string",
            "string": "Function is_minter can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHxgAAwACgEguCIBIAAElAAAASyUAAABvLgQAAYBJKAIAAgSASScCAwQBOw0AAgADKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAnQeAgACAB4CAAMAMzgAAgADAAQkAgAEAAAAkyUAAAKdHgIAAgknAgMAAQo4AgMEJAIABAAAAK8lAAACrycCAgAALQgBAycCBAQEABABBAEnAwMEAQAoAwIELQwEBS0OAgUAKAUCBS0OAgUAKAUCBS0OAgUtDQMEACgEAgQtDgQDKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy0OAgcAKAcCBy0OAgcAKAcCBy0OAgcAKAcCBy0OBActDQMEACgEAgQtDgQDLQ0FBAAoBAIELQ4EBS0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgqARQAFLQgBBgAAAQIBLgqARAAGJwIHAAYnAggECS0IAAktDAQKLQwDCy0MBQwtDAYNLQwHDgAQAAgAJQAAAsEtBAAAJwIHBAgtCAAILQwECS0MAwotDAULLQwGDC0MAQ0AEAAHACUAAALBLQQAAC0NBgELKAABgEQAByQCAAcAAAINJwIIBAA8CQEIJwIBBActCAAHLQwECC0MAwktDAUKLQwGCwAQAAEAJQAAA+otBAAALQ0DAQEoAAGARwAELQ0EAwo4AwIBCygAAYBEAAIkAgACAAACXiUAAAT9LwwAAwABHAwBAwEcDAMCABwMAgEBJigAgAQEeAANAAAAgASAAyQAgAMAAAKcKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQV0AjB8R9WsczwBAQImJQAAAnQtDQMGLQ0EBwsoAAeARAAIJAIACAAAAucnAgkEADwJAQkLKAAGgEMAByQCAAcAAAN2IwAAAvwtDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADISUAAAUPLgQABoADKACABAQABCUAAAUhLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA2ElAAAFry0OCgEtDgcCLQ4FAy0OCQQjAAAD6ScCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPqLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFIS4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA+kmJQAAAnQuCIBFAAUjAAAD+g0oAAWAQwAGJAIABgAABGojAAAEDy0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAASIIwAABPQtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUhLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABPQtDAYFIwAAA/oqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAU8IwAABUcuAIADgAUjAAAFri4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWaLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVpKAGABQQAAQMAgAYAAoAGIwAABa4mKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3dTuM6EMffpde98Iw/xt5XWR0hYLuoUtWiAkc6Qrz7SaFOQjOJybjaFcrcIELnX09+sT3jKbVfV782dy8PN9v978PT6sfP19XucH/7vD3sm6vXt/Xq7rjd7bYPN/0/r8zpB0B4Fzw93u5P10/Pt8fn1Q+w6M16tdn/Ov1uo2/e5Pd2t2muwL2th/YGMZsbhz1rYKxdCHC2doFMa02JMY7e+LNx9Ah943/WK0C4jv8pZXOA9Cf9vxJ/H1v+scQfPFG2DtZO+598yjebgnWX/lt3bf8BP/t/asXhH2mF2FaweWxZht7ZQivUdKazOTX2BboY8sBJGP0lXY9f8ejzfb/rSKYLwvbICHWe07mmU7bjy3dDxhv2oQbbDd3ewyHLdv1wNkbTdQBrPfcgk8sjl1Lq3hlTZKwt5a7oeqMEOZcRIb8xYm/8scbe5bHqXeybnvhFo/yq+DnlV8UvKb8afkn7Xx0/7X81/NBo/6vjF5VfDT9A5VfFj5RfDT++eqD8vswvKL8aflbXb0V+MZcQfK+wlfk55VfFT/PnKn7OKr8Cv9Dahs+mJ35Bx28dP11/VPEjHb91/LT/VfGL2v/q+Gn/q+KXtP5Sx0/XvzX8rNH6Sx0//fy8ih9o/aWOn1N+Vfy0/lLFDzV/ZqDoh0JDKFYzXQaKpq9DKE5zAgaKJpoMFI3eQyheQzIDRetUQyhBQzIDRUPyEAppmYiBoiGZgaIheQhFv+XAQEma5jNQtKcwUHROGUBxC/3kwUJ2GS2GSygL/TihAEV7CgNlmXPKNJSFVvMLUJZZzZ+GYpe5ICxA0YmWgaIT7RCKcwplCEV7yhDKQqv5BSjLrOZPQ1loNb8AZZnV/GkopKtkBoqGZAaKTrRDKFEnWgaKrpKHUBb67Y4ClGWGZHLZFsnLjRuC3iwzfs8hCCG6fH9kcEBwmXHtigRBR3ElwYVufXNNgsust84iSKndaTjCZSz2C93+5poEnRKsJKixuJKgW+Yy45oENZupJOg1ktQS1GymkmDQPlhL0CnBSoKazRQJphYGJDcgSBqLKwle41AKiO1JLdg/N4Ql6H3KzoeInfMAxDFsD+8h6jZkhYgfzvtv7Hyy39f5cI29gP6e8+VZI7iS8+3Ybjwwn5pg3PFtbYqCKZwyRDZmP8j1Dj5ijZsZi0LriDOpb3661y9s2n7te6XuXtFMu+8pH6jkY+e69fbDd/q+vuP35U78NyPAtFEHTE/1EUiI312oJGIzIADvuhu/LOXSyCls06KRo88KoiQQ8dsMN7NdO07RDEDwyTS47kiu/lSQRVEgIpSIgkDEpxYlkeSeksC9yIew5tm2D9cTDEQkEI0MjYIoCUT8pxwFEV/YL4lELY3cU2oz1ACXX16LIwf9TYtGzuKbFgUjEXmJSAKC3/+4JJLQiyPnXHYrCesH4ymBROQlojRflIyViEggApCIBMgTSlpCLxFJkFsJcjuCPLSLBRsvJ5Y0EnOnRXwZuiTyAlEAiSgIRPx/ppZEgpibIkpEgkCdkqAlMHxq2Sy/2iTZDTR8fEptgShRGGj4rlfQ0HyNB4HGz8/Jm3qYEamcSJUkKhK1RaK2oqitKGorSdoCY0QqWVuS+2qKFCIVSVQjMbGkkowU4DPnyTlm5AzuJirncewYzfx5CfhRPN1OEPjGL0KnNfwatKAJ8xlEEGgE7fDb06SY+8Gn6n/W+NkaNEagcYX74TTz+xvyO0dMa/giWUEzP3aitQJNnK8R5AIoyAVQkAugFzwfP7MfvDVX/94et7d3u81Tozi9+LK/f94e9ufL5/8e8yt3x+1ut324eTwe7je/Xo6bm93h/vTaypx//ERPa6T4HhubywbWGjC9D5/Tq5TWGKFptWn5fw==",
      "brillig_names": [
        "is_minter"
      ]
    },
    {
      "name": "transfer_in_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "transfer_in_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "NFTNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "token_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "NFT"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_nfts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nft_exists",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_owners",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::NFTTransfer"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finalize_transfer_to_private_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finalize_transfer_to_private_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "minter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "approve",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_minter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_minter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::finalize_transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::finalize_transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::owner_of_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::owner_of_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_store_nft_set_partial_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_store_nft_set_partial_note_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "minter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::is_minter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::is_minter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::prepare_private_balance_increase_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::nft_note::PartialNFTNote"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::prepare_private_balance_increase_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::cancel_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::cancel_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finish_transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finish_transfer_to_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "101": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "102": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "106": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "107": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "111": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "114": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "116": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "117": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "119": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "121": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "123": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "124": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "125": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "126": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "133": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "134": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "139": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "141": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "144": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "147": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "148": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteType;\nuse dep::protocol_types::traits::{Packable, ToField};\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteType + Packable<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "150": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "153": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "154": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "156": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "157": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "158": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "163": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "164": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "165": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "166": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "168": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "169": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "171": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "173": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "179": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "182": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "196": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "197": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "199": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "200": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "201": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "202": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "203": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "205": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "207": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "208": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "211": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "235": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "237": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "280": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "295": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "298": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "299": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "312": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "314": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "315": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "324": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "349": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "353": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "354": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "370": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "371": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "373": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "379": {
      "path": "/Users/0xandee/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "381": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/0xandee/Documents/Github/tezac/nft_contract/src/main.nr",
      "source": "// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal NFT implementation with `AuthWit` support that allows minting in public-only and transfers in both public\n// and private.\n#[aztec]\npub contract NFT {\n    use crate::types::nft_note::{NFTNote, PartialNFTNote};\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    use dep::aztec::{\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, utility, view},\n            storage::storage,\n        },\n        messages::logs::note::encode_and_encrypt_note,\n        note::{constants::MAX_NOTES_PER_PAGE, note_interface::NoteProperties},\n        prelude::{\n            AztecAddress, Map, NoteGetterOptions, NoteViewerOptions, PrivateContext, PrivateSet,\n            PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::traits::Serialize,\n        utils::comparison::Comparator,\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use aztec::protocol_types::traits::ToField;\n    use std::meta::derive;\n\n    // docs:end:imports\n\n    // TODO(#8467): Rename this to Transfer - calling this NFTTransfer to avoid export conflict with the Transfer event\n    // in the Token contract.\n    #[derive(Serialize)]\n    #[event]\n    struct NFTTransfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        token_id: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // The symbol of the NFT\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        // The name of the NFT\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // The admin of the contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Addresses that can mint\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // Contains the NFTs owned by each address in private.\n        private_nfts: Map<AztecAddress, PrivateSet<NFTNote, Context>, Context>,\n        // A map from token ID to a boolean indicating if the NFT exists.\n        nft_exists: Map<Field, PublicMutable<bool, Context>, Context>,\n        // A map from token ID to the public owner of the NFT.\n        public_owners: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.admin.write(new_admin);\n    }\n    // docs:end:set_admin\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.minters.at(minter).write(approve);\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint\n    #[public]\n    fn mint(to: AztecAddress, token_id: Field) {\n        assert(token_id != 0, \"zero token ID not supported\");\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not a minter\");\n        assert(storage.nft_exists.at(token_id).read() == false, \"token already exists\");\n\n        storage.nft_exists.at(token_id).write(true);\n\n        storage.public_owners.at(token_id).write(to);\n    }\n    // docs:end:mint\n\n    #[public]\n    #[view]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid owner\");\n\n        public_owners_storage.write(to);\n    }\n    // docs:end:transfer_in_public\n\n    // Transfers token with `token_id` from public balance of message sender to a private balance of `to`.\n    // docs:start:transfer_to_private\n    #[private]\n    fn transfer_to_private(to: AztecAddress, token_id: Field) {\n        let from = context.msg_sender();\n\n        let nft = NFT::at(context.this_address());\n\n        // We prepare the private balance increase.\n        let partial_note = _prepare_private_balance_increase(to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own NFTs.\n        nft._finalize_transfer_to_private_unsafe(from, token_id, partial_note).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_private\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// `finalize_transfer_to_private` with the returned partial note.\n    // docs:start:prepare_private_balance_increase\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress) -> PartialNFTNote {\n        _prepare_private_balance_increase(to, &mut context, storage)\n    }\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> PartialNFTNote {\n        // We create a partial note with unpopulated/zero token id for 'to'\n        let partial_note = NFTNote::partial(\n            to,\n            storage.private_nfts.at(to).storage_slot,\n            context,\n            to,\n            context.msg_sender(),\n        );\n\n        NFT::at(context.this_address())._store_nft_set_partial_note(partial_note).enqueue(context);\n\n        partial_note\n    }\n    // docs:end:prepare_private_balance_increase\n\n    // docs:start:store_payload_in_transient_storage_unsafe\n    #[public]\n    #[internal]\n    fn _store_nft_set_partial_note(partial_note: PartialNFTNote) {\n        // We store the partial note in a slot equal to its commitment. This is safe because the commitment is computed\n        // using a generator different from the one used to compute storage slots, so there can be no collisions.\n        // We could consider storing all pending partial notes in e.g. some array, but ultimately this is pointless: all\n        // we need to verify is that the note is valid.\n        context.storage_write(partial_note.commitment(), true);\n    }\n    // docs:end:store_payload_in_transient_storage_unsafe\n    /// Finalizes a transfer of NFT with `token_id` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `partial_note` must be passed as an argument to this function.\n    // docs:start:finalize_transfer_to_private\n    #[public]\n    fn finalize_transfer_to_private(token_id: Field, partial_note: PartialNFTNote) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, token_id, partial_note, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        token_id: Field,\n        partial_note: PartialNFTNote,\n    ) {\n        _finalize_transfer_to_private(from, token_id, partial_note, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        token_id: Field,\n        partial_note: PartialNFTNote,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid NFT owner\");\n\n        // Set the public NFT owner to zero\n        public_owners_storage.write(AztecAddress::zero());\n\n        // We verify that the partial note we're completing is valid (i.e. it uses the correct state variable's storage\n        // slot, and it is internally consistent). We *could* clear the storage since each partial note should only be\n        // used once, but since the AVM offers no gas refunds for doing so this would just make the transaction be more\n        // expensive.\n        assert(context.storage_read(partial_note.commitment()), \"Invalid partial note\");\n        partial_note.complete(token_id, context);\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let nfts = storage.private_nfts;\n\n        let notes = nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring\");\n\n        let new_note = NFTNote::new(token_id, to);\n\n        nfts.at(to).insert(new_note).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let notes = storage.private_nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring to public\");\n\n        NFT::at(context.this_address())._finish_transfer_to_public(to, token_id).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:finish_transfer_to_public\n    #[public]\n    #[internal]\n    fn _finish_transfer_to_public(to: AztecAddress, token_id: Field) {\n        storage.public_owners.at(token_id).write(to);\n    }\n    // docs:end:finish_transfer_to_public\n\n    // Returns zero address when the token does not have a public owner. Reverts if the token does not exist.\n    #[public]\n    #[view]\n    fn owner_of(token_id: Field) -> AztecAddress {\n        assert(storage.nft_exists.at(token_id).read(), \"token does not exist\");\n        storage.public_owners.at(token_id).read()\n    }\n\n    /// Returns an array of token IDs owned by `owner` in private and a flag indicating whether a page limit was\n    /// reached. Starts getting the notes from page with index `page_index`. Zero values in the array are placeholder\n    /// values for non-existing notes.\n    // docs:start:get_private_nfts\n    #[utility]\n    unconstrained fn get_private_nfts(\n        owner: AztecAddress,\n        page_index: u32,\n    ) -> ([Field; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.private_nfts.at(owner).view_notes(options.set_offset(offset));\n\n        let mut owned_nft_ids = [0; MAX_NOTES_PER_PAGE];\n        for i in 0..options.limit {\n            if i < notes.len() {\n                owned_nft_ids[i] = notes.get_unchecked(i).token_id;\n            }\n        }\n\n        let page_limit_reached = notes.len() == options.limit;\n        (owned_nft_ids, page_limit_reached)\n    }\n    // docs:end:get_private_nfts\n}\n"
    },
    "59": {
      "path": "/Users/0xandee/Documents/Github/tezac/nft_contract/src/types/nft_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize},\n        utils::arrays::array_concat,\n    },\n};\n\n// NFTNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the token id).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n// docs:start:nft_note\n/// A private note representing a token id associated to an account.\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct NFTNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of NFTPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The ID of the token represented by this note.\n    token_id: Field,\n}\n// docs:end:nft_note\n\nimpl NoteHash for NFTNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because NFTNote has just one variant (where the token id is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            NFTPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note =\n            PartialNFTNote { commitment: private_content.compute_partial_commitment(storage_slot) };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.token_id)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl NFTNote {\n    pub fn new(token_id: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { token_id, owner, randomness }\n    }\n\n    pub fn get_token_id(self) -> Field {\n        self.token_id\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the token id, since the note will be\n    /// later completed in public. This is a powerful technique for scenarios in which the token id cannot be known in\n    /// private (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialNFTNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialNFTNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = NFTPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateNFTPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialNFTNote { commitment }\n    }\n}\n\n/// The private content of a partial NFTNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct NFTPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of NFTNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NFTPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateNFTPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of NFTNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateNFTPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        NFTNote::get_id()\n    }\n}\n\n/// A partial instance of a NFTNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the token id field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the token id to the public), resulting in a NFTNote that can be used like any other one (except\n/// of course that its token id is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialNFTNote {\n    commitment: Field,\n}\n\nimpl PartialNFTNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialNFTNote {\n    /// Completes the partial note, creating a new note that can be used like any other NFTNote.\n    pub fn complete(self, token_id: Field, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(token_id != 0, \"Cannot complete a PartialNFTNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the token id). The contract will later find it by\n        //  searching for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(token_id));\n        context.push_note_hash(self.compute_complete_note_hash(token_id));\n    }\n\n    fn compute_note_completion_log(self, token_id: Field) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, token_id]\n    }\n\n    fn compute_complete_note_hash(self, token_id: Field) -> Field {\n        // Here we finalize the note hash by including the (public) token id into the partial note commitment. Note that\n        // we use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator([self.commitment, token_id], GENERATOR_INDEX__NOTE_HASH)\n    }\n}\n\nmod test {\n    use super::{\n        NFTNote, NFTPartialNotePrivateContent, PartialNFTNote,\n        PrivateNFTPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global token_id: Field = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a NFTNote has the same note hash as a PartialNFTNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = NFTNote { token_id, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = NFTPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialNFTNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(token_id);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular NFTNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular NFTNote.\n\n        let note = NFTNote { token_id, randomness, owner };\n\n        let partial_note_private_content = NFTPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateNFTPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialNFTNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(token_id)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in NFTNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(token_id), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "70": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "71": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "78": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "79": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "80": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "81": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "97": {
      "path": "/Users/0xandee/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    }
  }
}
